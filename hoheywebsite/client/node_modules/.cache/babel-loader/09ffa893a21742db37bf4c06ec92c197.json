{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst assert_1 = require(\"@0x/assert\");\n\nconst utils_1 = require(\"@0x/utils\");\n\nconst EthereumTx = require(\"ethereumjs-tx\");\n\nconst types_1 = require(\"../types\");\n\nconst base_wallet_subprovider_1 = require(\"./base_wallet_subprovider\");\n\nconst DEFAULT_NUM_ADDRESSES_TO_FETCH = 1;\nconst MAINNET_ID = 1;\nconst ROPSTEN_ID = 3;\nconst RINKEBY_ID = 4;\nconst KOVAN_ID = 42;\nconst GOERLI_ID = 6284; // Get the network name given an ID. This network is only used for connecting to\n// the Lattice. Generally, `mainnet` corresponds to a production Lattice\n\nfunction getNetwork(networkId) {\n  switch (networkId) {\n    // Only known testnet IDs can be used to find development Lattices.\n    case ROPSTEN_ID:\n    case RINKEBY_ID:\n    case KOVAN_ID:\n    case GOERLI_ID:\n      return 'testnet';\n    // Mainnet and all custom chainIDs are used to find production Lattices.\n\n    case MAINNET_ID:\n    default:\n      return 'mainnet';\n  }\n}\n\nclass LatticeSubprovider extends base_wallet_subprovider_1.BaseWalletSubprovider {\n  /**\n   * Instantiates a LatticeSubprovider. Private key path is set to `44'/60'/0'/0/`.\n   * This subprovider must be initialized with the GridPlus `eth-lattice-keyring` module as\n   * the `config.latticeConnectClient` object: https://www.npmjs.com/package/eth-lattice-keyring\n   */\n  constructor(config) {\n    super();\n    const opts = {\n      name: config.appName,\n      network: getNetwork(config.networkId)\n    };\n    this._latticeConnectClient = new config.latticeConnectClient(opts);\n  }\n  /**\n   * Fetches the current Lattice wallet Ethereum address at path `44'/60'/0'/0/0`. Only the 0-th index address\n   * may be fetched, but the Lattice user may switch wallets on their device at any time, in which case this\n   * function would return a new address (in the form of a 1-element string array).\n   * @param numberOfAccounts number of accounts to fetch. Currently this is ignored in the connect client, as only one address may be fetched at a time\n   * @return A one-element array of addresses representing the current Lattice wallet's Ethereum account.\n   */\n\n\n  getAccountsAsync(numberOfAccounts = DEFAULT_NUM_ADDRESSES_TO_FETCH) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const accounts = yield this._latticeConnectClient.addAccounts(numberOfAccounts);\n        return accounts;\n      } catch (err) {\n        throw err;\n      }\n    });\n  }\n  /**\n   * Signs a transaction from the account specified by the `from` field in txParams.\n   * @param txParams Parameters of the transaction to sign.\n   * @return Signed transaction hex string. This is a serialized `ethereum-tx` Transaction object.\n   */\n\n\n  signTransactionAsync(txData) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (txData.from === undefined || !utils_1.addressUtils.isAddress(txData.from)) {\n        throw new Error(types_1.WalletSubproviderErrors.FromAddressMissingOrInvalid);\n      }\n\n      const txReq = new EthereumTx(txData);\n\n      try {\n        const signedTx = yield this._latticeConnectClient.signTransaction(txData.from, txReq);\n        return `0x${signedTx.serialize().toString('hex')}`;\n      } catch (err) {\n        throw err;\n      }\n    });\n  }\n  /**\n   * Sign a personal Ethereum message from the account specified in the `address` param.\n   * @param data Data to be signed. May be represented in hex or ASCII; this representation will be preserved.\n   * @param address Address from which to sign. Must be the address at `m/44'/60'/0'/0/0` of the current wallet.\n   * @return Signature hex string of form `0x{r}{s}{v}\n   */\n\n\n  signPersonalMessageAsync(data, address) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (data === undefined) {\n        throw new Error(types_1.WalletSubproviderErrors.DataMissingForSignPersonalMessage);\n      }\n\n      assert_1.assert.isHexString('data', data);\n      assert_1.assert.isETHAddressHex('address', address);\n\n      try {\n        const sig = yield this._latticeConnectClient.signPersonalMessage(address, data);\n        return sig;\n      } catch (err) {\n        throw err;\n      }\n    });\n  }\n  /**\n   * Sign a typed data message from the account specified in the `address` param.\n   * @param address Address from which to sign. Must be the address at `m/44'/60'/0'/0/0` of the current wallet.\n   * @param typedData The data to be signed.\n   * @return Signature hex string of form `0x{r}{s}{v}\n   */\n\n\n  signTypedDataAsync(address, typedData) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (typedData === undefined) {\n        throw new Error(types_1.WalletSubproviderErrors.DataMissingForSignTypedData);\n      }\n\n      assert_1.assert.isETHAddressHex('address', address);\n\n      try {\n        const data = {\n          protocol: 'eip712',\n          payload: typedData\n        };\n        const sig = yield this._latticeConnectClient.signMessage(address, data);\n        return sig;\n      } catch (err) {\n        throw err;\n      }\n    });\n  }\n\n}\n\nexports.LatticeSubprovider = LatticeSubprovider;","map":{"version":3,"sources":["../../../src/subproviders/lattice.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert_1 = require(\"@0x/assert\");\nconst utils_1 = require(\"@0x/utils\");\nconst EthereumTx = require(\"ethereumjs-tx\");\nconst types_1 = require(\"../types\");\nconst base_wallet_subprovider_1 = require(\"./base_wallet_subprovider\");\nconst DEFAULT_NUM_ADDRESSES_TO_FETCH = 1;\nconst MAINNET_ID = 1;\nconst ROPSTEN_ID = 3;\nconst RINKEBY_ID = 4;\nconst KOVAN_ID = 42;\nconst GOERLI_ID = 6284;\n// Get the network name given an ID. This network is only used for connecting to\n// the Lattice. Generally, `mainnet` corresponds to a production Lattice\nfunction getNetwork(networkId) {\n    switch (networkId) {\n        // Only known testnet IDs can be used to find development Lattices.\n        case ROPSTEN_ID:\n        case RINKEBY_ID:\n        case KOVAN_ID:\n        case GOERLI_ID:\n            return 'testnet';\n        // Mainnet and all custom chainIDs are used to find production Lattices.\n        case MAINNET_ID:\n        default:\n            return 'mainnet';\n    }\n}\nclass LatticeSubprovider extends base_wallet_subprovider_1.BaseWalletSubprovider {\n    /**\n     * Instantiates a LatticeSubprovider. Private key path is set to `44'/60'/0'/0/`.\n     * This subprovider must be initialized with the GridPlus `eth-lattice-keyring` module as\n     * the `config.latticeConnectClient` object: https://www.npmjs.com/package/eth-lattice-keyring\n     */\n    constructor(config) {\n        super();\n        const opts = {\n            name: config.appName,\n            network: getNetwork(config.networkId),\n        };\n        this._latticeConnectClient = new config.latticeConnectClient(opts);\n    }\n    /**\n     * Fetches the current Lattice wallet Ethereum address at path `44'/60'/0'/0/0`. Only the 0-th index address\n     * may be fetched, but the Lattice user may switch wallets on their device at any time, in which case this\n     * function would return a new address (in the form of a 1-element string array).\n     * @param numberOfAccounts number of accounts to fetch. Currently this is ignored in the connect client, as only one address may be fetched at a time\n     * @return A one-element array of addresses representing the current Lattice wallet's Ethereum account.\n     */\n    getAccountsAsync(numberOfAccounts = DEFAULT_NUM_ADDRESSES_TO_FETCH) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const accounts = yield this._latticeConnectClient.addAccounts(numberOfAccounts);\n                return accounts;\n            }\n            catch (err) {\n                throw err;\n            }\n        });\n    }\n    /**\n     * Signs a transaction from the account specified by the `from` field in txParams.\n     * @param txParams Parameters of the transaction to sign.\n     * @return Signed transaction hex string. This is a serialized `ethereum-tx` Transaction object.\n     */\n    signTransactionAsync(txData) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (txData.from === undefined || !utils_1.addressUtils.isAddress(txData.from)) {\n                throw new Error(types_1.WalletSubproviderErrors.FromAddressMissingOrInvalid);\n            }\n            const txReq = new EthereumTx(txData);\n            try {\n                const signedTx = yield this._latticeConnectClient.signTransaction(txData.from, txReq);\n                return `0x${signedTx.serialize().toString('hex')}`;\n            }\n            catch (err) {\n                throw err;\n            }\n        });\n    }\n    /**\n     * Sign a personal Ethereum message from the account specified in the `address` param.\n     * @param data Data to be signed. May be represented in hex or ASCII; this representation will be preserved.\n     * @param address Address from which to sign. Must be the address at `m/44'/60'/0'/0/0` of the current wallet.\n     * @return Signature hex string of form `0x{r}{s}{v}\n     */\n    signPersonalMessageAsync(data, address) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (data === undefined) {\n                throw new Error(types_1.WalletSubproviderErrors.DataMissingForSignPersonalMessage);\n            }\n            assert_1.assert.isHexString('data', data);\n            assert_1.assert.isETHAddressHex('address', address);\n            try {\n                const sig = yield this._latticeConnectClient.signPersonalMessage(address, data);\n                return sig;\n            }\n            catch (err) {\n                throw err;\n            }\n        });\n    }\n    /**\n     * Sign a typed data message from the account specified in the `address` param.\n     * @param address Address from which to sign. Must be the address at `m/44'/60'/0'/0/0` of the current wallet.\n     * @param typedData The data to be signed.\n     * @return Signature hex string of form `0x{r}{s}{v}\n     */\n    signTypedDataAsync(address, typedData) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typedData === undefined) {\n                throw new Error(types_1.WalletSubproviderErrors.DataMissingForSignTypedData);\n            }\n            assert_1.assert.isETHAddressHex('address', address);\n            try {\n                const data = {\n                    protocol: 'eip712',\n                    payload: typedData,\n                };\n                const sig = yield this._latticeConnectClient.signMessage(address, data);\n                return sig;\n            }\n            catch (err) {\n                throw err;\n            }\n        });\n    }\n}\nexports.LatticeSubprovider = LatticeSubprovider;\n//# sourceMappingURL=lattice.js.map"]},"metadata":{},"sourceType":"module"}