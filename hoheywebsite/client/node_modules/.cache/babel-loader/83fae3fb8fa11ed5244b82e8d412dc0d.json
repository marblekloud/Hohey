{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.intervalUtils = {\n  setAsyncExcludingInterval(fn, intervalMs, onError) {\n    let isLocked = false;\n    const intervalId = setInterval(() => __awaiter(this, void 0, void 0, function* () {\n      if (isLocked) {\n        return;\n      } else {\n        isLocked = true;\n\n        try {\n          yield fn();\n        } catch (err) {\n          onError(err);\n        }\n\n        isLocked = false;\n      }\n    }), intervalMs);\n    return intervalId;\n  },\n\n  clearAsyncExcludingInterval(intervalId) {\n    clearInterval(intervalId);\n  },\n\n  setInterval(fn, intervalMs, onError) {\n    const intervalId = setInterval(() => {\n      try {\n        fn();\n      } catch (err) {\n        onError(err);\n      }\n    }, intervalMs);\n    return intervalId;\n  },\n\n  clearInterval(intervalId) {\n    clearInterval(intervalId);\n  }\n\n};","map":{"version":3,"sources":["../../src/interval_utils.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAa,OAAA,CAAA,aAAA,GAAgB;AACzB,EAAA,yBAAyB,CACrB,EADqB,EAErB,UAFqB,EAGrB,OAHqB,EAGQ;AAE7B,QAAI,QAAQ,GAAG,KAAf;AACA,UAAM,UAAU,GAAG,WAAW,CAAC,MAAW,SAAA,CAAA,IAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,aAAA;AACtC,UAAI,QAAJ,EAAc;AACV;AACH,OAFD,MAEO;AACH,QAAA,QAAQ,GAAG,IAAX;;AACA,YAAI;AACA,gBAAM,EAAE,EAAR;AACH,SAFD,CAEE,OAAO,GAAP,EAAY;AACV,UAAA,OAAO,CAAC,GAAD,CAAP;AACH;;AACD,QAAA,QAAQ,GAAG,KAAX;AACH;AACJ,KAZyC,CAAZ,EAY3B,UAZ2B,CAA9B;AAaA,WAAO,UAAP;AACH,GArBwB;;AAsBzB,EAAA,2BAA2B,CAAC,UAAD,EAAyB;AAChD,IAAA,aAAa,CAAC,UAAD,CAAb;AACH,GAxBwB;;AAyBzB,EAAA,WAAW,CAAC,EAAD,EAAiB,UAAjB,EAAqC,OAArC,EAAkE;AACzE,UAAM,UAAU,GAAG,WAAW,CAAC,MAAK;AAChC,UAAI;AACA,QAAA,EAAE;AACL,OAFD,CAEE,OAAO,GAAP,EAAY;AACV,QAAA,OAAO,CAAC,GAAD,CAAP;AACH;AACJ,KAN6B,EAM3B,UAN2B,CAA9B;AAOA,WAAO,UAAP;AACH,GAlCwB;;AAmCzB,EAAA,aAAa,CAAC,UAAD,EAAyB;AAClC,IAAA,aAAa,CAAC,UAAD,CAAb;AACH;;AArCwB,CAAhB","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.intervalUtils = {\n    setAsyncExcludingInterval(fn, intervalMs, onError) {\n        let isLocked = false;\n        const intervalId = setInterval(() => __awaiter(this, void 0, void 0, function* () {\n            if (isLocked) {\n                return;\n            }\n            else {\n                isLocked = true;\n                try {\n                    yield fn();\n                }\n                catch (err) {\n                    onError(err);\n                }\n                isLocked = false;\n            }\n        }), intervalMs);\n        return intervalId;\n    },\n    clearAsyncExcludingInterval(intervalId) {\n        clearInterval(intervalId);\n    },\n    setInterval(fn, intervalMs, onError) {\n        const intervalId = setInterval(() => {\n            try {\n                fn();\n            }\n            catch (err) {\n                onError(err);\n            }\n        }, intervalMs);\n        return intervalId;\n    },\n    clearInterval(intervalId) {\n        clearInterval(intervalId);\n    },\n};\n//# sourceMappingURL=interval_utils.js.map"]},"metadata":{},"sourceType":"module"}