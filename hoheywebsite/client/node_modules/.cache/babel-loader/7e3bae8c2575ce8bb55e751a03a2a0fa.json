{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/* tslint:disable max-classes-per-file */\n\nconst _ = require(\"lodash\");\n\nconst queue_1 = require(\"../utils/queue\");\n\nconst blob_1 = require(\"./blocks/blob\");\n\nconst pointer_1 = require(\"./blocks/pointer\");\n\nconst set_1 = require(\"./blocks/set\");\n/**\n * Iterator class for Calldata Blocks. Blocks follows the order\n * they should be put into calldata that is passed to he EVM.\n *\n * Example #1:\n * Let root = Set {\n *                  Blob{} A,\n *                  Pointer {\n *                      Blob{} a\n *                  } B,\n *                  Blob{} C\n *            }\n * It will iterate as follows: [A, B, C, B.a]\n *\n * Example #2:\n * Let root = Set {\n *                  Blob{} A,\n *                  Pointer {\n *                      Blob{} a\n *                      Pointer {\n *                          Blob{} b\n *                      }\n *                  } B,\n *                  Pointer {\n *                      Blob{} c\n *                  } C\n *            }\n * It will iterate as follows: [A, B, C, B.a, B.b, C.c]\n */\n\n\nclass BaseIterator {\n  static _createQueue(block) {\n    const queue = new queue_1.Queue(); // Base case\n\n    if (!(block instanceof set_1.SetCalldataBlock)) {\n      queue.pushBack(block);\n      return queue;\n    } // This is a set; add members\n\n\n    const set = block;\n\n    _.eachRight(set.getMembers(), member => {\n      queue.mergeFront(BaseIterator._createQueue(member));\n    }); // Add children\n\n\n    _.each(set.getMembers(), member => {\n      // Traverse child if it is a unique pointer.\n      // A pointer that is an alias for another pointer is ignored.\n      if (member instanceof pointer_1.PointerCalldataBlock && member.getAlias() === undefined) {\n        const dependency = member.getDependency();\n        queue.mergeBack(BaseIterator._createQueue(dependency));\n      }\n    }); // Put set block at the front of the queue\n\n\n    queue.pushFront(set);\n    return queue;\n  }\n\n  constructor(root) {\n    this._root = root;\n    this._queue = BaseIterator._createQueue(root);\n  }\n\n  [Symbol.iterator]() {\n    return {\n      next: () => {\n        const nextBlock = this.nextBlock();\n\n        if (nextBlock !== undefined) {\n          return {\n            value: nextBlock,\n            done: false\n          };\n        }\n\n        return {\n          done: true,\n          value: new blob_1.BlobCalldataBlock('', '', '', Buffer.from(''))\n        };\n      }\n    };\n  }\n\n}\n\nclass CalldataIterator extends BaseIterator {\n  constructor(root) {\n    super(root);\n  }\n\n  nextBlock() {\n    return this._queue.popFront();\n  }\n\n}\n\nexports.CalldataIterator = CalldataIterator;\n\nclass ReverseCalldataIterator extends BaseIterator {\n  constructor(root) {\n    super(root);\n  }\n\n  nextBlock() {\n    return this._queue.popBack();\n  }\n\n}\n\nexports.ReverseCalldataIterator = ReverseCalldataIterator;","map":{"version":3,"sources":["../../../../src/abi_encoder/calldata/iterator.ts"],"names":[],"mappings":";;;;;AAAA;;AACA,MAAA,CAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AAEA,MAAA,OAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AAEA,MAAA,MAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AACA,MAAA,SAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;;AACA,MAAA,KAAA,GAAA,OAAA,CAAA,cAAA,CAAA;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BG;;;AACH,MAAe,YAAf,CAA2B;AAII,SAAZ,YAAY,CAAC,KAAD,EAAqB;AAC5C,UAAM,KAAK,GAAG,IAAI,OAAA,CAAA,KAAJ,EAAd,CAD4C,CAE5C;;AACA,QAAI,EAAE,KAAK,YAAY,KAAA,CAAA,gBAAnB,CAAJ,EAA0C;AACtC,MAAA,KAAK,CAAC,QAAN,CAAe,KAAf;AACA,aAAO,KAAP;AACH,KAN2C,CAO5C;;;AACA,UAAM,GAAG,GAAG,KAAZ;;AACA,IAAA,CAAC,CAAC,SAAF,CAAY,GAAG,CAAC,UAAJ,EAAZ,EAA+B,MAAD,IAA0B;AACpD,MAAA,KAAK,CAAC,UAAN,CAAiB,YAAY,CAAC,YAAb,CAA0B,MAA1B,CAAjB;AACH,KAFD,EAT4C,CAY5C;;;AACA,IAAA,CAAC,CAAC,IAAF,CAAO,GAAG,CAAC,UAAJ,EAAP,EAA0B,MAAD,IAA0B;AAC/C;AACA;AACA,UAAI,MAAM,YAAY,SAAA,CAAA,oBAAlB,IAA0C,MAAM,CAAC,QAAP,OAAsB,SAApE,EAA+E;AAC3E,cAAM,UAAU,GAAG,MAAM,CAAC,aAAP,EAAnB;AACA,QAAA,KAAK,CAAC,SAAN,CAAgB,YAAY,CAAC,YAAb,CAA0B,UAA1B,CAAhB;AACH;AACJ,KAPD,EAb4C,CAqB5C;;;AACA,IAAA,KAAK,CAAC,SAAN,CAAgB,GAAhB;AACA,WAAO,KAAP;AACH;;AAED,EAAA,WAAA,CAAmB,IAAnB,EAAsC;AAClC,SAAK,KAAL,GAAa,IAAb;AACA,SAAK,MAAL,GAAc,YAAY,CAAC,YAAb,CAA0B,IAA1B,CAAd;AACH;;AAEsB,GAAf,MAAM,CAAC,QAAQ,IAAC;AACpB,WAAO;AACH,MAAA,IAAI,EAAE,MAAK;AACP,cAAM,SAAS,GAAG,KAAK,SAAL,EAAlB;;AACA,YAAI,SAAS,KAAK,SAAlB,EAA6B;AACzB,iBAAO;AACH,YAAA,KAAK,EAAE,SADJ;AAEH,YAAA,IAAI,EAAE;AAFH,WAAP;AAIH;;AACD,eAAO;AACH,UAAA,IAAI,EAAE,IADH;AAEH,UAAA,KAAK,EAAE,IAAI,MAAA,CAAA,iBAAJ,CAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,EAAkC,MAAM,CAAC,IAAP,CAAY,EAAZ,CAAlC;AAFJ,SAAP;AAIH;AAbE,KAAP;AAeH;;AAnDsB;;AAwD3B,MAAa,gBAAb,SAAsC,YAAtC,CAAkD;AAC9C,EAAA,WAAA,CAAmB,IAAnB,EAAsC;AAClC,UAAM,IAAN;AACH;;AAEM,EAAA,SAAS,GAAA;AACZ,WAAO,KAAK,MAAL,CAAY,QAAZ,EAAP;AACH;;AAP6C;;AAAlD,OAAA,CAAA,gBAAA,GAAA,gBAAA;;AAUA,MAAa,uBAAb,SAA6C,YAA7C,CAAyD;AACrD,EAAA,WAAA,CAAmB,IAAnB,EAAsC;AAClC,UAAM,IAAN;AACH;;AAEM,EAAA,SAAS,GAAA;AACZ,WAAO,KAAK,MAAL,CAAY,OAAZ,EAAP;AACH;;AAPoD;;AAAzD,OAAA,CAAA,uBAAA,GAAA,uBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* tslint:disable max-classes-per-file */\nconst _ = require(\"lodash\");\nconst queue_1 = require(\"../utils/queue\");\nconst blob_1 = require(\"./blocks/blob\");\nconst pointer_1 = require(\"./blocks/pointer\");\nconst set_1 = require(\"./blocks/set\");\n/**\n * Iterator class for Calldata Blocks. Blocks follows the order\n * they should be put into calldata that is passed to he EVM.\n *\n * Example #1:\n * Let root = Set {\n *                  Blob{} A,\n *                  Pointer {\n *                      Blob{} a\n *                  } B,\n *                  Blob{} C\n *            }\n * It will iterate as follows: [A, B, C, B.a]\n *\n * Example #2:\n * Let root = Set {\n *                  Blob{} A,\n *                  Pointer {\n *                      Blob{} a\n *                      Pointer {\n *                          Blob{} b\n *                      }\n *                  } B,\n *                  Pointer {\n *                      Blob{} c\n *                  } C\n *            }\n * It will iterate as follows: [A, B, C, B.a, B.b, C.c]\n */\nclass BaseIterator {\n    static _createQueue(block) {\n        const queue = new queue_1.Queue();\n        // Base case\n        if (!(block instanceof set_1.SetCalldataBlock)) {\n            queue.pushBack(block);\n            return queue;\n        }\n        // This is a set; add members\n        const set = block;\n        _.eachRight(set.getMembers(), (member) => {\n            queue.mergeFront(BaseIterator._createQueue(member));\n        });\n        // Add children\n        _.each(set.getMembers(), (member) => {\n            // Traverse child if it is a unique pointer.\n            // A pointer that is an alias for another pointer is ignored.\n            if (member instanceof pointer_1.PointerCalldataBlock && member.getAlias() === undefined) {\n                const dependency = member.getDependency();\n                queue.mergeBack(BaseIterator._createQueue(dependency));\n            }\n        });\n        // Put set block at the front of the queue\n        queue.pushFront(set);\n        return queue;\n    }\n    constructor(root) {\n        this._root = root;\n        this._queue = BaseIterator._createQueue(root);\n    }\n    [Symbol.iterator]() {\n        return {\n            next: () => {\n                const nextBlock = this.nextBlock();\n                if (nextBlock !== undefined) {\n                    return {\n                        value: nextBlock,\n                        done: false,\n                    };\n                }\n                return {\n                    done: true,\n                    value: new blob_1.BlobCalldataBlock('', '', '', Buffer.from('')),\n                };\n            },\n        };\n    }\n}\nclass CalldataIterator extends BaseIterator {\n    constructor(root) {\n        super(root);\n    }\n    nextBlock() {\n        return this._queue.popFront();\n    }\n}\nexports.CalldataIterator = CalldataIterator;\nclass ReverseCalldataIterator extends BaseIterator {\n    constructor(root) {\n        super(root);\n    }\n    nextBlock() {\n        return this._queue.popBack();\n    }\n}\nexports.ReverseCalldataIterator = ReverseCalldataIterator;\n//# sourceMappingURL=iterator.js.map"]},"metadata":{},"sourceType":"module"}