{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst json_schemas_1 = require(\"@0x/json-schemas\");\n\nconst utils_1 = require(\"@0x/utils\");\n\nconst _ = require(\"lodash\");\n\nconst validUrl = require(\"valid-url\");\n\nconst HEX_REGEX = /^0x[0-9A-F]*$/i;\nexports.assert = {\n  isBigNumber(variableName, value) {\n    const isBigNumber = utils_1.BigNumber.isBigNumber(value);\n    exports.assert.assert(isBigNumber, exports.assert.typeAssertionMessage(variableName, 'BigNumber', value));\n  },\n\n  isNumberLike(variableName, value) {\n    const isBigNumber = utils_1.BigNumber.isBigNumber(value);\n    const isNumber = typeof value === 'number';\n    exports.assert.assert(isBigNumber || isNumber, exports.assert.typeAssertionMessage(variableName, 'BigNumber | number', value));\n  },\n\n  isValidBaseUnitAmount(variableName, value) {\n    exports.assert.isBigNumber(variableName, value);\n    const isNegative = value.isLessThan(0);\n    exports.assert.assert(!isNegative, `${variableName} cannot be a negative number, found value: ${value.toNumber()}`);\n    const hasDecimals = value.decimalPlaces() !== 0;\n    exports.assert.assert(!hasDecimals, `${variableName} should be in baseUnits (no decimals), found value: ${value.toNumber()}`);\n  },\n\n  isString(variableName, value) {\n    exports.assert.assert(_.isString(value), exports.assert.typeAssertionMessage(variableName, 'string', value));\n  },\n\n  isFunction(variableName, value) {\n    exports.assert.assert(_.isFunction(value), exports.assert.typeAssertionMessage(variableName, 'function', value));\n  },\n\n  isHexString(variableName, value) {\n    exports.assert.assert(_.isString(value) && HEX_REGEX.test(value), exports.assert.typeAssertionMessage(variableName, 'HexString', value));\n  },\n\n  isETHAddressHex(variableName, value) {\n    exports.assert.assert(_.isString(value), exports.assert.typeAssertionMessage(variableName, 'string', value));\n    exports.assert.assert(utils_1.addressUtils.isAddress(value), exports.assert.typeAssertionMessage(variableName, 'ETHAddressHex', value));\n  },\n\n  doesBelongToStringEnum(variableName, value, stringEnum\n  /* There is no base type for every string enum */\n  ) {\n    const enumValues = _.values(stringEnum);\n\n    const doesBelongToStringEnum = _.includes(enumValues, value);\n\n    const enumValuesAsStrings = _.map(enumValues, enumValue => `'${enumValue}'`);\n\n    const enumValuesAsString = enumValuesAsStrings.join(', ');\n    exports.assert.assert(doesBelongToStringEnum, `Expected ${variableName} to be one of: ${enumValuesAsString}, encountered: ${value}`);\n  },\n\n  hasAtMostOneUniqueValue(value, errMsg) {\n    exports.assert.assert(_.uniq(value).length <= 1, errMsg);\n  },\n\n  isNumber(variableName, value) {\n    exports.assert.assert(_.isFinite(value), exports.assert.typeAssertionMessage(variableName, 'number', value));\n  },\n\n  isNumberOrBigNumber(variableName, value) {\n    if (_.isFinite(value)) {\n      return;\n    } else {\n      exports.assert.assert(utils_1.BigNumber.isBigNumber(value), exports.assert.typeAssertionMessage(variableName, 'number or BigNumber', value));\n    }\n  },\n\n  isBoolean(variableName, value) {\n    exports.assert.assert(_.isBoolean(value), exports.assert.typeAssertionMessage(variableName, 'boolean', value));\n  },\n\n  isWeb3Provider(variableName, value) {\n    utils_1.logUtils.warn('DEPRECATED: Please use providerUtils.standardizeOrThrow() instead');\n\n    const isWeb3Provider = _.isFunction(value.send) || _.isFunction(value.sendAsync);\n\n    exports.assert.assert(isWeb3Provider, exports.assert.typeAssertionMessage(variableName, 'Provider', value));\n  },\n\n  doesConformToSchema(variableName, value, schema, subSchemas) {\n    if (value === undefined) {\n      throw new Error(`${variableName} can't be undefined`);\n    }\n\n    const schemaValidator = new json_schemas_1.SchemaValidator();\n\n    if (subSchemas !== undefined) {\n      _.map(subSchemas, schemaValidator.addSchema.bind(schemaValidator));\n    }\n\n    const validationResult = schemaValidator.validate(value, schema);\n    const hasValidationErrors = validationResult.errors.length > 0;\n    const msg = `Expected ${variableName} to conform to schema ${schema.id}\nEncountered: ${JSON.stringify(value, null, '\\t')}\nValidation errors: ${validationResult.errors.join(', ')}`;\n    exports.assert.assert(!hasValidationErrors, msg);\n  },\n\n  doesMatchRegex(variableName, value, regex) {\n    exports.assert.assert(regex.test(value), exports.assert.typeAssertionMessage(variableName, String(regex), value));\n  },\n\n  isWebUri(variableName, value) {\n    const isValidUrl = validUrl.isWebUri(value) !== undefined;\n    exports.assert.assert(isValidUrl, exports.assert.typeAssertionMessage(variableName, 'web uri', value));\n  },\n\n  isUri(variableName, value) {\n    const isValidUri = validUrl.isUri(value) !== undefined;\n    exports.assert.assert(isValidUri, exports.assert.typeAssertionMessage(variableName, 'uri', value));\n  },\n\n  isBlockParam(variableName, value) {\n    if (Number.isInteger(value) && value >= 0) {\n      return;\n    }\n\n    if (value === 'earliest' || value === 'latest' || value === 'pending') {\n      return;\n    }\n\n    throw new Error(exports.assert.typeAssertionMessage(variableName, 'BlockParam', value));\n  },\n\n  isArray(variableName, value) {\n    if (!Array.isArray(value)) {\n      throw new Error(exports.assert.typeAssertionMessage(variableName, 'Array', value));\n    }\n  },\n\n  assert(condition, message) {\n    if (!condition) {\n      throw new Error(message);\n    }\n  },\n\n  typeAssertionMessage(variableName, type, value) {\n    return `Expected ${variableName} to be of type ${type}, encountered: ${value}`;\n  }\n\n};","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst json_schemas_1 = require(\"@0x/json-schemas\");\nconst utils_1 = require(\"@0x/utils\");\nconst _ = require(\"lodash\");\nconst validUrl = require(\"valid-url\");\nconst HEX_REGEX = /^0x[0-9A-F]*$/i;\nexports.assert = {\n    isBigNumber(variableName, value) {\n        const isBigNumber = utils_1.BigNumber.isBigNumber(value);\n        exports.assert.assert(isBigNumber, exports.assert.typeAssertionMessage(variableName, 'BigNumber', value));\n    },\n    isNumberLike(variableName, value) {\n        const isBigNumber = utils_1.BigNumber.isBigNumber(value);\n        const isNumber = typeof value === 'number';\n        exports.assert.assert(isBigNumber || isNumber, exports.assert.typeAssertionMessage(variableName, 'BigNumber | number', value));\n    },\n    isValidBaseUnitAmount(variableName, value) {\n        exports.assert.isBigNumber(variableName, value);\n        const isNegative = value.isLessThan(0);\n        exports.assert.assert(!isNegative, `${variableName} cannot be a negative number, found value: ${value.toNumber()}`);\n        const hasDecimals = value.decimalPlaces() !== 0;\n        exports.assert.assert(!hasDecimals, `${variableName} should be in baseUnits (no decimals), found value: ${value.toNumber()}`);\n    },\n    isString(variableName, value) {\n        exports.assert.assert(_.isString(value), exports.assert.typeAssertionMessage(variableName, 'string', value));\n    },\n    isFunction(variableName, value) {\n        exports.assert.assert(_.isFunction(value), exports.assert.typeAssertionMessage(variableName, 'function', value));\n    },\n    isHexString(variableName, value) {\n        exports.assert.assert(_.isString(value) && HEX_REGEX.test(value), exports.assert.typeAssertionMessage(variableName, 'HexString', value));\n    },\n    isETHAddressHex(variableName, value) {\n        exports.assert.assert(_.isString(value), exports.assert.typeAssertionMessage(variableName, 'string', value));\n        exports.assert.assert(utils_1.addressUtils.isAddress(value), exports.assert.typeAssertionMessage(variableName, 'ETHAddressHex', value));\n    },\n    doesBelongToStringEnum(variableName, value, stringEnum /* There is no base type for every string enum */) {\n        const enumValues = _.values(stringEnum);\n        const doesBelongToStringEnum = _.includes(enumValues, value);\n        const enumValuesAsStrings = _.map(enumValues, enumValue => `'${enumValue}'`);\n        const enumValuesAsString = enumValuesAsStrings.join(', ');\n        exports.assert.assert(doesBelongToStringEnum, `Expected ${variableName} to be one of: ${enumValuesAsString}, encountered: ${value}`);\n    },\n    hasAtMostOneUniqueValue(value, errMsg) {\n        exports.assert.assert(_.uniq(value).length <= 1, errMsg);\n    },\n    isNumber(variableName, value) {\n        exports.assert.assert(_.isFinite(value), exports.assert.typeAssertionMessage(variableName, 'number', value));\n    },\n    isNumberOrBigNumber(variableName, value) {\n        if (_.isFinite(value)) {\n            return;\n        }\n        else {\n            exports.assert.assert(utils_1.BigNumber.isBigNumber(value), exports.assert.typeAssertionMessage(variableName, 'number or BigNumber', value));\n        }\n    },\n    isBoolean(variableName, value) {\n        exports.assert.assert(_.isBoolean(value), exports.assert.typeAssertionMessage(variableName, 'boolean', value));\n    },\n    isWeb3Provider(variableName, value) {\n        utils_1.logUtils.warn('DEPRECATED: Please use providerUtils.standardizeOrThrow() instead');\n        const isWeb3Provider = _.isFunction(value.send) || _.isFunction(value.sendAsync);\n        exports.assert.assert(isWeb3Provider, exports.assert.typeAssertionMessage(variableName, 'Provider', value));\n    },\n    doesConformToSchema(variableName, value, schema, subSchemas) {\n        if (value === undefined) {\n            throw new Error(`${variableName} can't be undefined`);\n        }\n        const schemaValidator = new json_schemas_1.SchemaValidator();\n        if (subSchemas !== undefined) {\n            _.map(subSchemas, schemaValidator.addSchema.bind(schemaValidator));\n        }\n        const validationResult = schemaValidator.validate(value, schema);\n        const hasValidationErrors = validationResult.errors.length > 0;\n        const msg = `Expected ${variableName} to conform to schema ${schema.id}\nEncountered: ${JSON.stringify(value, null, '\\t')}\nValidation errors: ${validationResult.errors.join(', ')}`;\n        exports.assert.assert(!hasValidationErrors, msg);\n    },\n    doesMatchRegex(variableName, value, regex) {\n        exports.assert.assert(regex.test(value), exports.assert.typeAssertionMessage(variableName, String(regex), value));\n    },\n    isWebUri(variableName, value) {\n        const isValidUrl = validUrl.isWebUri(value) !== undefined;\n        exports.assert.assert(isValidUrl, exports.assert.typeAssertionMessage(variableName, 'web uri', value));\n    },\n    isUri(variableName, value) {\n        const isValidUri = validUrl.isUri(value) !== undefined;\n        exports.assert.assert(isValidUri, exports.assert.typeAssertionMessage(variableName, 'uri', value));\n    },\n    isBlockParam(variableName, value) {\n        if (Number.isInteger(value) && value >= 0) {\n            return;\n        }\n        if (value === 'earliest' || value === 'latest' || value === 'pending') {\n            return;\n        }\n        throw new Error(exports.assert.typeAssertionMessage(variableName, 'BlockParam', value));\n    },\n    isArray(variableName, value) {\n        if (!Array.isArray(value)) {\n            throw new Error(exports.assert.typeAssertionMessage(variableName, 'Array', value));\n        }\n    },\n    assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    },\n    typeAssertionMessage(variableName, type, value) {\n        return `Expected ${variableName} to be of type ${type}, encountered: ${value}`;\n    },\n};\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}