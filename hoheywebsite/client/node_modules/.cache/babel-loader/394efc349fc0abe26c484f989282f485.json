{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst assert_1 = require(\"@0x/assert\");\n\nconst utils_1 = require(\"@0x/utils\");\n\nconst types_1 = require(\"../types\");\n\nconst subprovider_1 = require(\"./subprovider\");\n\nclass BaseWalletSubprovider extends subprovider_1.Subprovider {\n  static _validateTxParams(txParams) {\n    if (txParams.to !== undefined) {\n      assert_1.assert.isETHAddressHex('to', txParams.to);\n    }\n\n    assert_1.assert.isHexString('nonce', txParams.nonce);\n  }\n\n  static _validateSender(sender) {\n    if (sender === undefined || !utils_1.addressUtils.isAddress(sender)) {\n      throw new Error(types_1.WalletSubproviderErrors.SenderInvalidOrNotSupplied);\n    }\n  }\n  /**\n   * This method conforms to the web3-provider-engine interface.\n   * It is called internally by the ProviderEngine when it is this subproviders\n   * turn to handle a JSON RPC request.\n   * @param payload JSON RPC payload\n   * @param next Callback to call if this subprovider decides not to handle the request\n   * @param end Callback to call if subprovider handled the request and wants to pass back the request.\n   */\n  // tslint:disable-next-line:async-suffix\n\n\n  handleRequest(payload, next, end) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let accounts;\n      let txParams;\n      let address;\n      let typedData;\n\n      switch (payload.method) {\n        case 'eth_coinbase':\n          try {\n            accounts = yield this.getAccountsAsync();\n            end(null, accounts[0]);\n          } catch (err) {\n            end(err);\n          }\n\n          return;\n\n        case 'eth_accounts':\n          try {\n            accounts = yield this.getAccountsAsync();\n            end(null, accounts);\n          } catch (err) {\n            end(err);\n          }\n\n          return;\n\n        case 'eth_sendTransaction':\n          txParams = payload.params[0];\n\n          try {\n            BaseWalletSubprovider._validateSender(txParams.from);\n\n            const filledParams = yield this._populateMissingTxParamsAsync(txParams);\n            const signedTx = yield this.signTransactionAsync(filledParams);\n            const response = yield this._emitSendTransactionAsync(signedTx);\n            end(null, response.result);\n          } catch (err) {\n            end(err);\n          }\n\n          return;\n\n        case 'eth_signTransaction':\n          txParams = payload.params[0];\n\n          try {\n            const filledParams = yield this._populateMissingTxParamsAsync(txParams);\n            const signedTx = yield this.signTransactionAsync(filledParams);\n            const result = {\n              raw: signedTx,\n              tx: txParams\n            };\n            end(null, result);\n          } catch (err) {\n            end(err);\n          }\n\n          return;\n\n        case 'eth_sign':\n        case 'personal_sign':\n          const data = payload.method === 'eth_sign' ? payload.params[1] : payload.params[0];\n          address = payload.method === 'eth_sign' ? payload.params[0] : payload.params[1];\n\n          try {\n            const ecSignatureHex = yield this.signPersonalMessageAsync(data, address);\n            end(null, ecSignatureHex);\n          } catch (err) {\n            end(err);\n          }\n\n          return;\n\n        case 'eth_signTypedData':\n          [address, typedData] = payload.params;\n\n          try {\n            const signature = yield this.signTypedDataAsync(address, typedData);\n            end(null, signature);\n          } catch (err) {\n            end(err);\n          }\n\n          return;\n\n        default:\n          next();\n          return;\n      }\n    });\n  }\n\n  _emitSendTransactionAsync(signedTx) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const payload = {\n        method: 'eth_sendRawTransaction',\n        params: [signedTx]\n      };\n      const result = yield this.emitPayloadAsync(payload);\n      return result;\n    });\n  }\n\n  _populateMissingTxParamsAsync(partialTxParams) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let txParams = partialTxParams;\n\n      if (partialTxParams.gasPrice === undefined) {\n        const gasPriceResult = yield this.emitPayloadAsync({\n          method: 'eth_gasPrice',\n          params: []\n        });\n        const gasPrice = gasPriceResult.result.toString();\n        txParams = Object.assign({}, txParams, {\n          gasPrice\n        });\n      }\n\n      if (partialTxParams.nonce === undefined) {\n        const nonceResult = yield this.emitPayloadAsync({\n          method: 'eth_getTransactionCount',\n          params: [partialTxParams.from, 'pending']\n        });\n        const nonce = nonceResult.result;\n        txParams = Object.assign({}, txParams, {\n          nonce\n        });\n      }\n\n      if (partialTxParams.gas === undefined) {\n        const gasResult = yield this.emitPayloadAsync({\n          method: 'eth_estimateGas',\n          params: [partialTxParams]\n        });\n        const gas = gasResult.result.toString();\n        txParams = Object.assign({}, txParams, {\n          gas\n        });\n      }\n\n      return txParams;\n    });\n  }\n\n}\n\nexports.BaseWalletSubprovider = BaseWalletSubprovider;","map":{"version":3,"sources":["../../../src/subproviders/base_wallet_subprovider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert_1 = require(\"@0x/assert\");\nconst utils_1 = require(\"@0x/utils\");\nconst types_1 = require(\"../types\");\nconst subprovider_1 = require(\"./subprovider\");\nclass BaseWalletSubprovider extends subprovider_1.Subprovider {\n    static _validateTxParams(txParams) {\n        if (txParams.to !== undefined) {\n            assert_1.assert.isETHAddressHex('to', txParams.to);\n        }\n        assert_1.assert.isHexString('nonce', txParams.nonce);\n    }\n    static _validateSender(sender) {\n        if (sender === undefined || !utils_1.addressUtils.isAddress(sender)) {\n            throw new Error(types_1.WalletSubproviderErrors.SenderInvalidOrNotSupplied);\n        }\n    }\n    /**\n     * This method conforms to the web3-provider-engine interface.\n     * It is called internally by the ProviderEngine when it is this subproviders\n     * turn to handle a JSON RPC request.\n     * @param payload JSON RPC payload\n     * @param next Callback to call if this subprovider decides not to handle the request\n     * @param end Callback to call if subprovider handled the request and wants to pass back the request.\n     */\n    // tslint:disable-next-line:async-suffix\n    handleRequest(payload, next, end) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let accounts;\n            let txParams;\n            let address;\n            let typedData;\n            switch (payload.method) {\n                case 'eth_coinbase':\n                    try {\n                        accounts = yield this.getAccountsAsync();\n                        end(null, accounts[0]);\n                    }\n                    catch (err) {\n                        end(err);\n                    }\n                    return;\n                case 'eth_accounts':\n                    try {\n                        accounts = yield this.getAccountsAsync();\n                        end(null, accounts);\n                    }\n                    catch (err) {\n                        end(err);\n                    }\n                    return;\n                case 'eth_sendTransaction':\n                    txParams = payload.params[0];\n                    try {\n                        BaseWalletSubprovider._validateSender(txParams.from);\n                        const filledParams = yield this._populateMissingTxParamsAsync(txParams);\n                        const signedTx = yield this.signTransactionAsync(filledParams);\n                        const response = yield this._emitSendTransactionAsync(signedTx);\n                        end(null, response.result);\n                    }\n                    catch (err) {\n                        end(err);\n                    }\n                    return;\n                case 'eth_signTransaction':\n                    txParams = payload.params[0];\n                    try {\n                        const filledParams = yield this._populateMissingTxParamsAsync(txParams);\n                        const signedTx = yield this.signTransactionAsync(filledParams);\n                        const result = {\n                            raw: signedTx,\n                            tx: txParams,\n                        };\n                        end(null, result);\n                    }\n                    catch (err) {\n                        end(err);\n                    }\n                    return;\n                case 'eth_sign':\n                case 'personal_sign':\n                    const data = payload.method === 'eth_sign' ? payload.params[1] : payload.params[0];\n                    address = payload.method === 'eth_sign' ? payload.params[0] : payload.params[1];\n                    try {\n                        const ecSignatureHex = yield this.signPersonalMessageAsync(data, address);\n                        end(null, ecSignatureHex);\n                    }\n                    catch (err) {\n                        end(err);\n                    }\n                    return;\n                case 'eth_signTypedData':\n                    [address, typedData] = payload.params;\n                    try {\n                        const signature = yield this.signTypedDataAsync(address, typedData);\n                        end(null, signature);\n                    }\n                    catch (err) {\n                        end(err);\n                    }\n                    return;\n                default:\n                    next();\n                    return;\n            }\n        });\n    }\n    _emitSendTransactionAsync(signedTx) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const payload = {\n                method: 'eth_sendRawTransaction',\n                params: [signedTx],\n            };\n            const result = yield this.emitPayloadAsync(payload);\n            return result;\n        });\n    }\n    _populateMissingTxParamsAsync(partialTxParams) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let txParams = partialTxParams;\n            if (partialTxParams.gasPrice === undefined) {\n                const gasPriceResult = yield this.emitPayloadAsync({\n                    method: 'eth_gasPrice',\n                    params: [],\n                });\n                const gasPrice = gasPriceResult.result.toString();\n                txParams = Object.assign({}, txParams, { gasPrice });\n            }\n            if (partialTxParams.nonce === undefined) {\n                const nonceResult = yield this.emitPayloadAsync({\n                    method: 'eth_getTransactionCount',\n                    params: [partialTxParams.from, 'pending'],\n                });\n                const nonce = nonceResult.result;\n                txParams = Object.assign({}, txParams, { nonce });\n            }\n            if (partialTxParams.gas === undefined) {\n                const gasResult = yield this.emitPayloadAsync({\n                    method: 'eth_estimateGas',\n                    params: [partialTxParams],\n                });\n                const gas = gasResult.result.toString();\n                txParams = Object.assign({}, txParams, { gas });\n            }\n            return txParams;\n        });\n    }\n}\nexports.BaseWalletSubprovider = BaseWalletSubprovider;\n//# sourceMappingURL=base_wallet_subprovider.js.map"]},"metadata":{},"sourceType":"module"}