{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst _ = require(\"lodash\");\n\nexports.providerUtils = {\n  /**\n   * Starts the Web3ProviderEngine without excess block polling\n   * @param providerEngine The Web3ProviderEngine\n   */\n  startProviderEngine(providerEngine) {\n    if (providerEngine.start === undefined) {\n      throw new Error(`Invalid Web3ProviderEngine`);\n    } // HACK: When calling start() Web3ProviderEngine starts a block polling service\n    // this continuously pulls data from the network and can result in high data usage\n    // for long running services. If used in a front end application this can cause\n    // a high amount of load on a node (one request per user per block).\n\n\n    providerEngine._ready.go();\n\n    providerEngine._running = true;\n  },\n\n  /**\n   * Standardize the supported provider types into our internal provider interface\n   * or throw if unsupported provider supplied.\n   * @param supportedProvider Potentially supported provider instance\n   * @return Provider that conforms of our internal provider interface\n   */\n  standardizeOrThrow(supportedProvider) {\n    if (supportedProvider === undefined) {\n      throw new Error(`supportedProvider cannot be 'undefined'`);\n    }\n\n    const provider = {\n      isStandardizedProvider: true,\n      isMetaMask: supportedProvider.isMetaMask,\n      isParity: supportedProvider.isParity,\n      stop: supportedProvider.stop,\n      enable: supportedProvider.enable,\n      sendAsync: _.noop.bind(_)\n    };\n\n    if (provider.enable) {\n      // Need to bind, metamask can lose reference to function without binding as of 7.7.0\n      provider.enable.bind(supportedProvider);\n    } // Case 1: We've already converted to our ZeroExProvider so noop.\n\n\n    if (supportedProvider.isStandardizedProvider) {\n      // tslint:disable-next-line:no-unnecessary-type-assertion\n      return supportedProvider; // Case 2: It's a compliant EIP 1193 Provider\n      // tslint:disable-next-line:no-unnecessary-type-assertion\n    } else if (supportedProvider.isEIP1193) {\n      provider.sendAsync = (payload, callback) => {\n        const method = payload.method;\n        const params = payload.params;\n        supportedProvider.send(method, params).then(result => {\n          callback(null, result);\n        }).catch(err => {\n          callback(err);\n        });\n      };\n\n      return provider; // Case 3: The provider has a `sendAsync` method, so we use it.\n    } else if (supportedProvider.sendAsync !== undefined) {\n      provider.sendAsync = supportedProvider.sendAsync.bind(supportedProvider);\n      return provider; // Case 4: The provider does not have a `sendAsync` method but does have a `send` method\n    } else if (supportedProvider.send !== undefined) {\n      // HACK(fabio): Detect if the `send` method has the old interface `send(payload, cb)` such\n      // as in versions < Web3.js@1.0.0-beta.37. If so, do a simple re-mapping\n      if (_.includes(supportedProvider.send.toString().replace(' ', ''), 'function(payload,callback)')) {\n        provider.sendAsync = supportedProvider.send.bind(supportedProvider);\n        return provider;\n      } else {\n        // If doesn't have old interface, we assume it has new interface `send(method, payload)`\n        // such as in versions > Web3.js@1.0.0-beta.38 and convert it to `sendAsync`\n        provider.sendAsync = (payload, callback) => {\n          const method = payload.method;\n          const params = payload.params;\n          supportedProvider.send(method, params).then(result => {\n            callback(null, result);\n          }).catch(err => {\n            callback(err);\n          });\n        };\n\n        return provider;\n      }\n    }\n\n    throw new Error(`Unsupported provider found. Please make sure it conforms to one of the supported providers. See 'Provider' type in 'ethereum-types' package.`);\n  },\n\n  /**\n   * Retrieve the chain ID from a supported provider.\n   * @param supportedProvider A supported provider instance.\n   * @return A promise that resolves to the chain ID of the network the provider\n   * is connected to.\n   */\n  getChainIdAsync(supportedProvider) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const provider = exports.providerUtils.standardizeOrThrow(supportedProvider); // tslint:disable-next-line:custom-no-magic-numbers\n\n      const RPC_ID_MAX = Math.pow(2, 64);\n      return new Promise((accept, reject) => {\n        provider.sendAsync({\n          jsonrpc: '2.0',\n          id: _.random(1, RPC_ID_MAX),\n          method: 'eth_chainId',\n          params: []\n        }, (err, result) => {\n          if (!_.isNil(err)) {\n            reject(err);\n          }\n\n          if (!result) {\n            throw new Error(\"Invalid 'eth_chainId' response\");\n          }\n\n          accept(_.toNumber(result.result));\n        });\n      });\n    });\n  }\n\n};","map":{"version":3,"sources":["../../src/provider_utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst _ = require(\"lodash\");\nexports.providerUtils = {\n    /**\n     * Starts the Web3ProviderEngine without excess block polling\n     * @param providerEngine The Web3ProviderEngine\n     */\n    startProviderEngine(providerEngine) {\n        if (providerEngine.start === undefined) {\n            throw new Error(`Invalid Web3ProviderEngine`);\n        }\n        // HACK: When calling start() Web3ProviderEngine starts a block polling service\n        // this continuously pulls data from the network and can result in high data usage\n        // for long running services. If used in a front end application this can cause\n        // a high amount of load on a node (one request per user per block).\n        providerEngine._ready.go();\n        providerEngine._running = true;\n    },\n    /**\n     * Standardize the supported provider types into our internal provider interface\n     * or throw if unsupported provider supplied.\n     * @param supportedProvider Potentially supported provider instance\n     * @return Provider that conforms of our internal provider interface\n     */\n    standardizeOrThrow(supportedProvider) {\n        if (supportedProvider === undefined) {\n            throw new Error(`supportedProvider cannot be 'undefined'`);\n        }\n        const provider = {\n            isStandardizedProvider: true,\n            isMetaMask: supportedProvider.isMetaMask,\n            isParity: supportedProvider.isParity,\n            stop: supportedProvider.stop,\n            enable: supportedProvider.enable,\n            sendAsync: _.noop.bind(_),\n        };\n        if (provider.enable) {\n            // Need to bind, metamask can lose reference to function without binding as of 7.7.0\n            provider.enable.bind(supportedProvider);\n        }\n        // Case 1: We've already converted to our ZeroExProvider so noop.\n        if (supportedProvider.isStandardizedProvider) {\n            // tslint:disable-next-line:no-unnecessary-type-assertion\n            return supportedProvider;\n            // Case 2: It's a compliant EIP 1193 Provider\n            // tslint:disable-next-line:no-unnecessary-type-assertion\n        }\n        else if (supportedProvider.isEIP1193) {\n            provider.sendAsync = (payload, callback) => {\n                const method = payload.method;\n                const params = payload.params;\n                supportedProvider\n                    .send(method, params)\n                    .then((result) => {\n                    callback(null, result);\n                })\n                    .catch((err) => {\n                    callback(err);\n                });\n            };\n            return provider;\n            // Case 3: The provider has a `sendAsync` method, so we use it.\n        }\n        else if (supportedProvider.sendAsync !== undefined) {\n            provider.sendAsync = supportedProvider.sendAsync.bind(supportedProvider);\n            return provider;\n            // Case 4: The provider does not have a `sendAsync` method but does have a `send` method\n        }\n        else if (supportedProvider.send !== undefined) {\n            // HACK(fabio): Detect if the `send` method has the old interface `send(payload, cb)` such\n            // as in versions < Web3.js@1.0.0-beta.37. If so, do a simple re-mapping\n            if (_.includes(supportedProvider.send.toString().replace(' ', ''), 'function(payload,callback)')) {\n                provider.sendAsync = supportedProvider.send.bind(supportedProvider);\n                return provider;\n            }\n            else {\n                // If doesn't have old interface, we assume it has new interface `send(method, payload)`\n                // such as in versions > Web3.js@1.0.0-beta.38 and convert it to `sendAsync`\n                provider.sendAsync = (payload, callback) => {\n                    const method = payload.method;\n                    const params = payload.params;\n                    supportedProvider\n                        .send(method, params)\n                        .then((result) => {\n                        callback(null, result);\n                    })\n                        .catch((err) => {\n                        callback(err);\n                    });\n                };\n                return provider;\n            }\n        }\n        throw new Error(`Unsupported provider found. Please make sure it conforms to one of the supported providers. See 'Provider' type in 'ethereum-types' package.`);\n    },\n    /**\n     * Retrieve the chain ID from a supported provider.\n     * @param supportedProvider A supported provider instance.\n     * @return A promise that resolves to the chain ID of the network the provider\n     * is connected to.\n     */\n    getChainIdAsync(supportedProvider) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const provider = exports.providerUtils.standardizeOrThrow(supportedProvider);\n            // tslint:disable-next-line:custom-no-magic-numbers\n            const RPC_ID_MAX = Math.pow(2, 64);\n            return new Promise((accept, reject) => {\n                provider.sendAsync({\n                    jsonrpc: '2.0',\n                    id: _.random(1, RPC_ID_MAX),\n                    method: 'eth_chainId',\n                    params: [],\n                }, (err, result) => {\n                    if (!_.isNil(err)) {\n                        reject(err);\n                    }\n                    if (!result) {\n                        throw new Error(\"Invalid 'eth_chainId' response\");\n                    }\n                    accept(_.toNumber(result.result));\n                });\n            });\n        });\n    },\n};\n//# sourceMappingURL=provider_utils.js.map"]},"metadata":{},"sourceType":"module"}