{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst isNode = require(\"detect-node\");\n\nrequire(\"isomorphic-fetch\"); // WARNING: This needs to be imported after isomorphic-fetch: https://github.com/mo/abortcontroller-polyfill#using-it-on-browsers-without-fetch\n// tslint:disable-next-line:ordered-imports\n\n\nrequire(\"abortcontroller-polyfill/dist/abortcontroller-polyfill-only\");\n\nexports.fetchAsync = (endpoint, options = {}, timeoutMs = 20000) => __awaiter(this, void 0, void 0, function* () {\n  if (options.signal || options.timeout) {\n    throw new Error('Cannot call fetchAsync with options.signal or options.timeout. To set a timeout, please use the supplied \"timeoutMs\" parameter.');\n  }\n\n  let optionsWithAbortParam;\n\n  if (!isNode) {\n    const controller = new AbortController();\n    const signal = controller.signal;\n    setTimeout(() => {\n      controller.abort();\n    }, timeoutMs);\n    optionsWithAbortParam = Object.assign({\n      signal\n    }, options);\n  } else {\n    // HACK: the `timeout` param only exists in `node-fetch`, and not on the `isomorphic-fetch`\n    // `RequestInit` type. Since `isomorphic-fetch` conditionally wraps `node-fetch` when the\n    // execution environment is `Node.js`, we need to cast it to `any` in that scenario.\n    optionsWithAbortParam = Object.assign({\n      timeout: timeoutMs\n    }, options);\n  }\n\n  const response = yield fetch(endpoint, optionsWithAbortParam);\n  return response;\n});","map":{"version":3,"sources":["../../src/fetch_async.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAA,MAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,OAAA,CAAA,kBAAA,CAAA,C,CACA;AACA;;;AACA,OAAA,CAAA,6DAAA,CAAA;;AAEa,OAAA,CAAA,UAAA,GAAa,CACtB,QADsB,EAEtB,OAAA,GAAuB,EAFD,EAGtB,SAAA,GAAoB,KAHE,KAIH,SAAA,CAAA,IAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,aAAA;AACnB,MAAI,OAAO,CAAC,MAAR,IAAmB,OAAe,CAAC,OAAvC,EAAgD;AAC5C,UAAM,IAAI,KAAJ,CACF,iIADE,CAAN;AAGH;;AACD,MAAI,qBAAJ;;AACA,MAAI,CAAC,MAAL,EAAa;AACT,UAAM,UAAU,GAAG,IAAI,eAAJ,EAAnB;AACA,UAAM,MAAM,GAAG,UAAU,CAAC,MAA1B;AACA,IAAA,UAAU,CAAC,MAAK;AACZ,MAAA,UAAU,CAAC,KAAX;AACH,KAFS,EAEP,SAFO,CAAV;AAGA,IAAA,qBAAqB,GAAA,MAAA,CAAA,MAAA,CAAA;AACjB,MAAA;AADiB,KAAA,EAEd,OAFc,CAArB;AAIH,GAVD,MAUO;AACH;AACA;AACA;AACA,IAAA,qBAAqB,GAAG,MAAA,CAAA,MAAA,CAAA;AACpB,MAAA,OAAO,EAAE;AADW,KAAA,EAEjB,OAFiB,CAAxB;AAIH;;AAED,QAAM,QAAQ,GAAG,MAAM,KAAK,CAAC,QAAD,EAAW,qBAAX,CAA5B;AACA,SAAO,QAAP;AACH,CA7BsB,CAJV","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst isNode = require(\"detect-node\");\nrequire(\"isomorphic-fetch\");\n// WARNING: This needs to be imported after isomorphic-fetch: https://github.com/mo/abortcontroller-polyfill#using-it-on-browsers-without-fetch\n// tslint:disable-next-line:ordered-imports\nrequire(\"abortcontroller-polyfill/dist/abortcontroller-polyfill-only\");\nexports.fetchAsync = (endpoint, options = {}, timeoutMs = 20000) => __awaiter(this, void 0, void 0, function* () {\n    if (options.signal || options.timeout) {\n        throw new Error('Cannot call fetchAsync with options.signal or options.timeout. To set a timeout, please use the supplied \"timeoutMs\" parameter.');\n    }\n    let optionsWithAbortParam;\n    if (!isNode) {\n        const controller = new AbortController();\n        const signal = controller.signal;\n        setTimeout(() => {\n            controller.abort();\n        }, timeoutMs);\n        optionsWithAbortParam = Object.assign({ signal }, options);\n    }\n    else {\n        // HACK: the `timeout` param only exists in `node-fetch`, and not on the `isomorphic-fetch`\n        // `RequestInit` type. Since `isomorphic-fetch` conditionally wraps `node-fetch` when the\n        // execution environment is `Node.js`, we need to cast it to `any` in that scenario.\n        optionsWithAbortParam = Object.assign({ timeout: timeoutMs }, options);\n    }\n    const response = yield fetch(endpoint, optionsWithAbortParam);\n    return response;\n});\n//# sourceMappingURL=fetch_async.js.map"]},"metadata":{},"sourceType":"module"}