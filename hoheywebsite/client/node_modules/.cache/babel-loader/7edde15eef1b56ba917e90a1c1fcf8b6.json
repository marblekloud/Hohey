{"ast":null,"code":"const Buffer = require('buffer/').Buffer;\n\nconst keccak256 = require('js-sha3').keccak256;\n\nconst {\n  ETH_ABI_LATTICE_FW_TYPE_MAP\n} = require('./constants');\n\nconst NAME_MAX_SZ = 100;\nconst HEADER_SZ = 5 + NAME_MAX_SZ; // 4 byte sig + name + 1 byte param count\n\nconst PARAM_SZ = 26; // 20 byte name + 6 byte def\n\nconst MAX_PARAMS = 18;\nconst MAX_ABI_DEFS = 2;\nexports.MAX_ABI_DEFS = MAX_ABI_DEFS; // Build a request to add ABI data\n\nexports.buildAddAbiPayload = function (defs) {\n  if (!defs || !Array.isArray(defs)) throw new Error('Missing definitions.');\n  if (defs.length > exports.MAX_ABI_DEFS) throw new Error(`You may only add ${MAX_ABI_DEFS} ABI definitions per request.`);\n  const b = Buffer.alloc(1 + MAX_ABI_DEFS * (HEADER_SZ + PARAM_SZ * MAX_PARAMS));\n  let off = 0;\n  b.writeUInt8(defs.length, off);\n  off++;\n  defs.forEach(def => {\n    if (!def.sig || !def.name || !def.params) throw new Error('name, sig, and params must be present for every ABI definition.'); // Header data\n\n    const sig = Buffer.from(def.sig, 'hex');\n    if (sig.length !== 4) throw new Error('Function signatures must always be four bytes.');\n    sig.copy(b, off);\n    off += sig.length;\n    const name = Buffer.from(def.name);\n    if (name.length > NAME_MAX_SZ - 1) // The -1 accounts for the null terminator\n      throw new Error(`Only function names shorter than ${NAME_MAX_SZ} characters are supported.`);\n    Buffer.from(def.name).slice(0, NAME_MAX_SZ).copy(b, off);\n    off += NAME_MAX_SZ; // Number of parameters\n\n    const numParams = Array.isArray(def.params) ? def.params.length : 0;\n    b.writeUInt8(numParams, off);\n    off++; // Don't overflow the buffer\n\n    if (numParams > MAX_PARAMS) throw new Error('Currently only ABI defintions with <=10 parameters are supported.'); // Copy the params if needed\n\n    if (numParams > 0) {\n      // First copy param names (first 20 bytes)\n      def.params.forEach(param => {\n        if (!param.name || !param.latticeTypeIdx || param.isArray === undefined || param.arraySz === undefined) throw new Error('name, latticeTypeIdx, isArray, and arraySz must be defined for all ABI params.');\n        Buffer.from(param.name).slice(0, 20).copy(b, off);\n        off += 20;\n      }); // Bump offset to account for blank param slots\n\n      off += 20 * (MAX_PARAMS - numParams); // Next copy the definitions\n\n      def.params.forEach(param => {\n        b.writeUInt8(param.latticeTypeIdx, off);\n        off++;\n        b.writeUInt8(param.isArray === true, off);\n        off++;\n        b.writeUInt32LE(param.arraySz, off);\n        off += 4;\n      }); // Bump offset again\n\n      off += 6 * (MAX_PARAMS - numParams);\n    } else {\n      // If there are no params, just bump the offset\n      off += PARAM_SZ * MAX_PARAMS;\n    }\n  });\n  return b;\n}; //--------------------------------------\n// PARSERS\n//--------------------------------------\n\n\nfunction parseEtherscanAbiDefs(_defs) {\n  // `_defs` are `result` of the parsed response\n  const defs = [];\n\n  _defs.forEach(d => {\n    if (d.name && d.inputs && d.type === 'function' && d.stateMutability !== 'view') {\n      const sig = getFuncSig(d);\n      const params = parseEtherscanAbiInputs(d.inputs);\n      defs.push({\n        name: d.name,\n        sig,\n        params\n      });\n    }\n  });\n\n  return defs;\n}\n\nexports.abiParsers = {\n  etherscan: parseEtherscanAbiDefs\n}; //--------------------------------------\n// HELPERS\n//--------------------------------------\n// Get the 4-byte function identifier based on the canonical name\n\nfunction getFuncSig(f) {\n  // Canonical name is:\n  // funcName(paramType0, ..., paramTypeN)\n  let canonicalName = `${f.name}(`;\n  f.inputs.forEach(input => {\n    canonicalName += `${input.type},`;\n  });\n  if (f.inputs.length > 0) canonicalName = canonicalName.slice(0, canonicalName.length - 1);\n  canonicalName += ')';\n  return keccak256(canonicalName).slice(0, 8);\n} // Parse the ABI param data into structs Lattice firmware will recognize.\n\n\nfunction parseEtherscanAbiInputs(inputs) {\n  const data = [];\n  inputs.forEach(input => {\n    const typeName = input.type;\n    const d = {\n      isArray: false,\n      arraySz: 0,\n      name: input.name\n    };\n    const openBracketIdx = typeName.indexOf('[');\n    const closeBracketIdx = typeName.indexOf(']');\n\n    if (openBracketIdx > -1 && closeBracketIdx > -1) {\n      if (openBracketIdx >= closeBracketIdx) {\n        ; // not a valid param -- skip it\n      } else if (openBracketIdx + 1 === closeBracketIdx) {\n        d.isArray = true;\n      } else {\n        // Parse the array size if applicable\n        const number = parseInt(typeName.slice(openBracketIdx, closeBracketIdx));\n\n        if (isNaN(number)) {\n          return d;\n        }\n\n        d.isArray = true;\n        d.arraySz = number;\n      }\n    }\n\n    const singularTypeName = openBracketIdx > -1 ? typeName.slice(0, openBracketIdx) : typeName;\n    d.latticeTypeIdx = getTypeIdxLatticeFw(singularTypeName);\n    if (!d.latticeTypeIdx) throw new Error(`Unsupported type: ${typeName}`);\n    data.push(d);\n  });\n  return data;\n} // Enum values from inside Lattice firmware\n\n\nfunction getTypeIdxLatticeFw(type) {\n  return ETH_ABI_LATTICE_FW_TYPE_MAP[type];\n}","map":{"version":3,"sources":["/Users/kelvinho/Documents/Coding/HoHey-main 4 2/hoheywebsite/client/src/example/node_modules/gridplus-sdk/src/ethereumAbi.js"],"names":["Buffer","require","keccak256","ETH_ABI_LATTICE_FW_TYPE_MAP","NAME_MAX_SZ","HEADER_SZ","PARAM_SZ","MAX_PARAMS","MAX_ABI_DEFS","exports","buildAddAbiPayload","defs","Array","isArray","Error","length","b","alloc","off","writeUInt8","forEach","def","sig","name","params","from","copy","slice","numParams","param","latticeTypeIdx","undefined","arraySz","writeUInt32LE","parseEtherscanAbiDefs","_defs","d","inputs","type","stateMutability","getFuncSig","parseEtherscanAbiInputs","push","abiParsers","etherscan","f","canonicalName","input","data","typeName","openBracketIdx","indexOf","closeBracketIdx","number","parseInt","isNaN","singularTypeName","getTypeIdxLatticeFw"],"mappings":"AAAA,MAAMA,MAAM,GAAGC,OAAO,CAAC,SAAD,CAAP,CAAmBD,MAAlC;;AACA,MAAME,SAAS,GAAGD,OAAO,CAAC,SAAD,CAAP,CAAmBC,SAArC;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAkCF,OAAO,CAAC,aAAD,CAA/C;;AACA,MAAMG,WAAW,GAAG,GAApB;AACA,MAAMC,SAAS,GAAG,IAAID,WAAtB,C,CAAmC;;AACnC,MAAME,QAAQ,GAAG,EAAjB,C,CAAqB;;AACrB,MAAMC,UAAU,GAAG,EAAnB;AACA,MAAMC,YAAY,GAAG,CAArB;AACAC,OAAO,CAACD,YAAR,GAAuBA,YAAvB,C,CAEA;;AACAC,OAAO,CAACC,kBAAR,GAA6B,UAASC,IAAT,EAAe;AAC1C,MAAI,CAACA,IAAD,IAAS,CAACC,KAAK,CAACC,OAAN,CAAcF,IAAd,CAAd,EACE,MAAM,IAAIG,KAAJ,CAAU,sBAAV,CAAN;AACF,MAAIH,IAAI,CAACI,MAAL,GAAcN,OAAO,CAACD,YAA1B,EACE,MAAM,IAAIM,KAAJ,CAAW,oBAAmBN,YAAa,+BAA3C,CAAN;AACF,QAAMQ,CAAC,GAAGhB,MAAM,CAACiB,KAAP,CAAa,IAAKT,YAAY,IAAIH,SAAS,GAAIC,QAAQ,GAAGC,UAA5B,CAA9B,CAAV;AACA,MAAIW,GAAG,GAAG,CAAV;AACAF,EAAAA,CAAC,CAACG,UAAF,CAAaR,IAAI,CAACI,MAAlB,EAA0BG,GAA1B;AAAgCA,EAAAA,GAAG;AACnCP,EAAAA,IAAI,CAACS,OAAL,CAAcC,GAAD,IAAS;AACpB,QAAI,CAACA,GAAG,CAACC,GAAL,IAAY,CAACD,GAAG,CAACE,IAAjB,IAAyB,CAACF,GAAG,CAACG,MAAlC,EACE,MAAM,IAAIV,KAAJ,CAAU,iEAAV,CAAN,CAFkB,CAGpB;;AACA,UAAMQ,GAAG,GAAGtB,MAAM,CAACyB,IAAP,CAAYJ,GAAG,CAACC,GAAhB,EAAqB,KAArB,CAAZ;AACA,QAAIA,GAAG,CAACP,MAAJ,KAAe,CAAnB,EACE,MAAM,IAAID,KAAJ,CAAU,gDAAV,CAAN;AACFQ,IAAAA,GAAG,CAACI,IAAJ,CAASV,CAAT,EAAYE,GAAZ;AAAkBA,IAAAA,GAAG,IAAII,GAAG,CAACP,MAAX;AAClB,UAAMQ,IAAI,GAAGvB,MAAM,CAACyB,IAAP,CAAYJ,GAAG,CAACE,IAAhB,CAAb;AACA,QAAIA,IAAI,CAACR,MAAL,GAAcX,WAAW,GAAG,CAAhC,EAAmC;AACjC,YAAM,IAAIU,KAAJ,CAAW,oCAAmCV,WAAY,4BAA1D,CAAN;AACFJ,IAAAA,MAAM,CAACyB,IAAP,CAAYJ,GAAG,CAACE,IAAhB,EAAsBI,KAAtB,CAA4B,CAA5B,EAA+BvB,WAA/B,EAA4CsB,IAA5C,CAAiDV,CAAjD,EAAoDE,GAApD;AAA0DA,IAAAA,GAAG,IAAId,WAAP,CAXtC,CAYpB;;AACA,UAAMwB,SAAS,GAAGhB,KAAK,CAACC,OAAN,CAAcQ,GAAG,CAACG,MAAlB,IAA4BH,GAAG,CAACG,MAAJ,CAAWT,MAAvC,GAAgD,CAAlE;AACAC,IAAAA,CAAC,CAACG,UAAF,CAAaS,SAAb,EAAwBV,GAAxB;AAA8BA,IAAAA,GAAG,GAdb,CAepB;;AACA,QAAIU,SAAS,GAAGrB,UAAhB,EACE,MAAM,IAAIO,KAAJ,CAAU,mEAAV,CAAN,CAjBkB,CAkBpB;;AACA,QAAIc,SAAS,GAAG,CAAhB,EAAmB;AACjB;AACAP,MAAAA,GAAG,CAACG,MAAJ,CAAWJ,OAAX,CAAoBS,KAAD,IAAW;AAC5B,YAAI,CAACA,KAAK,CAACN,IAAP,IAAe,CAACM,KAAK,CAACC,cAAtB,IAAwCD,KAAK,CAAChB,OAAN,KAAkBkB,SAA1D,IAAuEF,KAAK,CAACG,OAAN,KAAkBD,SAA7F,EACE,MAAM,IAAIjB,KAAJ,CAAU,gFAAV,CAAN;AACFd,QAAAA,MAAM,CAACyB,IAAP,CAAYI,KAAK,CAACN,IAAlB,EAAwBI,KAAxB,CAA8B,CAA9B,EAAiC,EAAjC,EAAqCD,IAArC,CAA0CV,CAA1C,EAA6CE,GAA7C;AAAmDA,QAAAA,GAAG,IAAI,EAAP;AACpD,OAJD,EAFiB,CAOjB;;AACAA,MAAAA,GAAG,IAAI,MAAMX,UAAU,GAAGqB,SAAnB,CAAP,CARiB,CASjB;;AACAP,MAAAA,GAAG,CAACG,MAAJ,CAAWJ,OAAX,CAAoBS,KAAD,IAAW;AAC5Bb,QAAAA,CAAC,CAACG,UAAF,CAAaU,KAAK,CAACC,cAAnB,EAAmCZ,GAAnC;AAAyCA,QAAAA,GAAG;AAC5CF,QAAAA,CAAC,CAACG,UAAF,CAAaU,KAAK,CAAChB,OAAN,KAAkB,IAA/B,EAAqCK,GAArC;AAA2CA,QAAAA,GAAG;AAC9CF,QAAAA,CAAC,CAACiB,aAAF,CAAgBJ,KAAK,CAACG,OAAtB,EAA+Bd,GAA/B;AAAqCA,QAAAA,GAAG,IAAI,CAAP;AACtC,OAJD,EAViB,CAejB;;AACAA,MAAAA,GAAG,IAAI,KAAKX,UAAU,GAAGqB,SAAlB,CAAP;AACD,KAjBD,MAiBO;AACL;AACAV,MAAAA,GAAG,IAAIZ,QAAQ,GAAGC,UAAlB;AACD;AACF,GAxCD;AAyCA,SAAOS,CAAP;AACD,CAlDD,C,CAoDA;AACA;AACA;;;AACA,SAASkB,qBAAT,CAA+BC,KAA/B,EAAsC;AAAE;AACtC,QAAMxB,IAAI,GAAG,EAAb;;AACAwB,EAAAA,KAAK,CAACf,OAAN,CAAegB,CAAD,IAAO;AACnB,QAAIA,CAAC,CAACb,IAAF,IAAUa,CAAC,CAACC,MAAZ,IAAsBD,CAAC,CAACE,IAAF,KAAW,UAAjC,IAA+CF,CAAC,CAACG,eAAF,KAAsB,MAAzE,EAAiF;AAC/E,YAAMjB,GAAG,GAAGkB,UAAU,CAACJ,CAAD,CAAtB;AACA,YAAMZ,MAAM,GAAGiB,uBAAuB,CAACL,CAAC,CAACC,MAAH,CAAtC;AACA1B,MAAAA,IAAI,CAAC+B,IAAL,CAAU;AACRnB,QAAAA,IAAI,EAAEa,CAAC,CAACb,IADA;AAERD,QAAAA,GAFQ;AAGRE,QAAAA;AAHQ,OAAV;AAKD;AACF,GAVD;;AAWA,SAAOb,IAAP;AACD;;AAEDF,OAAO,CAACkC,UAAR,GAAqB;AACnBC,EAAAA,SAAS,EAAEV;AADQ,CAArB,C,CAIA;AACA;AACA;AACA;;AACA,SAASM,UAAT,CAAoBK,CAApB,EAAuB;AACrB;AACA;AACA,MAAIC,aAAa,GAAI,GAAED,CAAC,CAACtB,IAAK,GAA9B;AACAsB,EAAAA,CAAC,CAACR,MAAF,CAASjB,OAAT,CAAkB2B,KAAD,IAAW;AAC1BD,IAAAA,aAAa,IAAK,GAAEC,KAAK,CAACT,IAAK,GAA/B;AACD,GAFD;AAGA,MAAIO,CAAC,CAACR,MAAF,CAAStB,MAAT,GAAkB,CAAtB,EACE+B,aAAa,GAAGA,aAAa,CAACnB,KAAd,CAAoB,CAApB,EAAuBmB,aAAa,CAAC/B,MAAd,GAAuB,CAA9C,CAAhB;AACF+B,EAAAA,aAAa,IAAI,GAAjB;AACA,SAAO5C,SAAS,CAAC4C,aAAD,CAAT,CAAyBnB,KAAzB,CAA+B,CAA/B,EAAkC,CAAlC,CAAP;AACD,C,CAED;;;AACA,SAASc,uBAAT,CAAiCJ,MAAjC,EAAyC;AACvC,QAAMW,IAAI,GAAG,EAAb;AACAX,EAAAA,MAAM,CAACjB,OAAP,CAAgB2B,KAAD,IAAW;AACxB,UAAME,QAAQ,GAAGF,KAAK,CAACT,IAAvB;AACA,UAAMF,CAAC,GAAG;AAAEvB,MAAAA,OAAO,EAAE,KAAX;AAAkBmB,MAAAA,OAAO,EAAE,CAA3B;AAA8BT,MAAAA,IAAI,EAAEwB,KAAK,CAACxB;AAA1C,KAAV;AACA,UAAM2B,cAAc,GAAGD,QAAQ,CAACE,OAAT,CAAiB,GAAjB,CAAvB;AACA,UAAMC,eAAe,GAAGH,QAAQ,CAACE,OAAT,CAAiB,GAAjB,CAAxB;;AACA,QAAID,cAAc,GAAG,CAAC,CAAlB,IAAuBE,eAAe,GAAG,CAAC,CAA9C,EAAiD;AAC/C,UAAIF,cAAc,IAAIE,eAAtB,EAAuC;AACrC,SADqC,CACnC;AACH,OAFD,MAEO,IAAKF,cAAc,GAAG,CAAlB,KAAyBE,eAA7B,EAA8C;AACnDhB,QAAAA,CAAC,CAACvB,OAAF,GAAY,IAAZ;AACD,OAFM,MAEA;AACL;AACA,cAAMwC,MAAM,GAAGC,QAAQ,CAACL,QAAQ,CAACtB,KAAT,CAAeuB,cAAf,EAA+BE,eAA/B,CAAD,CAAvB;;AACA,YAAIG,KAAK,CAACF,MAAD,CAAT,EAAmB;AACjB,iBAAOjB,CAAP;AACD;;AACDA,QAAAA,CAAC,CAACvB,OAAF,GAAY,IAAZ;AACAuB,QAAAA,CAAC,CAACJ,OAAF,GAAYqB,MAAZ;AACD;AACF;;AACD,UAAMG,gBAAgB,GAAGN,cAAc,GAAG,CAAC,CAAlB,GAAsBD,QAAQ,CAACtB,KAAT,CAAe,CAAf,EAAkBuB,cAAlB,CAAtB,GAA0DD,QAAnF;AACAb,IAAAA,CAAC,CAACN,cAAF,GAAmB2B,mBAAmB,CAACD,gBAAD,CAAtC;AACA,QAAI,CAACpB,CAAC,CAACN,cAAP,EACE,MAAM,IAAIhB,KAAJ,CAAW,qBAAoBmC,QAAS,EAAxC,CAAN;AACFD,IAAAA,IAAI,CAACN,IAAL,CAAUN,CAAV;AACD,GAzBD;AA0BA,SAAOY,IAAP;AACD,C,CAED;;;AACA,SAASS,mBAAT,CAA6BnB,IAA7B,EAAmC;AACjC,SAAOnC,2BAA2B,CAACmC,IAAD,CAAlC;AACD","sourcesContent":["const Buffer = require('buffer/').Buffer\nconst keccak256 = require('js-sha3').keccak256;\nconst { ETH_ABI_LATTICE_FW_TYPE_MAP } = require('./constants');\nconst NAME_MAX_SZ = 100;\nconst HEADER_SZ = 5 + NAME_MAX_SZ; // 4 byte sig + name + 1 byte param count\nconst PARAM_SZ = 26; // 20 byte name + 6 byte def\nconst MAX_PARAMS = 18;\nconst MAX_ABI_DEFS = 2;\nexports.MAX_ABI_DEFS = MAX_ABI_DEFS;\n\n// Build a request to add ABI data\nexports.buildAddAbiPayload = function(defs) {\n  if (!defs || !Array.isArray(defs))\n    throw new Error('Missing definitions.');\n  if (defs.length > exports.MAX_ABI_DEFS)\n    throw new Error(`You may only add ${MAX_ABI_DEFS} ABI definitions per request.`);\n  const b = Buffer.alloc(1 + (MAX_ABI_DEFS * (HEADER_SZ + (PARAM_SZ * MAX_PARAMS))));\n  let off = 0;\n  b.writeUInt8(defs.length, off); off++;\n  defs.forEach((def) => {\n    if (!def.sig || !def.name || !def.params)\n      throw new Error('name, sig, and params must be present for every ABI definition.')\n    // Header data\n    const sig = Buffer.from(def.sig, 'hex');\n    if (sig.length !== 4)\n      throw new Error('Function signatures must always be four bytes.');\n    sig.copy(b, off); off += sig.length;\n    const name = Buffer.from(def.name);\n    if (name.length > NAME_MAX_SZ - 1) // The -1 accounts for the null terminator\n      throw new Error(`Only function names shorter than ${NAME_MAX_SZ} characters are supported.`);\n    Buffer.from(def.name).slice(0, NAME_MAX_SZ).copy(b, off); off += NAME_MAX_SZ;\n    // Number of parameters\n    const numParams = Array.isArray(def.params) ? def.params.length : 0;\n    b.writeUInt8(numParams, off); off++;\n    // Don't overflow the buffer\n    if (numParams > MAX_PARAMS)\n      throw new Error('Currently only ABI defintions with <=10 parameters are supported.');\n    // Copy the params if needed\n    if (numParams > 0) {\n      // First copy param names (first 20 bytes)\n      def.params.forEach((param) => {\n        if (!param.name || !param.latticeTypeIdx || param.isArray === undefined || param.arraySz === undefined)\n          throw new Error('name, latticeTypeIdx, isArray, and arraySz must be defined for all ABI params.');\n        Buffer.from(param.name).slice(0, 20).copy(b, off); off += 20;\n      })\n      // Bump offset to account for blank param slots\n      off += 20 * (MAX_PARAMS - numParams);\n      // Next copy the definitions\n      def.params.forEach((param) => {\n        b.writeUInt8(param.latticeTypeIdx, off); off++;\n        b.writeUInt8(param.isArray === true, off); off++;\n        b.writeUInt32LE(param.arraySz, off); off += 4;\n      })\n      // Bump offset again\n      off += 6 * (MAX_PARAMS - numParams);\n    } else {\n      // If there are no params, just bump the offset\n      off += PARAM_SZ * MAX_PARAMS;\n    }\n  })\n  return b;\n}\n\n//--------------------------------------\n// PARSERS\n//--------------------------------------\nfunction parseEtherscanAbiDefs(_defs) { // `_defs` are `result` of the parsed response\n  const defs = [];\n  _defs.forEach((d) => {\n    if (d.name && d.inputs && d.type === 'function' && d.stateMutability !== 'view') {\n      const sig = getFuncSig(d);\n      const params = parseEtherscanAbiInputs(d.inputs);\n      defs.push({\n        name: d.name,\n        sig,\n        params,\n      })\n    }\n  })\n  return defs;\n}\n\nexports.abiParsers = {\n  etherscan: parseEtherscanAbiDefs,\n}\n\n//--------------------------------------\n// HELPERS\n//--------------------------------------\n// Get the 4-byte function identifier based on the canonical name\nfunction getFuncSig(f) {\n  // Canonical name is:\n  // funcName(paramType0, ..., paramTypeN)\n  let canonicalName = `${f.name}(`;\n  f.inputs.forEach((input) => {\n    canonicalName += `${input.type},`\n  })\n  if (f.inputs.length > 0)\n    canonicalName = canonicalName.slice(0, canonicalName.length - 1)\n  canonicalName += ')'\n  return keccak256(canonicalName).slice(0, 8);\n}\n\n// Parse the ABI param data into structs Lattice firmware will recognize.\nfunction parseEtherscanAbiInputs(inputs) {\n  const data = [];\n  inputs.forEach((input) => {\n    const typeName = input.type;\n    const d = { isArray: false, arraySz: 0, name: input.name, };\n    const openBracketIdx = typeName.indexOf('[');\n    const closeBracketIdx = typeName.indexOf(']');\n    if (openBracketIdx > -1 && closeBracketIdx > -1) {\n      if (openBracketIdx >= closeBracketIdx) {\n        ; // not a valid param -- skip it\n      } else if ((openBracketIdx + 1) === closeBracketIdx) {\n        d.isArray = true;\n      } else {\n        // Parse the array size if applicable\n        const number = parseInt(typeName.slice(openBracketIdx, closeBracketIdx))\n        if (isNaN(number)) {\n          return d;\n        }\n        d.isArray = true;\n        d.arraySz = number;\n      }\n    }\n    const singularTypeName = openBracketIdx > -1 ? typeName.slice(0, openBracketIdx) : typeName;\n    d.latticeTypeIdx = getTypeIdxLatticeFw(singularTypeName)\n    if (!d.latticeTypeIdx)\n      throw new Error(`Unsupported type: ${typeName}`)\n    data.push(d)\n  })\n  return data;\n}\n\n// Enum values from inside Lattice firmware\nfunction getTypeIdxLatticeFw(type) {\n  return ETH_ABI_LATTICE_FW_TYPE_MAP[type];\n}\n"]},"metadata":{},"sourceType":"module"}