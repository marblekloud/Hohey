{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ethUtil = require(\"ethereumjs-util\");\n\nconst _ = require(\"lodash\");\n\nconst util_1 = require(\"util\");\n\nconst AbiEncoder = require(\"./abi_encoder\");\n\nconst configured_bignumber_1 = require(\"./configured_bignumber\");\n/**\n * Register a RevertError type so that it can be decoded by\n * `decodeRevertError`.\n * @param revertClass A class that inherits from RevertError.\n * @param force Allow overwriting registered types.\n */\n\n\nfunction registerRevertErrorType(revertClass, force = false) {\n  RevertError.registerType(revertClass, force);\n}\n\nexports.registerRevertErrorType = registerRevertErrorType;\n/**\n * Decode an ABI encoded revert error.\n * Throws if the data cannot be decoded as a known RevertError type.\n * @param bytes The ABI encoded revert error. Either a hex string or a Buffer.\n * @param coerce Coerce unknown selectors into a `RawRevertError` type.\n * @return A RevertError object.\n */\n\nfunction decodeBytesAsRevertError(bytes, coerce = false) {\n  return RevertError.decode(bytes, coerce);\n}\n\nexports.decodeBytesAsRevertError = decodeBytesAsRevertError;\n/**\n * Decode a thrown error.\n * Throws if the data cannot be decoded as a known RevertError type.\n * @param error Any thrown error.\n * @param coerce Coerce unknown selectors into a `RawRevertError` type.\n * @return A RevertError object.\n */\n\nfunction decodeThrownErrorAsRevertError(error, coerce = false) {\n  if (error instanceof RevertError) {\n    return error;\n  }\n\n  return RevertError.decode(getThrownErrorRevertErrorBytes(error), coerce);\n}\n\nexports.decodeThrownErrorAsRevertError = decodeThrownErrorAsRevertError;\n/**\n * Coerce a thrown error into a `RevertError`. Always succeeds.\n * @param error Any thrown error.\n * @return A RevertError object.\n */\n\nfunction coerceThrownErrorAsRevertError(error) {\n  if (error instanceof RevertError) {\n    return error;\n  }\n\n  try {\n    return decodeThrownErrorAsRevertError(error, true);\n  } catch (err) {\n    if (isGanacheTransactionRevertError(error)) {\n      throw err;\n    } // Handle geth transaction reverts.\n\n\n    if (isGethTransactionRevertError(error)) {\n      // Geth transaction reverts are opaque, meaning no useful data is returned,\n      // so we just return an AnyRevertError type.\n      return new AnyRevertError();\n    } // Coerce plain errors into a StringRevertError.\n\n\n    return new StringRevertError(error.message);\n  }\n}\n\nexports.coerceThrownErrorAsRevertError = coerceThrownErrorAsRevertError;\n/**\n * Base type for revert errors.\n */\n\nclass RevertError extends Error {\n  /**\n   * Create a RevertError instance with optional parameter values.\n   * Parameters that are left undefined will not be tested in equality checks.\n   * @param declaration Function-style declaration of the revert (e.g., Error(string message))\n   * @param values Optional mapping of parameters to values.\n   * @param raw Optional encoded form of the revert error. If supplied, this\n   *        instance will be treated as a `RawRevertError`, meaning it can only\n   *        match other `RawRevertError` types with the same encoded payload.\n   */\n  constructor(name, declaration, values, raw) {\n    super(createErrorMessage(name, values));\n    this.values = {};\n\n    if (declaration !== undefined) {\n      this.abi = declarationToAbi(declaration);\n\n      if (values !== undefined) {\n        _.assign(this.values, _.cloneDeep(values));\n      }\n    }\n\n    this._raw = raw; // Extending Error is tricky; we need to explicitly set the prototype.\n\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n  /**\n   * Decode an ABI encoded revert error.\n   * Throws if the data cannot be decoded as a known RevertError type.\n   * @param bytes The ABI encoded revert error. Either a hex string or a Buffer.\n   * @param coerce Whether to coerce unknown selectors into a `RawRevertError` type.\n   * @return A RevertError object.\n   */\n\n\n  static decode(bytes, coerce = false) {\n    if (bytes instanceof RevertError) {\n      return bytes;\n    }\n\n    const _bytes = bytes instanceof Buffer ? ethUtil.bufferToHex(bytes) : ethUtil.addHexPrefix(bytes); // tslint:disable-next-line: custom-no-magic-numbers\n\n\n    const selector = _bytes.slice(2, 10);\n\n    if (!(selector in RevertError._typeRegistry)) {\n      if (coerce) {\n        return new RawRevertError(bytes);\n      }\n\n      throw new Error(`Unknown selector: ${selector}`);\n    }\n\n    const {\n      type,\n      decoder\n    } = RevertError._typeRegistry[selector];\n    const instance = new type();\n\n    try {\n      Object.assign(instance, {\n        values: decoder(_bytes)\n      });\n      instance.message = instance.toString();\n      return instance;\n    } catch (err) {\n      throw new Error(`Bytes ${_bytes} cannot be decoded as a revert error of type ${instance.signature}: ${err.message}`);\n    }\n  }\n  /**\n   * Register a RevertError type so that it can be decoded by\n   * `RevertError.decode`.\n   * @param revertClass A class that inherits from RevertError.\n   * @param force Allow overwriting existing registrations.\n   */\n\n\n  static registerType(revertClass, force = false) {\n    const instance = new revertClass();\n\n    if (!force && instance.selector in RevertError._typeRegistry) {\n      throw new Error(`RevertError type with signature \"${instance.signature}\" is already registered`);\n    }\n\n    if (_.isNil(instance.abi)) {\n      throw new Error(`Attempting to register a RevertError class with no ABI`);\n    }\n\n    RevertError._typeRegistry[instance.selector] = {\n      type: revertClass,\n      decoder: createDecoder(instance.abi)\n    };\n  }\n  /**\n   * Get the ABI name for this revert.\n   */\n\n\n  get name() {\n    if (!_.isNil(this.abi)) {\n      return this.abi.name;\n    }\n\n    return `<${this.typeName}>`;\n  }\n  /**\n   * Get the class name of this type.\n   */\n\n\n  get typeName() {\n    // tslint:disable-next-line: no-string-literal\n    return this.constructor.name;\n  }\n  /**\n   * Get the hex selector for this revert (without leading '0x').\n   */\n\n\n  get selector() {\n    if (!_.isNil(this.abi)) {\n      return toSelector(this.abi);\n    }\n\n    if (this._isRawType) {\n      // tslint:disable-next-line: custom-no-magic-numbers\n      return this._raw.slice(2, 10);\n    }\n\n    return '';\n  }\n  /**\n   * Get the signature for this revert: e.g., 'Error(string)'.\n   */\n\n\n  get signature() {\n    if (!_.isNil(this.abi)) {\n      return toSignature(this.abi);\n    }\n\n    return '';\n  }\n  /**\n   * Get the ABI arguments for this revert.\n   */\n\n\n  get arguments() {\n    if (!_.isNil(this.abi)) {\n      return this.abi.arguments || [];\n    }\n\n    return [];\n  }\n\n  get [Symbol.toStringTag]() {\n    return this.toString();\n  }\n  /**\n   * Compares this instance with another.\n   * Fails if instances are not of the same type.\n   * Only fields/values defined in both instances are compared.\n   * @param other Either another RevertError instance, hex-encoded bytes, or a Buffer of the ABI encoded revert.\n   * @return True if both instances match.\n   */\n\n\n  equals(other) {\n    let _other = other;\n\n    if (_other instanceof Buffer) {\n      _other = ethUtil.bufferToHex(_other);\n    }\n\n    if (typeof _other === 'string') {\n      _other = RevertError.decode(_other);\n    }\n\n    if (!(_other instanceof RevertError)) {\n      return false;\n    } // If either is of the `AnyRevertError` type, always succeed.\n\n\n    if (this._isAnyType || _other._isAnyType) {\n      return true;\n    } // If either are raw types, they must match their raw data.\n\n\n    if (this._isRawType || _other._isRawType) {\n      return this._raw === _other._raw;\n    } // Must be of same type.\n\n\n    if (this.constructor !== _other.constructor) {\n      return false;\n    } // Must share the same parameter values if defined in both instances.\n\n\n    for (const name of Object.keys(this.values)) {\n      const a = this.values[name];\n      const b = _other.values[name];\n\n      if (a === b) {\n        continue;\n      }\n\n      if (!_.isNil(a) && !_.isNil(b)) {\n        const {\n          type\n        } = this._getArgumentByName(name);\n\n        if (!checkArgEquality(type, a, b)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  encode() {\n    if (this._raw !== undefined) {\n      return this._raw;\n    }\n\n    if (!this._hasAllArgumentValues) {\n      throw new Error(`Instance of ${this.typeName} does not have all its parameter values set.`);\n    }\n\n    const encoder = createEncoder(this.abi);\n    return encoder(this.values);\n  }\n\n  toString() {\n    if (this._isRawType) {\n      return `${this.constructor.name}(${this._raw})`;\n    }\n\n    const values = _.omitBy(this.values, v => _.isNil(v)); // tslint:disable-next-line: forin\n\n\n    for (const k in values) {\n      const {\n        type: argType\n      } = this._getArgumentByName(k);\n\n      if (argType === 'bytes') {\n        // Try to decode nested revert errors.\n        try {\n          values[k] = RevertError.decode(values[k]);\n        } catch (err) {} // tslint:disable-line:no-empty\n\n      }\n    }\n\n    const inner = _.isEmpty(values) ? '' : util_1.inspect(values);\n    return `${this.constructor.name}(${inner})`;\n  }\n\n  _getArgumentByName(name) {\n    const arg = _.find(this.arguments, a => a.name === name);\n\n    if (_.isNil(arg)) {\n      throw new Error(`RevertError ${this.signature} has no argument named ${name}`);\n    }\n\n    return arg;\n  }\n\n  get _isAnyType() {\n    return _.isNil(this.abi) && _.isNil(this._raw);\n  }\n\n  get _isRawType() {\n    return !_.isNil(this._raw);\n  }\n\n  get _hasAllArgumentValues() {\n    if (_.isNil(this.abi) || _.isNil(this.abi.arguments)) {\n      return false;\n    }\n\n    for (const arg of this.abi.arguments) {\n      if (_.isNil(this.values[arg.name])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n} // Map of types registered via `registerType`.\n\n\nRevertError._typeRegistry = {};\nexports.RevertError = RevertError;\nconst PARITY_TRANSACTION_REVERT_ERROR_MESSAGE = /^VM execution error/;\nconst GANACHE_TRANSACTION_REVERT_ERROR_MESSAGE = /^VM Exception while processing transaction: revert/;\nconst GETH_TRANSACTION_REVERT_ERROR_MESSAGE = /always failing transaction$/;\n/**\n * Try to extract the ecnoded revert error bytes from a thrown `Error`.\n */\n\nfunction getThrownErrorRevertErrorBytes(error) {\n  // Handle ganache transaction reverts.\n  if (isGanacheTransactionRevertError(error)) {\n    // Grab the first result attached.\n    const result = error.results[error.hashes[0]]; // If a reason is provided, just wrap it in a StringRevertError\n\n    if (result.reason !== undefined) {\n      return new StringRevertError(result.reason).encode();\n    }\n\n    if (result.return !== undefined && result.return !== '0x') {\n      return result.return;\n    }\n  } else if (isParityTransactionRevertError(error)) {\n    // Parity returns { data: 'Reverted 0xa6bcde47...', ... }\n    const {\n      data\n    } = error;\n    const hexDataIndex = data.indexOf('0x');\n\n    if (hexDataIndex !== -1) {\n      return data.slice(hexDataIndex);\n    }\n  } else {\n    // Handle geth transaction reverts.\n    if (isGethTransactionRevertError(error)) {// Geth transaction reverts are opaque, meaning no useful data is returned,\n      // so we do nothing.\n    }\n  }\n\n  throw new Error(`Cannot decode thrown Error \"${error.message}\" as a RevertError`);\n}\n\nexports.getThrownErrorRevertErrorBytes = getThrownErrorRevertErrorBytes;\n\nfunction isParityTransactionRevertError(error) {\n  if (PARITY_TRANSACTION_REVERT_ERROR_MESSAGE.test(error.message) && 'code' in error && 'data' in error) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isGanacheTransactionRevertError(error) {\n  if (GANACHE_TRANSACTION_REVERT_ERROR_MESSAGE.test(error.message) && 'hashes' in error && 'results' in error) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isGethTransactionRevertError(error) {\n  return GETH_TRANSACTION_REVERT_ERROR_MESSAGE.test(error.message);\n}\n/**\n * RevertError type for standard string reverts.\n */\n\n\nclass StringRevertError extends RevertError {\n  constructor(message) {\n    super('StringRevertError', 'Error(string message)', {\n      message\n    });\n  }\n\n}\n\nexports.StringRevertError = StringRevertError;\n/**\n * Special RevertError type that matches with any other RevertError instance.\n */\n\nclass AnyRevertError extends RevertError {\n  constructor() {\n    super('AnyRevertError');\n  }\n\n}\n\nexports.AnyRevertError = AnyRevertError;\n/**\n * Special RevertError type that is not decoded.\n */\n\nclass RawRevertError extends RevertError {\n  constructor(encoded) {\n    super('RawRevertError', undefined, undefined, typeof encoded === 'string' ? encoded : ethUtil.bufferToHex(encoded));\n  }\n\n}\n\nexports.RawRevertError = RawRevertError;\n/**\n * Create an error message for a RevertError.\n * @param name The name of the RevertError.\n * @param values The values for the RevertError.\n */\n\nfunction createErrorMessage(name, values) {\n  if (values === undefined) {\n    return `${name}()`;\n  }\n\n  const _values = _.omitBy(values, v => _.isNil(v));\n\n  const inner = _.isEmpty(_values) ? '' : util_1.inspect(_values);\n  return `${name}(${inner})`;\n}\n/**\n * Parse a solidity function declaration into a RevertErrorAbi object.\n * @param declaration Function declaration (e.g., 'foo(uint256 bar)').\n * @return A RevertErrorAbi object.\n */\n\n\nfunction declarationToAbi(declaration) {\n  let m = /^\\s*([_a-z][a-z0-9_]*)\\((.*)\\)\\s*$/i.exec(declaration);\n\n  if (!m) {\n    throw new Error(`Invalid Revert Error signature: \"${declaration}\"`);\n  }\n\n  const [name, args] = m.slice(1);\n\n  const argList = _.filter(args.split(','));\n\n  const argData = _.map(argList, a => {\n    // Match a function parameter in the format 'TYPE ID', where 'TYPE' may be\n    // an array type.\n    m = /^\\s*(([_a-z][a-z0-9_]*)(\\[\\d*\\])*)\\s+([_a-z][a-z0-9_]*)\\s*$/i.exec(a);\n\n    if (!m) {\n      throw new Error(`Invalid Revert Error signature: \"${declaration}\"`);\n    } // tslint:disable: custom-no-magic-numbers\n\n\n    return {\n      name: m[4],\n      type: m[1]\n    }; // tslint:enable: custom-no-magic-numbers\n  });\n\n  const r = {\n    type: 'error',\n    name,\n    arguments: _.isEmpty(argData) ? [] : argData\n  };\n  return r;\n}\n\nfunction checkArgEquality(type, lhs, rhs) {\n  // Try to compare as decoded revert errors first.\n  try {\n    return RevertError.decode(lhs).equals(RevertError.decode(rhs));\n  } catch (err) {// no-op\n  }\n\n  if (type === 'address') {\n    return normalizeAddress(lhs) === normalizeAddress(rhs);\n  } else if (type === 'bytes' || /^bytes(\\d+)$/.test(type)) {\n    return normalizeBytes(lhs) === normalizeBytes(rhs);\n  } else if (type === 'string') {\n    return lhs === rhs;\n  } else if (/\\[\\d*\\]$/.test(type)) {\n    // An array type.\n    // tslint:disable: custom-no-magic-numbers\n    // Arguments must be arrays and have the same dimensions.\n    if (lhs.length !== rhs.length) {\n      return false;\n    }\n\n    const m = /^(.+)\\[(\\d*)\\]$/.exec(type);\n    const baseType = m[1];\n    const isFixedLength = m[2].length !== 0;\n\n    if (isFixedLength) {\n      const length = parseInt(m[2], 10); // Fixed-size arrays have a fixed dimension.\n\n      if (lhs.length !== length) {\n        return false;\n      }\n    } // Recurse into sub-elements.\n\n\n    for (const [slhs, srhs] of _.zip(lhs, rhs)) {\n      if (!checkArgEquality(baseType, slhs, srhs)) {\n        return false;\n      }\n    }\n\n    return true; // tslint:enable: no-magic-numbers\n  } // tslint:disable-next-line\n\n\n  return new configured_bignumber_1.BigNumber(lhs || 0).eq(rhs);\n}\n\nfunction normalizeAddress(addr) {\n  const ADDRESS_SIZE = 20;\n  return ethUtil.bufferToHex(ethUtil.setLengthLeft(ethUtil.toBuffer(ethUtil.addHexPrefix(addr)), ADDRESS_SIZE));\n}\n\nfunction normalizeBytes(bytes) {\n  return ethUtil.addHexPrefix(bytes).toLowerCase();\n}\n\nfunction createEncoder(abi) {\n  const encoder = AbiEncoder.createMethod(abi.name, abi.arguments || []);\n  return values => {\n    const valuesArray = _.map(abi.arguments, arg => values[arg.name]);\n\n    return encoder.encode(valuesArray);\n  };\n}\n\nfunction createDecoder(abi) {\n  const encoder = AbiEncoder.createMethod(abi.name, abi.arguments || []);\n  return hex => {\n    return encoder.decode(hex);\n  };\n}\n\nfunction toSignature(abi) {\n  const argTypes = _.map(abi.arguments, a => a.type);\n\n  const args = argTypes.join(',');\n  return `${abi.name}(${args})`;\n}\n\nfunction toSelector(abi) {\n  return ethUtil.sha3(Buffer.from(toSignature(abi))) // tslint:disable-next-line: custom-no-magic-numbers\n  .slice(0, 4).toString('hex');\n} // Register StringRevertError\n\n\nRevertError.registerType(StringRevertError); // tslint:disable-next-line max-file-line-count","map":{"version":3,"sources":["../../src/revert_error.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ethUtil = require(\"ethereumjs-util\");\nconst _ = require(\"lodash\");\nconst util_1 = require(\"util\");\nconst AbiEncoder = require(\"./abi_encoder\");\nconst configured_bignumber_1 = require(\"./configured_bignumber\");\n/**\n * Register a RevertError type so that it can be decoded by\n * `decodeRevertError`.\n * @param revertClass A class that inherits from RevertError.\n * @param force Allow overwriting registered types.\n */\nfunction registerRevertErrorType(revertClass, force = false) {\n    RevertError.registerType(revertClass, force);\n}\nexports.registerRevertErrorType = registerRevertErrorType;\n/**\n * Decode an ABI encoded revert error.\n * Throws if the data cannot be decoded as a known RevertError type.\n * @param bytes The ABI encoded revert error. Either a hex string or a Buffer.\n * @param coerce Coerce unknown selectors into a `RawRevertError` type.\n * @return A RevertError object.\n */\nfunction decodeBytesAsRevertError(bytes, coerce = false) {\n    return RevertError.decode(bytes, coerce);\n}\nexports.decodeBytesAsRevertError = decodeBytesAsRevertError;\n/**\n * Decode a thrown error.\n * Throws if the data cannot be decoded as a known RevertError type.\n * @param error Any thrown error.\n * @param coerce Coerce unknown selectors into a `RawRevertError` type.\n * @return A RevertError object.\n */\nfunction decodeThrownErrorAsRevertError(error, coerce = false) {\n    if (error instanceof RevertError) {\n        return error;\n    }\n    return RevertError.decode(getThrownErrorRevertErrorBytes(error), coerce);\n}\nexports.decodeThrownErrorAsRevertError = decodeThrownErrorAsRevertError;\n/**\n * Coerce a thrown error into a `RevertError`. Always succeeds.\n * @param error Any thrown error.\n * @return A RevertError object.\n */\nfunction coerceThrownErrorAsRevertError(error) {\n    if (error instanceof RevertError) {\n        return error;\n    }\n    try {\n        return decodeThrownErrorAsRevertError(error, true);\n    }\n    catch (err) {\n        if (isGanacheTransactionRevertError(error)) {\n            throw err;\n        }\n        // Handle geth transaction reverts.\n        if (isGethTransactionRevertError(error)) {\n            // Geth transaction reverts are opaque, meaning no useful data is returned,\n            // so we just return an AnyRevertError type.\n            return new AnyRevertError();\n        }\n        // Coerce plain errors into a StringRevertError.\n        return new StringRevertError(error.message);\n    }\n}\nexports.coerceThrownErrorAsRevertError = coerceThrownErrorAsRevertError;\n/**\n * Base type for revert errors.\n */\nclass RevertError extends Error {\n    /**\n     * Create a RevertError instance with optional parameter values.\n     * Parameters that are left undefined will not be tested in equality checks.\n     * @param declaration Function-style declaration of the revert (e.g., Error(string message))\n     * @param values Optional mapping of parameters to values.\n     * @param raw Optional encoded form of the revert error. If supplied, this\n     *        instance will be treated as a `RawRevertError`, meaning it can only\n     *        match other `RawRevertError` types with the same encoded payload.\n     */\n    constructor(name, declaration, values, raw) {\n        super(createErrorMessage(name, values));\n        this.values = {};\n        if (declaration !== undefined) {\n            this.abi = declarationToAbi(declaration);\n            if (values !== undefined) {\n                _.assign(this.values, _.cloneDeep(values));\n            }\n        }\n        this._raw = raw;\n        // Extending Error is tricky; we need to explicitly set the prototype.\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n    /**\n     * Decode an ABI encoded revert error.\n     * Throws if the data cannot be decoded as a known RevertError type.\n     * @param bytes The ABI encoded revert error. Either a hex string or a Buffer.\n     * @param coerce Whether to coerce unknown selectors into a `RawRevertError` type.\n     * @return A RevertError object.\n     */\n    static decode(bytes, coerce = false) {\n        if (bytes instanceof RevertError) {\n            return bytes;\n        }\n        const _bytes = bytes instanceof Buffer ? ethUtil.bufferToHex(bytes) : ethUtil.addHexPrefix(bytes);\n        // tslint:disable-next-line: custom-no-magic-numbers\n        const selector = _bytes.slice(2, 10);\n        if (!(selector in RevertError._typeRegistry)) {\n            if (coerce) {\n                return new RawRevertError(bytes);\n            }\n            throw new Error(`Unknown selector: ${selector}`);\n        }\n        const { type, decoder } = RevertError._typeRegistry[selector];\n        const instance = new type();\n        try {\n            Object.assign(instance, { values: decoder(_bytes) });\n            instance.message = instance.toString();\n            return instance;\n        }\n        catch (err) {\n            throw new Error(`Bytes ${_bytes} cannot be decoded as a revert error of type ${instance.signature}: ${err.message}`);\n        }\n    }\n    /**\n     * Register a RevertError type so that it can be decoded by\n     * `RevertError.decode`.\n     * @param revertClass A class that inherits from RevertError.\n     * @param force Allow overwriting existing registrations.\n     */\n    static registerType(revertClass, force = false) {\n        const instance = new revertClass();\n        if (!force && instance.selector in RevertError._typeRegistry) {\n            throw new Error(`RevertError type with signature \"${instance.signature}\" is already registered`);\n        }\n        if (_.isNil(instance.abi)) {\n            throw new Error(`Attempting to register a RevertError class with no ABI`);\n        }\n        RevertError._typeRegistry[instance.selector] = {\n            type: revertClass,\n            decoder: createDecoder(instance.abi),\n        };\n    }\n    /**\n     * Get the ABI name for this revert.\n     */\n    get name() {\n        if (!_.isNil(this.abi)) {\n            return this.abi.name;\n        }\n        return `<${this.typeName}>`;\n    }\n    /**\n     * Get the class name of this type.\n     */\n    get typeName() {\n        // tslint:disable-next-line: no-string-literal\n        return this.constructor.name;\n    }\n    /**\n     * Get the hex selector for this revert (without leading '0x').\n     */\n    get selector() {\n        if (!_.isNil(this.abi)) {\n            return toSelector(this.abi);\n        }\n        if (this._isRawType) {\n            // tslint:disable-next-line: custom-no-magic-numbers\n            return this._raw.slice(2, 10);\n        }\n        return '';\n    }\n    /**\n     * Get the signature for this revert: e.g., 'Error(string)'.\n     */\n    get signature() {\n        if (!_.isNil(this.abi)) {\n            return toSignature(this.abi);\n        }\n        return '';\n    }\n    /**\n     * Get the ABI arguments for this revert.\n     */\n    get arguments() {\n        if (!_.isNil(this.abi)) {\n            return this.abi.arguments || [];\n        }\n        return [];\n    }\n    get [Symbol.toStringTag]() {\n        return this.toString();\n    }\n    /**\n     * Compares this instance with another.\n     * Fails if instances are not of the same type.\n     * Only fields/values defined in both instances are compared.\n     * @param other Either another RevertError instance, hex-encoded bytes, or a Buffer of the ABI encoded revert.\n     * @return True if both instances match.\n     */\n    equals(other) {\n        let _other = other;\n        if (_other instanceof Buffer) {\n            _other = ethUtil.bufferToHex(_other);\n        }\n        if (typeof _other === 'string') {\n            _other = RevertError.decode(_other);\n        }\n        if (!(_other instanceof RevertError)) {\n            return false;\n        }\n        // If either is of the `AnyRevertError` type, always succeed.\n        if (this._isAnyType || _other._isAnyType) {\n            return true;\n        }\n        // If either are raw types, they must match their raw data.\n        if (this._isRawType || _other._isRawType) {\n            return this._raw === _other._raw;\n        }\n        // Must be of same type.\n        if (this.constructor !== _other.constructor) {\n            return false;\n        }\n        // Must share the same parameter values if defined in both instances.\n        for (const name of Object.keys(this.values)) {\n            const a = this.values[name];\n            const b = _other.values[name];\n            if (a === b) {\n                continue;\n            }\n            if (!_.isNil(a) && !_.isNil(b)) {\n                const { type } = this._getArgumentByName(name);\n                if (!checkArgEquality(type, a, b)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    encode() {\n        if (this._raw !== undefined) {\n            return this._raw;\n        }\n        if (!this._hasAllArgumentValues) {\n            throw new Error(`Instance of ${this.typeName} does not have all its parameter values set.`);\n        }\n        const encoder = createEncoder(this.abi);\n        return encoder(this.values);\n    }\n    toString() {\n        if (this._isRawType) {\n            return `${this.constructor.name}(${this._raw})`;\n        }\n        const values = _.omitBy(this.values, (v) => _.isNil(v));\n        // tslint:disable-next-line: forin\n        for (const k in values) {\n            const { type: argType } = this._getArgumentByName(k);\n            if (argType === 'bytes') {\n                // Try to decode nested revert errors.\n                try {\n                    values[k] = RevertError.decode(values[k]);\n                }\n                catch (err) { } // tslint:disable-line:no-empty\n            }\n        }\n        const inner = _.isEmpty(values) ? '' : util_1.inspect(values);\n        return `${this.constructor.name}(${inner})`;\n    }\n    _getArgumentByName(name) {\n        const arg = _.find(this.arguments, (a) => a.name === name);\n        if (_.isNil(arg)) {\n            throw new Error(`RevertError ${this.signature} has no argument named ${name}`);\n        }\n        return arg;\n    }\n    get _isAnyType() {\n        return _.isNil(this.abi) && _.isNil(this._raw);\n    }\n    get _isRawType() {\n        return !_.isNil(this._raw);\n    }\n    get _hasAllArgumentValues() {\n        if (_.isNil(this.abi) || _.isNil(this.abi.arguments)) {\n            return false;\n        }\n        for (const arg of this.abi.arguments) {\n            if (_.isNil(this.values[arg.name])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n// Map of types registered via `registerType`.\nRevertError._typeRegistry = {};\nexports.RevertError = RevertError;\nconst PARITY_TRANSACTION_REVERT_ERROR_MESSAGE = /^VM execution error/;\nconst GANACHE_TRANSACTION_REVERT_ERROR_MESSAGE = /^VM Exception while processing transaction: revert/;\nconst GETH_TRANSACTION_REVERT_ERROR_MESSAGE = /always failing transaction$/;\n/**\n * Try to extract the ecnoded revert error bytes from a thrown `Error`.\n */\nfunction getThrownErrorRevertErrorBytes(error) {\n    // Handle ganache transaction reverts.\n    if (isGanacheTransactionRevertError(error)) {\n        // Grab the first result attached.\n        const result = error.results[error.hashes[0]];\n        // If a reason is provided, just wrap it in a StringRevertError\n        if (result.reason !== undefined) {\n            return new StringRevertError(result.reason).encode();\n        }\n        if (result.return !== undefined && result.return !== '0x') {\n            return result.return;\n        }\n    }\n    else if (isParityTransactionRevertError(error)) {\n        // Parity returns { data: 'Reverted 0xa6bcde47...', ... }\n        const { data } = error;\n        const hexDataIndex = data.indexOf('0x');\n        if (hexDataIndex !== -1) {\n            return data.slice(hexDataIndex);\n        }\n    }\n    else {\n        // Handle geth transaction reverts.\n        if (isGethTransactionRevertError(error)) {\n            // Geth transaction reverts are opaque, meaning no useful data is returned,\n            // so we do nothing.\n        }\n    }\n    throw new Error(`Cannot decode thrown Error \"${error.message}\" as a RevertError`);\n}\nexports.getThrownErrorRevertErrorBytes = getThrownErrorRevertErrorBytes;\nfunction isParityTransactionRevertError(error) {\n    if (PARITY_TRANSACTION_REVERT_ERROR_MESSAGE.test(error.message) && 'code' in error && 'data' in error) {\n        return true;\n    }\n    return false;\n}\nfunction isGanacheTransactionRevertError(error) {\n    if (GANACHE_TRANSACTION_REVERT_ERROR_MESSAGE.test(error.message) && 'hashes' in error && 'results' in error) {\n        return true;\n    }\n    return false;\n}\nfunction isGethTransactionRevertError(error) {\n    return GETH_TRANSACTION_REVERT_ERROR_MESSAGE.test(error.message);\n}\n/**\n * RevertError type for standard string reverts.\n */\nclass StringRevertError extends RevertError {\n    constructor(message) {\n        super('StringRevertError', 'Error(string message)', { message });\n    }\n}\nexports.StringRevertError = StringRevertError;\n/**\n * Special RevertError type that matches with any other RevertError instance.\n */\nclass AnyRevertError extends RevertError {\n    constructor() {\n        super('AnyRevertError');\n    }\n}\nexports.AnyRevertError = AnyRevertError;\n/**\n * Special RevertError type that is not decoded.\n */\nclass RawRevertError extends RevertError {\n    constructor(encoded) {\n        super('RawRevertError', undefined, undefined, typeof encoded === 'string' ? encoded : ethUtil.bufferToHex(encoded));\n    }\n}\nexports.RawRevertError = RawRevertError;\n/**\n * Create an error message for a RevertError.\n * @param name The name of the RevertError.\n * @param values The values for the RevertError.\n */\nfunction createErrorMessage(name, values) {\n    if (values === undefined) {\n        return `${name}()`;\n    }\n    const _values = _.omitBy(values, (v) => _.isNil(v));\n    const inner = _.isEmpty(_values) ? '' : util_1.inspect(_values);\n    return `${name}(${inner})`;\n}\n/**\n * Parse a solidity function declaration into a RevertErrorAbi object.\n * @param declaration Function declaration (e.g., 'foo(uint256 bar)').\n * @return A RevertErrorAbi object.\n */\nfunction declarationToAbi(declaration) {\n    let m = /^\\s*([_a-z][a-z0-9_]*)\\((.*)\\)\\s*$/i.exec(declaration);\n    if (!m) {\n        throw new Error(`Invalid Revert Error signature: \"${declaration}\"`);\n    }\n    const [name, args] = m.slice(1);\n    const argList = _.filter(args.split(','));\n    const argData = _.map(argList, (a) => {\n        // Match a function parameter in the format 'TYPE ID', where 'TYPE' may be\n        // an array type.\n        m = /^\\s*(([_a-z][a-z0-9_]*)(\\[\\d*\\])*)\\s+([_a-z][a-z0-9_]*)\\s*$/i.exec(a);\n        if (!m) {\n            throw new Error(`Invalid Revert Error signature: \"${declaration}\"`);\n        }\n        // tslint:disable: custom-no-magic-numbers\n        return {\n            name: m[4],\n            type: m[1],\n        };\n        // tslint:enable: custom-no-magic-numbers\n    });\n    const r = {\n        type: 'error',\n        name,\n        arguments: _.isEmpty(argData) ? [] : argData,\n    };\n    return r;\n}\nfunction checkArgEquality(type, lhs, rhs) {\n    // Try to compare as decoded revert errors first.\n    try {\n        return RevertError.decode(lhs).equals(RevertError.decode(rhs));\n    }\n    catch (err) {\n        // no-op\n    }\n    if (type === 'address') {\n        return normalizeAddress(lhs) === normalizeAddress(rhs);\n    }\n    else if (type === 'bytes' || /^bytes(\\d+)$/.test(type)) {\n        return normalizeBytes(lhs) === normalizeBytes(rhs);\n    }\n    else if (type === 'string') {\n        return lhs === rhs;\n    }\n    else if (/\\[\\d*\\]$/.test(type)) {\n        // An array type.\n        // tslint:disable: custom-no-magic-numbers\n        // Arguments must be arrays and have the same dimensions.\n        if (lhs.length !== rhs.length) {\n            return false;\n        }\n        const m = /^(.+)\\[(\\d*)\\]$/.exec(type);\n        const baseType = m[1];\n        const isFixedLength = m[2].length !== 0;\n        if (isFixedLength) {\n            const length = parseInt(m[2], 10);\n            // Fixed-size arrays have a fixed dimension.\n            if (lhs.length !== length) {\n                return false;\n            }\n        }\n        // Recurse into sub-elements.\n        for (const [slhs, srhs] of _.zip(lhs, rhs)) {\n            if (!checkArgEquality(baseType, slhs, srhs)) {\n                return false;\n            }\n        }\n        return true;\n        // tslint:enable: no-magic-numbers\n    }\n    // tslint:disable-next-line\n    return new configured_bignumber_1.BigNumber(lhs || 0).eq(rhs);\n}\nfunction normalizeAddress(addr) {\n    const ADDRESS_SIZE = 20;\n    return ethUtil.bufferToHex(ethUtil.setLengthLeft(ethUtil.toBuffer(ethUtil.addHexPrefix(addr)), ADDRESS_SIZE));\n}\nfunction normalizeBytes(bytes) {\n    return ethUtil.addHexPrefix(bytes).toLowerCase();\n}\nfunction createEncoder(abi) {\n    const encoder = AbiEncoder.createMethod(abi.name, abi.arguments || []);\n    return (values) => {\n        const valuesArray = _.map(abi.arguments, (arg) => values[arg.name]);\n        return encoder.encode(valuesArray);\n    };\n}\nfunction createDecoder(abi) {\n    const encoder = AbiEncoder.createMethod(abi.name, abi.arguments || []);\n    return (hex) => {\n        return encoder.decode(hex);\n    };\n}\nfunction toSignature(abi) {\n    const argTypes = _.map(abi.arguments, (a) => a.type);\n    const args = argTypes.join(',');\n    return `${abi.name}(${args})`;\n}\nfunction toSelector(abi) {\n    return (ethUtil\n        .sha3(Buffer.from(toSignature(abi)))\n        // tslint:disable-next-line: custom-no-magic-numbers\n        .slice(0, 4)\n        .toString('hex'));\n}\n// Register StringRevertError\nRevertError.registerType(StringRevertError);\n// tslint:disable-next-line max-file-line-count\n//# sourceMappingURL=revert_error.js.map"]},"metadata":{},"sourceType":"module"}