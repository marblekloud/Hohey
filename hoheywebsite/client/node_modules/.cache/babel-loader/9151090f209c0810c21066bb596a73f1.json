{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst _ = require(\"lodash\");\n\nconst signature_parser_1 = require(\"./utils/signature_parser\");\n\nconst address_1 = require(\"./evm_data_types/address\");\n\nconst array_1 = require(\"./evm_data_types/array\");\n\nconst bool_1 = require(\"./evm_data_types/bool\");\n\nconst dynamic_bytes_1 = require(\"./evm_data_types/dynamic_bytes\");\n\nconst int_1 = require(\"./evm_data_types/int\");\n\nconst method_1 = require(\"./evm_data_types/method\");\n\nconst pointer_1 = require(\"./evm_data_types/pointer\");\n\nconst static_bytes_1 = require(\"./evm_data_types/static_bytes\");\n\nconst string_1 = require(\"./evm_data_types/string\");\n\nconst tuple_1 = require(\"./evm_data_types/tuple\");\n\nconst uint_1 = require(\"./evm_data_types/uint\");\n\nclass Address extends address_1.AddressDataType {\n  constructor(dataItem) {\n    super(dataItem, EvmDataTypeFactory.getInstance());\n  }\n\n}\n\nexports.Address = Address;\n\nclass Bool extends bool_1.BoolDataType {\n  constructor(dataItem) {\n    super(dataItem, EvmDataTypeFactory.getInstance());\n  }\n\n}\n\nexports.Bool = Bool;\n\nclass Int extends int_1.IntDataType {\n  constructor(dataItem) {\n    super(dataItem, EvmDataTypeFactory.getInstance());\n  }\n\n}\n\nexports.Int = Int;\n\nclass UInt extends uint_1.UIntDataType {\n  constructor(dataItem) {\n    super(dataItem, EvmDataTypeFactory.getInstance());\n  }\n\n}\n\nexports.UInt = UInt;\n\nclass StaticBytes extends static_bytes_1.StaticBytesDataType {\n  constructor(dataItem) {\n    super(dataItem, EvmDataTypeFactory.getInstance());\n  }\n\n}\n\nexports.StaticBytes = StaticBytes;\n\nclass DynamicBytes extends dynamic_bytes_1.DynamicBytesDataType {\n  constructor(dataItem) {\n    super(dataItem, EvmDataTypeFactory.getInstance());\n  }\n\n}\n\nexports.DynamicBytes = DynamicBytes;\n\nclass String extends string_1.StringDataType {\n  constructor(dataItem) {\n    super(dataItem, EvmDataTypeFactory.getInstance());\n  }\n\n}\n\nexports.String = String;\n\nclass Pointer extends pointer_1.PointerDataType {\n  constructor(destDataType, parentDataType) {\n    super(destDataType, parentDataType, EvmDataTypeFactory.getInstance());\n  }\n\n}\n\nexports.Pointer = Pointer;\n\nclass Tuple extends tuple_1.TupleDataType {\n  constructor(dataItem) {\n    super(dataItem, EvmDataTypeFactory.getInstance());\n  }\n\n}\n\nexports.Tuple = Tuple;\n\nclass Array extends array_1.ArrayDataType {\n  constructor(dataItem) {\n    super(dataItem, EvmDataTypeFactory.getInstance());\n  }\n\n}\n\nexports.Array = Array;\n\nclass Method extends method_1.MethodDataType {\n  constructor(abi) {\n    super(abi, EvmDataTypeFactory.getInstance());\n  }\n\n}\n\nexports.Method = Method;\n/* tslint:disable no-construct */\n\nclass EvmDataTypeFactory {\n  static getInstance() {\n    if (!EvmDataTypeFactory._instance) {\n      EvmDataTypeFactory._instance = new EvmDataTypeFactory();\n    }\n\n    return EvmDataTypeFactory._instance;\n  }\n  /* tslint:disable prefer-function-over-method */\n\n\n  create(dataItem, parentDataType) {\n    // Create data type\n    let dataType;\n\n    if (Array.matchType(dataItem.type)) {\n      dataType = new Array(dataItem);\n    } else if (Address.matchType(dataItem.type)) {\n      dataType = new Address(dataItem);\n    } else if (Bool.matchType(dataItem.type)) {\n      dataType = new Bool(dataItem);\n    } else if (Int.matchType(dataItem.type)) {\n      dataType = new Int(dataItem);\n    } else if (UInt.matchType(dataItem.type)) {\n      dataType = new UInt(dataItem);\n    } else if (StaticBytes.matchType(dataItem.type)) {\n      dataType = new StaticBytes(dataItem);\n    } else if (Tuple.matchType(dataItem.type)) {\n      dataType = new Tuple(dataItem);\n    } else if (DynamicBytes.matchType(dataItem.type)) {\n      dataType = new DynamicBytes(dataItem);\n    } else if (String.matchType(dataItem.type)) {\n      dataType = new String(dataItem);\n    } // @TODO: DataTypeement Fixed/UFixed types\n\n\n    if (dataType === undefined) {\n      throw new Error(`Unrecognized data type: '${dataItem.type}'`);\n    } else if (parentDataType !== undefined && !dataType.isStatic()) {\n      const pointerToDataType = new Pointer(dataType, parentDataType);\n      return pointerToDataType;\n    }\n\n    return dataType;\n  }\n  /* tslint:enable prefer-function-over-method */\n\n\n  constructor() {}\n\n}\n\nexports.EvmDataTypeFactory = EvmDataTypeFactory;\n/**\n * Convenience function for creating a DataType from different inputs.\n * @param input A single or set of DataItem or a signature for an EVM data type.\n * @return DataType corresponding to input.\n */\n\nfunction create(input) {\n  const dataItem = consolidateDataItemsIntoSingle(input);\n  const dataType = EvmDataTypeFactory.getInstance().create(dataItem);\n  return dataType;\n}\n\nexports.create = create;\n/**\n * Convenience function to aggregate a single input or a set of inputs into a single DataItem.\n * An array of data items is grouped into a single tuple.\n * @param input A single data item; a set of data items; a signature.\n * @return A single data item corresponding to input.\n */\n\nfunction consolidateDataItemsIntoSingle(input) {\n  let dataItem;\n\n  if (_.isArray(input)) {\n    const dataItems = input;\n    dataItem = {\n      name: '',\n      type: 'tuple',\n      components: dataItems\n    };\n  } else {\n    dataItem = _.isString(input) ? signature_parser_1.generateDataItemFromSignature(input) : input;\n  }\n\n  return dataItem;\n}\n/**\n * Convenience function for creating a Method encoder from different inputs.\n * @param methodName name of method.\n * @param input A single data item; a set of data items; a signature; or an array of signatures (optional).\n * @param output A single data item; a set of data items; a signature; or an array of signatures (optional).\n * @return Method corresponding to input.\n */\n\n\nfunction createMethod(methodName, input, output) {\n  const methodInput = input === undefined ? [] : consolidateDataItemsIntoArray(input);\n  const methodOutput = output === undefined ? [] : consolidateDataItemsIntoArray(output);\n  const methodAbi = {\n    name: methodName,\n    inputs: methodInput,\n    outputs: methodOutput,\n    type: 'function',\n    // default fields not used by ABI\n    constant: false,\n    payable: false,\n    stateMutability: 'nonpayable'\n  };\n  const dataType = new Method(methodAbi);\n  return dataType;\n}\n\nexports.createMethod = createMethod;\n/**\n * Convenience function that aggregates a single input or a set of inputs into an array of DataItems.\n * @param input A single data item; a set of data items; a signature; or an array of signatures.\n * @return Array of data items corresponding to input.\n */\n\nfunction consolidateDataItemsIntoArray(input) {\n  let dataItems;\n\n  if (_.isArray(input) && _.isEmpty(input)) {\n    dataItems = [];\n  } else if (_.isArray(input) && _.isString(input[0])) {\n    dataItems = [];\n\n    _.each(input, signature => {\n      const dataItem = signature_parser_1.generateDataItemFromSignature(signature);\n      dataItems.push(dataItem);\n    });\n  } else if (_.isArray(input)) {\n    dataItems = input;\n  } else if (typeof input === 'string') {\n    const dataItem = signature_parser_1.generateDataItemFromSignature(input);\n    dataItems = [dataItem];\n  } else {\n    dataItems = [input];\n  }\n\n  return dataItems;\n}\n/* tslint:enable no-construct */","map":{"version":3,"sources":["../../../src/abi_encoder/evm_data_type_factory.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst _ = require(\"lodash\");\nconst signature_parser_1 = require(\"./utils/signature_parser\");\nconst address_1 = require(\"./evm_data_types/address\");\nconst array_1 = require(\"./evm_data_types/array\");\nconst bool_1 = require(\"./evm_data_types/bool\");\nconst dynamic_bytes_1 = require(\"./evm_data_types/dynamic_bytes\");\nconst int_1 = require(\"./evm_data_types/int\");\nconst method_1 = require(\"./evm_data_types/method\");\nconst pointer_1 = require(\"./evm_data_types/pointer\");\nconst static_bytes_1 = require(\"./evm_data_types/static_bytes\");\nconst string_1 = require(\"./evm_data_types/string\");\nconst tuple_1 = require(\"./evm_data_types/tuple\");\nconst uint_1 = require(\"./evm_data_types/uint\");\nclass Address extends address_1.AddressDataType {\n    constructor(dataItem) {\n        super(dataItem, EvmDataTypeFactory.getInstance());\n    }\n}\nexports.Address = Address;\nclass Bool extends bool_1.BoolDataType {\n    constructor(dataItem) {\n        super(dataItem, EvmDataTypeFactory.getInstance());\n    }\n}\nexports.Bool = Bool;\nclass Int extends int_1.IntDataType {\n    constructor(dataItem) {\n        super(dataItem, EvmDataTypeFactory.getInstance());\n    }\n}\nexports.Int = Int;\nclass UInt extends uint_1.UIntDataType {\n    constructor(dataItem) {\n        super(dataItem, EvmDataTypeFactory.getInstance());\n    }\n}\nexports.UInt = UInt;\nclass StaticBytes extends static_bytes_1.StaticBytesDataType {\n    constructor(dataItem) {\n        super(dataItem, EvmDataTypeFactory.getInstance());\n    }\n}\nexports.StaticBytes = StaticBytes;\nclass DynamicBytes extends dynamic_bytes_1.DynamicBytesDataType {\n    constructor(dataItem) {\n        super(dataItem, EvmDataTypeFactory.getInstance());\n    }\n}\nexports.DynamicBytes = DynamicBytes;\nclass String extends string_1.StringDataType {\n    constructor(dataItem) {\n        super(dataItem, EvmDataTypeFactory.getInstance());\n    }\n}\nexports.String = String;\nclass Pointer extends pointer_1.PointerDataType {\n    constructor(destDataType, parentDataType) {\n        super(destDataType, parentDataType, EvmDataTypeFactory.getInstance());\n    }\n}\nexports.Pointer = Pointer;\nclass Tuple extends tuple_1.TupleDataType {\n    constructor(dataItem) {\n        super(dataItem, EvmDataTypeFactory.getInstance());\n    }\n}\nexports.Tuple = Tuple;\nclass Array extends array_1.ArrayDataType {\n    constructor(dataItem) {\n        super(dataItem, EvmDataTypeFactory.getInstance());\n    }\n}\nexports.Array = Array;\nclass Method extends method_1.MethodDataType {\n    constructor(abi) {\n        super(abi, EvmDataTypeFactory.getInstance());\n    }\n}\nexports.Method = Method;\n/* tslint:disable no-construct */\nclass EvmDataTypeFactory {\n    static getInstance() {\n        if (!EvmDataTypeFactory._instance) {\n            EvmDataTypeFactory._instance = new EvmDataTypeFactory();\n        }\n        return EvmDataTypeFactory._instance;\n    }\n    /* tslint:disable prefer-function-over-method */\n    create(dataItem, parentDataType) {\n        // Create data type\n        let dataType;\n        if (Array.matchType(dataItem.type)) {\n            dataType = new Array(dataItem);\n        }\n        else if (Address.matchType(dataItem.type)) {\n            dataType = new Address(dataItem);\n        }\n        else if (Bool.matchType(dataItem.type)) {\n            dataType = new Bool(dataItem);\n        }\n        else if (Int.matchType(dataItem.type)) {\n            dataType = new Int(dataItem);\n        }\n        else if (UInt.matchType(dataItem.type)) {\n            dataType = new UInt(dataItem);\n        }\n        else if (StaticBytes.matchType(dataItem.type)) {\n            dataType = new StaticBytes(dataItem);\n        }\n        else if (Tuple.matchType(dataItem.type)) {\n            dataType = new Tuple(dataItem);\n        }\n        else if (DynamicBytes.matchType(dataItem.type)) {\n            dataType = new DynamicBytes(dataItem);\n        }\n        else if (String.matchType(dataItem.type)) {\n            dataType = new String(dataItem);\n        }\n        // @TODO: DataTypeement Fixed/UFixed types\n        if (dataType === undefined) {\n            throw new Error(`Unrecognized data type: '${dataItem.type}'`);\n        }\n        else if (parentDataType !== undefined && !dataType.isStatic()) {\n            const pointerToDataType = new Pointer(dataType, parentDataType);\n            return pointerToDataType;\n        }\n        return dataType;\n    }\n    /* tslint:enable prefer-function-over-method */\n    constructor() { }\n}\nexports.EvmDataTypeFactory = EvmDataTypeFactory;\n/**\n * Convenience function for creating a DataType from different inputs.\n * @param input A single or set of DataItem or a signature for an EVM data type.\n * @return DataType corresponding to input.\n */\nfunction create(input) {\n    const dataItem = consolidateDataItemsIntoSingle(input);\n    const dataType = EvmDataTypeFactory.getInstance().create(dataItem);\n    return dataType;\n}\nexports.create = create;\n/**\n * Convenience function to aggregate a single input or a set of inputs into a single DataItem.\n * An array of data items is grouped into a single tuple.\n * @param input A single data item; a set of data items; a signature.\n * @return A single data item corresponding to input.\n */\nfunction consolidateDataItemsIntoSingle(input) {\n    let dataItem;\n    if (_.isArray(input)) {\n        const dataItems = input;\n        dataItem = {\n            name: '',\n            type: 'tuple',\n            components: dataItems,\n        };\n    }\n    else {\n        dataItem = _.isString(input) ? signature_parser_1.generateDataItemFromSignature(input) : input;\n    }\n    return dataItem;\n}\n/**\n * Convenience function for creating a Method encoder from different inputs.\n * @param methodName name of method.\n * @param input A single data item; a set of data items; a signature; or an array of signatures (optional).\n * @param output A single data item; a set of data items; a signature; or an array of signatures (optional).\n * @return Method corresponding to input.\n */\nfunction createMethod(methodName, input, output) {\n    const methodInput = input === undefined ? [] : consolidateDataItemsIntoArray(input);\n    const methodOutput = output === undefined ? [] : consolidateDataItemsIntoArray(output);\n    const methodAbi = {\n        name: methodName,\n        inputs: methodInput,\n        outputs: methodOutput,\n        type: 'function',\n        // default fields not used by ABI\n        constant: false,\n        payable: false,\n        stateMutability: 'nonpayable',\n    };\n    const dataType = new Method(methodAbi);\n    return dataType;\n}\nexports.createMethod = createMethod;\n/**\n * Convenience function that aggregates a single input or a set of inputs into an array of DataItems.\n * @param input A single data item; a set of data items; a signature; or an array of signatures.\n * @return Array of data items corresponding to input.\n */\nfunction consolidateDataItemsIntoArray(input) {\n    let dataItems;\n    if (_.isArray(input) && _.isEmpty(input)) {\n        dataItems = [];\n    }\n    else if (_.isArray(input) && _.isString(input[0])) {\n        dataItems = [];\n        _.each(input, (signature) => {\n            const dataItem = signature_parser_1.generateDataItemFromSignature(signature);\n            dataItems.push(dataItem);\n        });\n    }\n    else if (_.isArray(input)) {\n        dataItems = input;\n    }\n    else if (typeof input === 'string') {\n        const dataItem = signature_parser_1.generateDataItemFromSignature(input);\n        dataItems = [dataItem];\n    }\n    else {\n        dataItems = [input];\n    }\n    return dataItems;\n}\n/* tslint:enable no-construct */\n//# sourceMappingURL=evm_data_type_factory.js.map"]},"metadata":{},"sourceType":"module"}