{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ethUtil = require(\"ethereumjs-util\");\n\nconst _ = require(\"lodash\");\n\nconst constants_1 = require(\"../utils/constants\");\n\nconst queue_1 = require(\"../utils/queue\");\n\nclass RawCalldata {\n  constructor(value, hasSelector = true) {\n    // Sanity check\n    if (typeof value === 'string' && !_.startsWith(value, '0x')) {\n      throw new Error(`Expected raw calldata to start with '0x'`);\n    } // Construct initial values\n\n\n    this._value = ethUtil.toBuffer(value);\n    this._selector = '0x';\n    this._scopes = new queue_1.Queue();\n\n    this._scopes.pushBack(RawCalldata._INITIAL_OFFSET);\n\n    this._offset = RawCalldata._INITIAL_OFFSET; // If there's a selector then slice it\n\n    if (hasSelector) {\n      const selectorBuf = this._value.slice(constants_1.constants.HEX_SELECTOR_LENGTH_IN_BYTES);\n\n      this._value = this._value.slice(constants_1.constants.HEX_SELECTOR_LENGTH_IN_BYTES);\n      this._selector = ethUtil.bufferToHex(selectorBuf);\n    }\n  }\n\n  popBytes(lengthInBytes) {\n    const popBegin = this._offset;\n    const popEnd = popBegin + lengthInBytes;\n\n    if (popEnd > this._value.byteLength) {\n      throw new Error(`Tried to decode beyond the end of calldata`);\n    }\n\n    const value = this._value.slice(popBegin, popEnd);\n\n    this.setOffset(popEnd);\n    return value;\n  }\n\n  popWord() {\n    const wordInBytes = 32;\n    return this.popBytes(wordInBytes);\n  }\n\n  popWords(length) {\n    const wordInBytes = 32;\n    return this.popBytes(length * wordInBytes);\n  }\n\n  readBytes(from, to) {\n    const value = this._value.slice(from, to);\n\n    return value;\n  }\n\n  setOffset(offsetInBytes) {\n    this._offset = offsetInBytes;\n  }\n\n  startScope() {\n    this._scopes.pushFront(this._offset);\n  }\n\n  endScope() {\n    this._scopes.popFront();\n  }\n\n  getOffset() {\n    return this._offset;\n  }\n\n  toAbsoluteOffset(relativeOffset) {\n    const scopeOffset = this._scopes.peekFront();\n\n    if (scopeOffset === undefined) {\n      throw new Error(`Tried to access undefined scope.`);\n    }\n\n    const absoluteOffset = relativeOffset + scopeOffset;\n    return absoluteOffset;\n  }\n\n  getSelector() {\n    return this._selector;\n  }\n\n  getSizeInBytes() {\n    const sizeInBytes = this._value.byteLength;\n    return sizeInBytes;\n  }\n\n}\n\nRawCalldata._INITIAL_OFFSET = 0;\nexports.RawCalldata = RawCalldata;","map":{"version":3,"sources":["../../../../src/abi_encoder/calldata/raw_calldata.ts"],"names":[],"mappings":";;;;;;AAAA,MAAA,OAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AACA,MAAA,CAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AAEA,MAAA,WAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AAEA,MAAa,WAAb,CAAwB;AAOpB,EAAA,WAAA,CAAmB,KAAnB,EAA2C,WAAA,GAAuB,IAAlE,EAAsE;AAClE;AACA,QAAI,OAAO,KAAP,KAAiB,QAAjB,IAA6B,CAAC,CAAC,CAAC,UAAF,CAAa,KAAb,EAAoB,IAApB,CAAlC,EAA6D;AACzD,YAAM,IAAI,KAAJ,CAAU,0CAAV,CAAN;AACH,KAJiE,CAKlE;;;AACA,SAAK,MAAL,GAAc,OAAO,CAAC,QAAR,CAAiB,KAAjB,CAAd;AACA,SAAK,SAAL,GAAiB,IAAjB;AACA,SAAK,OAAL,GAAe,IAAI,OAAA,CAAA,KAAJ,EAAf;;AACA,SAAK,OAAL,CAAa,QAAb,CAAsB,WAAW,CAAC,eAAlC;;AACA,SAAK,OAAL,GAAe,WAAW,CAAC,eAA3B,CAVkE,CAWlE;;AACA,QAAI,WAAJ,EAAiB;AACb,YAAM,WAAW,GAAG,KAAK,MAAL,CAAY,KAAZ,CAAkB,WAAA,CAAA,SAAA,CAAU,4BAA5B,CAApB;;AACA,WAAK,MAAL,GAAc,KAAK,MAAL,CAAY,KAAZ,CAAkB,WAAA,CAAA,SAAA,CAAU,4BAA5B,CAAd;AACA,WAAK,SAAL,GAAiB,OAAO,CAAC,WAAR,CAAoB,WAApB,CAAjB;AACH;AACJ;;AAEM,EAAA,QAAQ,CAAC,aAAD,EAAsB;AACjC,UAAM,QAAQ,GAAG,KAAK,OAAtB;AACA,UAAM,MAAM,GAAG,QAAQ,GAAG,aAA1B;;AACA,QAAI,MAAM,GAAG,KAAK,MAAL,CAAY,UAAzB,EAAqC;AACjC,YAAM,IAAI,KAAJ,CAAU,4CAAV,CAAN;AACH;;AACD,UAAM,KAAK,GAAG,KAAK,MAAL,CAAY,KAAZ,CAAkB,QAAlB,EAA4B,MAA5B,CAAd;;AACA,SAAK,SAAL,CAAe,MAAf;AACA,WAAO,KAAP;AACH;;AAEM,EAAA,OAAO,GAAA;AACV,UAAM,WAAW,GAAG,EAApB;AACA,WAAO,KAAK,QAAL,CAAc,WAAd,CAAP;AACH;;AAEM,EAAA,QAAQ,CAAC,MAAD,EAAe;AAC1B,UAAM,WAAW,GAAG,EAApB;AACA,WAAO,KAAK,QAAL,CAAc,MAAM,GAAG,WAAvB,CAAP;AACH;;AAEM,EAAA,SAAS,CAAC,IAAD,EAAe,EAAf,EAAyB;AACrC,UAAM,KAAK,GAAG,KAAK,MAAL,CAAY,KAAZ,CAAkB,IAAlB,EAAwB,EAAxB,CAAd;;AACA,WAAO,KAAP;AACH;;AAEM,EAAA,SAAS,CAAC,aAAD,EAAsB;AAClC,SAAK,OAAL,GAAe,aAAf;AACH;;AAEM,EAAA,UAAU,GAAA;AACb,SAAK,OAAL,CAAa,SAAb,CAAuB,KAAK,OAA5B;AACH;;AAEM,EAAA,QAAQ,GAAA;AACX,SAAK,OAAL,CAAa,QAAb;AACH;;AAEM,EAAA,SAAS,GAAA;AACZ,WAAO,KAAK,OAAZ;AACH;;AAEM,EAAA,gBAAgB,CAAC,cAAD,EAAuB;AAC1C,UAAM,WAAW,GAAG,KAAK,OAAL,CAAa,SAAb,EAApB;;AACA,QAAI,WAAW,KAAK,SAApB,EAA+B;AAC3B,YAAM,IAAI,KAAJ,CAAU,kCAAV,CAAN;AACH;;AACD,UAAM,cAAc,GAAG,cAAc,GAAG,WAAxC;AACA,WAAO,cAAP;AACH;;AAEM,EAAA,WAAW,GAAA;AACd,WAAO,KAAK,SAAZ;AACH;;AAEM,EAAA,cAAc,GAAA;AACjB,UAAM,WAAW,GAAG,KAAK,MAAL,CAAY,UAAhC;AACA,WAAO,WAAP;AACH;;AApFmB;;AACI,WAAA,CAAA,eAAA,GAAkB,CAAlB;AAD5B,OAAA,CAAA,WAAA,GAAA,WAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ethUtil = require(\"ethereumjs-util\");\nconst _ = require(\"lodash\");\nconst constants_1 = require(\"../utils/constants\");\nconst queue_1 = require(\"../utils/queue\");\nclass RawCalldata {\n    constructor(value, hasSelector = true) {\n        // Sanity check\n        if (typeof value === 'string' && !_.startsWith(value, '0x')) {\n            throw new Error(`Expected raw calldata to start with '0x'`);\n        }\n        // Construct initial values\n        this._value = ethUtil.toBuffer(value);\n        this._selector = '0x';\n        this._scopes = new queue_1.Queue();\n        this._scopes.pushBack(RawCalldata._INITIAL_OFFSET);\n        this._offset = RawCalldata._INITIAL_OFFSET;\n        // If there's a selector then slice it\n        if (hasSelector) {\n            const selectorBuf = this._value.slice(constants_1.constants.HEX_SELECTOR_LENGTH_IN_BYTES);\n            this._value = this._value.slice(constants_1.constants.HEX_SELECTOR_LENGTH_IN_BYTES);\n            this._selector = ethUtil.bufferToHex(selectorBuf);\n        }\n    }\n    popBytes(lengthInBytes) {\n        const popBegin = this._offset;\n        const popEnd = popBegin + lengthInBytes;\n        if (popEnd > this._value.byteLength) {\n            throw new Error(`Tried to decode beyond the end of calldata`);\n        }\n        const value = this._value.slice(popBegin, popEnd);\n        this.setOffset(popEnd);\n        return value;\n    }\n    popWord() {\n        const wordInBytes = 32;\n        return this.popBytes(wordInBytes);\n    }\n    popWords(length) {\n        const wordInBytes = 32;\n        return this.popBytes(length * wordInBytes);\n    }\n    readBytes(from, to) {\n        const value = this._value.slice(from, to);\n        return value;\n    }\n    setOffset(offsetInBytes) {\n        this._offset = offsetInBytes;\n    }\n    startScope() {\n        this._scopes.pushFront(this._offset);\n    }\n    endScope() {\n        this._scopes.popFront();\n    }\n    getOffset() {\n        return this._offset;\n    }\n    toAbsoluteOffset(relativeOffset) {\n        const scopeOffset = this._scopes.peekFront();\n        if (scopeOffset === undefined) {\n            throw new Error(`Tried to access undefined scope.`);\n        }\n        const absoluteOffset = relativeOffset + scopeOffset;\n        return absoluteOffset;\n    }\n    getSelector() {\n        return this._selector;\n    }\n    getSizeInBytes() {\n        const sizeInBytes = this._value.byteLength;\n        return sizeInBytes;\n    }\n}\nRawCalldata._INITIAL_OFFSET = 0;\nexports.RawCalldata = RawCalldata;\n//# sourceMappingURL=raw_calldata.js.map"]},"metadata":{},"sourceType":"module"}