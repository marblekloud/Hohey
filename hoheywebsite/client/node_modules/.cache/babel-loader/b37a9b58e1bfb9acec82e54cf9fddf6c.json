{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst _ = require(\"lodash\");\n\nconst set_1 = require(\"../abstract_data_types/types/set\");\n\nconst constants_1 = require(\"../utils/constants\");\n\nclass ArrayDataType extends set_1.AbstractSetDataType {\n  constructor(dataItem, dataTypeFactory) {\n    // Construct parent\n    const isArray = true;\n\n    const [arrayElementType, arrayLength] = ArrayDataType._decodeElementTypeAndLengthFromType(dataItem.type);\n\n    super(dataItem, dataTypeFactory, isArray, arrayLength, arrayElementType); // Set array properties\n\n    this._elementType = arrayElementType;\n  }\n\n  static matchType(type) {\n    return ArrayDataType._MATCHER.test(type);\n  }\n\n  static _decodeElementTypeAndLengthFromType(type) {\n    const matches = ArrayDataType._MATCHER.exec(type);\n\n    if (matches === null || matches.length !== 3) {\n      throw new Error(`Could not parse array: ${type}`);\n    } else if (matches[1] === undefined) {\n      throw new Error(`Could not parse array type: ${type}`);\n    } else if (matches[2] === undefined) {\n      throw new Error(`Could not parse array length: ${type}`);\n    }\n\n    const arrayElementType = matches[1];\n    const arrayLength = _.isEmpty(matches[2]) ? undefined : parseInt(matches[2], constants_1.constants.DEC_BASE);\n    return [arrayElementType, arrayLength];\n  }\n\n  getSignatureType() {\n    return this._computeSignature(false);\n  }\n\n  getSignature(isDetailed) {\n    if (_.isEmpty(this.getDataItem().name) || !isDetailed) {\n      return this.getSignatureType();\n    }\n\n    const name = this.getDataItem().name;\n    const lastIndexOfScopeDelimiter = name.lastIndexOf('.');\n    const isScopedName = lastIndexOfScopeDelimiter !== undefined && lastIndexOfScopeDelimiter > 0;\n    const shortName = isScopedName ? name.substr(lastIndexOfScopeDelimiter + 1) : name;\n    const detailedSignature = `${shortName} ${this._computeSignature(isDetailed)}`;\n    return detailedSignature;\n  }\n\n  _computeSignature(isDetailed) {\n    // Compute signature for a single array element\n    const elementDataItem = {\n      type: this._elementType,\n      name: ''\n    };\n    const elementComponents = this.getDataItem().components;\n\n    if (elementComponents !== undefined) {\n      elementDataItem.components = elementComponents;\n    }\n\n    const elementDataType = this.getFactory().create(elementDataItem);\n    const elementSignature = elementDataType.getSignature(isDetailed); // Construct signature for array of type `element`\n\n    if (this._arrayLength === undefined) {\n      return `${elementSignature}[]`;\n    } else {\n      return `${elementSignature}[${this._arrayLength}]`;\n    }\n  }\n\n}\n\nArrayDataType._MATCHER = RegExp('^(.+)\\\\[([0-9]*)\\\\]$');\nexports.ArrayDataType = ArrayDataType;","map":{"version":3,"sources":["../../../../src/abi_encoder/evm_data_types/array.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst _ = require(\"lodash\");\nconst set_1 = require(\"../abstract_data_types/types/set\");\nconst constants_1 = require(\"../utils/constants\");\nclass ArrayDataType extends set_1.AbstractSetDataType {\n    constructor(dataItem, dataTypeFactory) {\n        // Construct parent\n        const isArray = true;\n        const [arrayElementType, arrayLength] = ArrayDataType._decodeElementTypeAndLengthFromType(dataItem.type);\n        super(dataItem, dataTypeFactory, isArray, arrayLength, arrayElementType);\n        // Set array properties\n        this._elementType = arrayElementType;\n    }\n    static matchType(type) {\n        return ArrayDataType._MATCHER.test(type);\n    }\n    static _decodeElementTypeAndLengthFromType(type) {\n        const matches = ArrayDataType._MATCHER.exec(type);\n        if (matches === null || matches.length !== 3) {\n            throw new Error(`Could not parse array: ${type}`);\n        }\n        else if (matches[1] === undefined) {\n            throw new Error(`Could not parse array type: ${type}`);\n        }\n        else if (matches[2] === undefined) {\n            throw new Error(`Could not parse array length: ${type}`);\n        }\n        const arrayElementType = matches[1];\n        const arrayLength = _.isEmpty(matches[2]) ? undefined : parseInt(matches[2], constants_1.constants.DEC_BASE);\n        return [arrayElementType, arrayLength];\n    }\n    getSignatureType() {\n        return this._computeSignature(false);\n    }\n    getSignature(isDetailed) {\n        if (_.isEmpty(this.getDataItem().name) || !isDetailed) {\n            return this.getSignatureType();\n        }\n        const name = this.getDataItem().name;\n        const lastIndexOfScopeDelimiter = name.lastIndexOf('.');\n        const isScopedName = lastIndexOfScopeDelimiter !== undefined && lastIndexOfScopeDelimiter > 0;\n        const shortName = isScopedName ? name.substr(lastIndexOfScopeDelimiter + 1) : name;\n        const detailedSignature = `${shortName} ${this._computeSignature(isDetailed)}`;\n        return detailedSignature;\n    }\n    _computeSignature(isDetailed) {\n        // Compute signature for a single array element\n        const elementDataItem = {\n            type: this._elementType,\n            name: '',\n        };\n        const elementComponents = this.getDataItem().components;\n        if (elementComponents !== undefined) {\n            elementDataItem.components = elementComponents;\n        }\n        const elementDataType = this.getFactory().create(elementDataItem);\n        const elementSignature = elementDataType.getSignature(isDetailed);\n        // Construct signature for array of type `element`\n        if (this._arrayLength === undefined) {\n            return `${elementSignature}[]`;\n        }\n        else {\n            return `${elementSignature}[${this._arrayLength}]`;\n        }\n    }\n}\nArrayDataType._MATCHER = RegExp('^(.+)\\\\[([0-9]*)\\\\]$');\nexports.ArrayDataType = ArrayDataType;\n//# sourceMappingURL=array.js.map"]},"metadata":{},"sourceType":"module"}