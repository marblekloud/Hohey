{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst _ = require(\"lodash\");\n\nfunction parseNode(node) {\n  const components = [];\n\n  _.each(node.children, child => {\n    const component = parseNode(child);\n    components.push(component);\n  });\n\n  const dataItem = {\n    name: node.name,\n    type: node.value\n  };\n\n  if (!_.isEmpty(components)) {\n    dataItem.components = components;\n  }\n\n  return dataItem;\n}\n/**\n * Returns a DataItem corresponding to the input signature.\n * A signature can be in two forms: `type` or `(type_1,type_2,...,type_n)`\n * An example of the first form would be 'address' or 'uint256[]' or 'bytes[5][]'\n * An example of the second form would be '(address,uint256)' or '(address,uint256)[]'\n * @param signature of input DataItem.\n * @return DataItem derived from input signature.\n */\n\n\nfunction generateDataItemFromSignature(signature) {\n  // No data item corresponds to an empty signature\n  if (_.isEmpty(signature)) {\n    throw new Error(`Cannot parse data item from empty signature, ''`);\n  } // Create a parse tree for data item\n\n\n  let node = {\n    name: '',\n    value: '',\n    children: []\n  };\n\n  for (const char of signature) {\n    switch (char) {\n      case '(':\n        const child = {\n          name: '',\n          value: '',\n          children: [],\n          parent: node\n        };\n        node.value = 'tuple';\n        node.children.push(child);\n        node = child;\n        break;\n\n      case ')':\n        node = node.parent;\n        break;\n\n      case ',':\n        const sibling = {\n          name: '',\n          value: '',\n          children: [],\n          parent: node.parent\n        };\n        node.parent.children.push(sibling);\n        node = sibling;\n        break;\n\n      case ' ':\n        node.name = node.value;\n        node.value = '';\n        break;\n\n      default:\n        node.value += char;\n        break;\n    }\n  } // Interpret data item from parse tree\n\n\n  const dataItem = parseNode(node);\n  return dataItem;\n}\n\nexports.generateDataItemFromSignature = generateDataItemFromSignature;","map":{"version":3,"sources":["../../../../src/abi_encoder/utils/signature_parser.ts"],"names":[],"mappings":";;;;;;AACA,MAAA,CAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AASA,SAAS,SAAT,CAAmB,IAAnB,EAA6B;AACzB,QAAM,UAAU,GAAe,EAA/B;;AACA,EAAA,CAAC,CAAC,IAAF,CAAO,IAAI,CAAC,QAAZ,EAAuB,KAAD,IAAgB;AAClC,UAAM,SAAS,GAAG,SAAS,CAAC,KAAD,CAA3B;AACA,IAAA,UAAU,CAAC,IAAX,CAAgB,SAAhB;AACH,GAHD;;AAIA,QAAM,QAAQ,GAAa;AACvB,IAAA,IAAI,EAAE,IAAI,CAAC,IADY;AAEvB,IAAA,IAAI,EAAE,IAAI,CAAC;AAFY,GAA3B;;AAIA,MAAI,CAAC,CAAC,CAAC,OAAF,CAAU,UAAV,CAAL,EAA4B;AACxB,IAAA,QAAQ,CAAC,UAAT,GAAsB,UAAtB;AACH;;AACD,SAAO,QAAP;AACH;AAED;;;;;;;AAOG;;;AACH,SAAgB,6BAAhB,CAA8C,SAA9C,EAA+D;AAC3D;AACA,MAAI,CAAC,CAAC,OAAF,CAAU,SAAV,CAAJ,EAA0B;AACtB,UAAM,IAAI,KAAJ,CAAU,iDAAV,CAAN;AACH,GAJ0D,CAK3D;;;AACA,MAAI,IAAI,GAAS;AACb,IAAA,IAAI,EAAE,EADO;AAEb,IAAA,KAAK,EAAE,EAFM;AAGb,IAAA,QAAQ,EAAE;AAHG,GAAjB;;AAKA,OAAK,MAAM,IAAX,IAAmB,SAAnB,EAA8B;AAC1B,YAAQ,IAAR;AACI,WAAK,GAAL;AACI,cAAM,KAAK,GAAG;AACV,UAAA,IAAI,EAAE,EADI;AAEV,UAAA,KAAK,EAAE,EAFG;AAGV,UAAA,QAAQ,EAAE,EAHA;AAIV,UAAA,MAAM,EAAE;AAJE,SAAd;AAMA,QAAA,IAAI,CAAC,KAAL,GAAa,OAAb;AACA,QAAA,IAAI,CAAC,QAAL,CAAc,IAAd,CAAmB,KAAnB;AACA,QAAA,IAAI,GAAG,KAAP;AACA;;AAEJ,WAAK,GAAL;AACI,QAAA,IAAI,GAAG,IAAI,CAAC,MAAZ;AACA;;AAEJ,WAAK,GAAL;AACI,cAAM,OAAO,GAAG;AACZ,UAAA,IAAI,EAAE,EADM;AAEZ,UAAA,KAAK,EAAE,EAFK;AAGZ,UAAA,QAAQ,EAAE,EAHE;AAIZ,UAAA,MAAM,EAAE,IAAI,CAAC;AAJD,SAAhB;AAMC,QAAA,IAAI,CAAC,MAAL,CAAqB,QAArB,CAA8B,IAA9B,CAAmC,OAAnC;AACD,QAAA,IAAI,GAAG,OAAP;AACA;;AAEJ,WAAK,GAAL;AACI,QAAA,IAAI,CAAC,IAAL,GAAY,IAAI,CAAC,KAAjB;AACA,QAAA,IAAI,CAAC,KAAL,GAAa,EAAb;AACA;;AAEJ;AACI,QAAA,IAAI,CAAC,KAAL,IAAc,IAAd;AACA;AAnCR;AAqCH,GAjD0D,CAkD3D;;;AACA,QAAM,QAAQ,GAAG,SAAS,CAAC,IAAD,CAA1B;AACA,SAAO,QAAP;AACH;;AArDD,OAAA,CAAA,6BAAA,GAAA,6BAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst _ = require(\"lodash\");\nfunction parseNode(node) {\n    const components = [];\n    _.each(node.children, (child) => {\n        const component = parseNode(child);\n        components.push(component);\n    });\n    const dataItem = {\n        name: node.name,\n        type: node.value,\n    };\n    if (!_.isEmpty(components)) {\n        dataItem.components = components;\n    }\n    return dataItem;\n}\n/**\n * Returns a DataItem corresponding to the input signature.\n * A signature can be in two forms: `type` or `(type_1,type_2,...,type_n)`\n * An example of the first form would be 'address' or 'uint256[]' or 'bytes[5][]'\n * An example of the second form would be '(address,uint256)' or '(address,uint256)[]'\n * @param signature of input DataItem.\n * @return DataItem derived from input signature.\n */\nfunction generateDataItemFromSignature(signature) {\n    // No data item corresponds to an empty signature\n    if (_.isEmpty(signature)) {\n        throw new Error(`Cannot parse data item from empty signature, ''`);\n    }\n    // Create a parse tree for data item\n    let node = {\n        name: '',\n        value: '',\n        children: [],\n    };\n    for (const char of signature) {\n        switch (char) {\n            case '(':\n                const child = {\n                    name: '',\n                    value: '',\n                    children: [],\n                    parent: node,\n                };\n                node.value = 'tuple';\n                node.children.push(child);\n                node = child;\n                break;\n            case ')':\n                node = node.parent;\n                break;\n            case ',':\n                const sibling = {\n                    name: '',\n                    value: '',\n                    children: [],\n                    parent: node.parent,\n                };\n                node.parent.children.push(sibling);\n                node = sibling;\n                break;\n            case ' ':\n                node.name = node.value;\n                node.value = '';\n                break;\n            default:\n                node.value += char;\n                break;\n        }\n    }\n    // Interpret data item from parse tree\n    const dataItem = parseNode(node);\n    return dataItem;\n}\nexports.generateDataItemFromSignature = generateDataItemFromSignature;\n//# sourceMappingURL=signature_parser.js.map"]},"metadata":{},"sourceType":"module"}