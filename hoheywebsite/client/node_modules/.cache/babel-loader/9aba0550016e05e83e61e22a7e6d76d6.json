{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ethUtil = require(\"ethereumjs-util\");\n\nconst _ = require(\"lodash\");\n\nconst configured_bignumber_1 = require(\"../../configured_bignumber\");\n\nconst constants_1 = require(\"../utils/constants\");\n\nfunction sanityCheckBigNumberRange(value_, minValue, maxValue) {\n  const value = new configured_bignumber_1.BigNumber(value_, 10);\n\n  if (value.isGreaterThan(maxValue)) {\n    throw new Error(`Tried to assign value of ${value}, which exceeds max value of ${maxValue}`);\n  } else if (value.isLessThan(minValue)) {\n    throw new Error(`Tried to assign value of ${value}, which exceeds min value of ${minValue}`);\n  } else if (value.isNaN()) {\n    throw new Error(`Tried to assign NaN value`);\n  }\n}\n\nfunction bigNumberToPaddedBuffer(value) {\n  const valueHex = `0x${value.toString(constants_1.constants.HEX_BASE)}`;\n  const valueBuf = ethUtil.toBuffer(valueHex);\n  const valueBufPadded = ethUtil.setLengthLeft(valueBuf, constants_1.constants.EVM_WORD_WIDTH_IN_BYTES);\n  return valueBufPadded;\n}\n/**\n * Takes a numeric value and returns its ABI-encoded value\n * @param value_    The value to encode.\n * @return ABI Encoded value\n */\n\n\nfunction encodeNumericValue(value_) {\n  const value = new configured_bignumber_1.BigNumber(value_, 10); // Case 1/2: value is non-negative\n\n  if (value.isGreaterThanOrEqualTo(0)) {\n    const encodedPositiveValue = bigNumberToPaddedBuffer(value);\n    return encodedPositiveValue;\n  } // Case 2/2: Value is negative\n  // Use two's-complement to encode the value\n  // Step 1/3: Convert negative value to positive binary string\n\n\n  const valueBin = value.times(-1).toString(constants_1.constants.BIN_BASE); // Step 2/3: Invert binary value\n\n  let invertedValueBin = '1'.repeat(constants_1.constants.EVM_WORD_WIDTH_IN_BITS - valueBin.length);\n\n  _.each(valueBin, bit => {\n    invertedValueBin += bit === '1' ? '0' : '1';\n  });\n\n  const invertedValue = new configured_bignumber_1.BigNumber(invertedValueBin, constants_1.constants.BIN_BASE); // Step 3/3: Add 1 to inverted value\n\n  const negativeValue = invertedValue.plus(1);\n  const encodedValue = bigNumberToPaddedBuffer(negativeValue);\n  return encodedValue;\n}\n\nexports.encodeNumericValue = encodeNumericValue;\n/**\n * Takes a numeric value and returns its ABI-encoded value.\n * Performs an additional sanity check, given the min/max allowed value.\n * @param value_    The value to encode.\n * @return ABI Encoded value\n */\n\nfunction safeEncodeNumericValue(value, minValue, maxValue) {\n  sanityCheckBigNumberRange(value, minValue, maxValue);\n  const encodedValue = encodeNumericValue(value);\n  return encodedValue;\n}\n\nexports.safeEncodeNumericValue = safeEncodeNumericValue;\n/**\n * Takes an ABI-encoded numeric value and returns its decoded value as a BigNumber.\n * @param encodedValue    The encoded numeric value.\n * @param minValue        The minimum possible decoded value.\n * @return ABI Decoded value\n */\n\nfunction decodeNumericValue(encodedValue, minValue) {\n  const valueHex = ethUtil.bufferToHex(encodedValue); // Case 1/3: value is definitely non-negative because of numeric boundaries\n\n  const value = new configured_bignumber_1.BigNumber(valueHex, constants_1.constants.HEX_BASE);\n\n  if (!minValue.isLessThan(0)) {\n    return value;\n  } // Case 2/3: value is non-negative because there is no leading 1 (encoded as two's-complement)\n\n\n  const valueBin = value.toString(constants_1.constants.BIN_BASE);\n\n  const isValueNegative = valueBin.length === constants_1.constants.EVM_WORD_WIDTH_IN_BITS && _.startsWith(valueBin[0], '1');\n\n  if (!isValueNegative) {\n    return value;\n  } // Case 3/3: value is negative\n  // Step 1/3: Invert b inary value\n\n\n  let invertedValueBin = '';\n\n  _.each(valueBin, bit => {\n    invertedValueBin += bit === '1' ? '0' : '1';\n  });\n\n  const invertedValue = new configured_bignumber_1.BigNumber(invertedValueBin, constants_1.constants.BIN_BASE); // Step 2/3: Add 1 to inverted value\n  // The result is the two's-complement representation of the input value.\n\n  const positiveValue = invertedValue.plus(1); // Step 3/3: Invert positive value to get the negative value\n\n  const negativeValue = positiveValue.times(-1);\n  return negativeValue;\n}\n\nexports.decodeNumericValue = decodeNumericValue;\n/**\n * Takes an ABI-encoded numeric value and returns its decoded value as a BigNumber.\n * Performs an additional sanity check, given the min/max allowed value.\n * @param encodedValue    The encoded numeric value.\n * @param minValue        The minimum possible decoded value.\n * @return ABI Decoded value\n */\n\nfunction safeDecodeNumericValue(encodedValue, minValue, maxValue) {\n  const value = decodeNumericValue(encodedValue, minValue);\n  sanityCheckBigNumberRange(value, minValue, maxValue);\n  return value;\n}\n\nexports.safeDecodeNumericValue = safeDecodeNumericValue;","map":{"version":3,"sources":["../../../../src/abi_encoder/utils/math.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ethUtil = require(\"ethereumjs-util\");\nconst _ = require(\"lodash\");\nconst configured_bignumber_1 = require(\"../../configured_bignumber\");\nconst constants_1 = require(\"../utils/constants\");\nfunction sanityCheckBigNumberRange(value_, minValue, maxValue) {\n    const value = new configured_bignumber_1.BigNumber(value_, 10);\n    if (value.isGreaterThan(maxValue)) {\n        throw new Error(`Tried to assign value of ${value}, which exceeds max value of ${maxValue}`);\n    }\n    else if (value.isLessThan(minValue)) {\n        throw new Error(`Tried to assign value of ${value}, which exceeds min value of ${minValue}`);\n    }\n    else if (value.isNaN()) {\n        throw new Error(`Tried to assign NaN value`);\n    }\n}\nfunction bigNumberToPaddedBuffer(value) {\n    const valueHex = `0x${value.toString(constants_1.constants.HEX_BASE)}`;\n    const valueBuf = ethUtil.toBuffer(valueHex);\n    const valueBufPadded = ethUtil.setLengthLeft(valueBuf, constants_1.constants.EVM_WORD_WIDTH_IN_BYTES);\n    return valueBufPadded;\n}\n/**\n * Takes a numeric value and returns its ABI-encoded value\n * @param value_    The value to encode.\n * @return ABI Encoded value\n */\nfunction encodeNumericValue(value_) {\n    const value = new configured_bignumber_1.BigNumber(value_, 10);\n    // Case 1/2: value is non-negative\n    if (value.isGreaterThanOrEqualTo(0)) {\n        const encodedPositiveValue = bigNumberToPaddedBuffer(value);\n        return encodedPositiveValue;\n    }\n    // Case 2/2: Value is negative\n    // Use two's-complement to encode the value\n    // Step 1/3: Convert negative value to positive binary string\n    const valueBin = value.times(-1).toString(constants_1.constants.BIN_BASE);\n    // Step 2/3: Invert binary value\n    let invertedValueBin = '1'.repeat(constants_1.constants.EVM_WORD_WIDTH_IN_BITS - valueBin.length);\n    _.each(valueBin, (bit) => {\n        invertedValueBin += bit === '1' ? '0' : '1';\n    });\n    const invertedValue = new configured_bignumber_1.BigNumber(invertedValueBin, constants_1.constants.BIN_BASE);\n    // Step 3/3: Add 1 to inverted value\n    const negativeValue = invertedValue.plus(1);\n    const encodedValue = bigNumberToPaddedBuffer(negativeValue);\n    return encodedValue;\n}\nexports.encodeNumericValue = encodeNumericValue;\n/**\n * Takes a numeric value and returns its ABI-encoded value.\n * Performs an additional sanity check, given the min/max allowed value.\n * @param value_    The value to encode.\n * @return ABI Encoded value\n */\nfunction safeEncodeNumericValue(value, minValue, maxValue) {\n    sanityCheckBigNumberRange(value, minValue, maxValue);\n    const encodedValue = encodeNumericValue(value);\n    return encodedValue;\n}\nexports.safeEncodeNumericValue = safeEncodeNumericValue;\n/**\n * Takes an ABI-encoded numeric value and returns its decoded value as a BigNumber.\n * @param encodedValue    The encoded numeric value.\n * @param minValue        The minimum possible decoded value.\n * @return ABI Decoded value\n */\nfunction decodeNumericValue(encodedValue, minValue) {\n    const valueHex = ethUtil.bufferToHex(encodedValue);\n    // Case 1/3: value is definitely non-negative because of numeric boundaries\n    const value = new configured_bignumber_1.BigNumber(valueHex, constants_1.constants.HEX_BASE);\n    if (!minValue.isLessThan(0)) {\n        return value;\n    }\n    // Case 2/3: value is non-negative because there is no leading 1 (encoded as two's-complement)\n    const valueBin = value.toString(constants_1.constants.BIN_BASE);\n    const isValueNegative = valueBin.length === constants_1.constants.EVM_WORD_WIDTH_IN_BITS && _.startsWith(valueBin[0], '1');\n    if (!isValueNegative) {\n        return value;\n    }\n    // Case 3/3: value is negative\n    // Step 1/3: Invert b inary value\n    let invertedValueBin = '';\n    _.each(valueBin, (bit) => {\n        invertedValueBin += bit === '1' ? '0' : '1';\n    });\n    const invertedValue = new configured_bignumber_1.BigNumber(invertedValueBin, constants_1.constants.BIN_BASE);\n    // Step 2/3: Add 1 to inverted value\n    // The result is the two's-complement representation of the input value.\n    const positiveValue = invertedValue.plus(1);\n    // Step 3/3: Invert positive value to get the negative value\n    const negativeValue = positiveValue.times(-1);\n    return negativeValue;\n}\nexports.decodeNumericValue = decodeNumericValue;\n/**\n * Takes an ABI-encoded numeric value and returns its decoded value as a BigNumber.\n * Performs an additional sanity check, given the min/max allowed value.\n * @param encodedValue    The encoded numeric value.\n * @param minValue        The minimum possible decoded value.\n * @return ABI Decoded value\n */\nfunction safeDecodeNumericValue(encodedValue, minValue, maxValue) {\n    const value = decodeNumericValue(encodedValue, minValue);\n    sanityCheckBigNumberRange(value, minValue, maxValue);\n    return value;\n}\nexports.safeDecodeNumericValue = safeDecodeNumericValue;\n//# sourceMappingURL=math.js.map"]},"metadata":{},"sourceType":"module"}