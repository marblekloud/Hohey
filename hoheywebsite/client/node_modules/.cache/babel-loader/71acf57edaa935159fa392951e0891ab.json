{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ethUtil = require(\"ethereumjs-util\");\n\nconst pointer_1 = require(\"../../calldata/blocks/pointer\");\n\nconst constants_1 = require(\"../../utils/constants\");\n\nconst data_type_1 = require(\"../data_type\");\n\nclass AbstractPointerDataType extends data_type_1.DataType {\n  constructor(dataItem, factory, destination, parent) {\n    super(dataItem, factory);\n    this._destination = destination;\n    this._parent = parent;\n  }\n\n  generateCalldataBlock(value, parentBlock) {\n    if (parentBlock === undefined) {\n      throw new Error(`DependentDataType requires a parent block to generate its block`);\n    }\n\n    const destinationBlock = this._destination.generateCalldataBlock(value, parentBlock);\n\n    const name = this.getDataItem().name;\n    const signature = this.getSignature();\n    const parentName = parentBlock.getName();\n    const block = new pointer_1.PointerCalldataBlock(name, signature, parentName, destinationBlock, parentBlock);\n    return block;\n  }\n\n  generateValue(calldata, rules) {\n    const destinationOffsetBuf = calldata.popWord();\n    const destinationOffsetHex = ethUtil.bufferToHex(destinationOffsetBuf);\n    const destinationOffsetRelative = parseInt(destinationOffsetHex, constants_1.constants.HEX_BASE);\n    const destinationOffsetAbsolute = calldata.toAbsoluteOffset(destinationOffsetRelative);\n    const currentOffset = calldata.getOffset();\n    calldata.setOffset(destinationOffsetAbsolute);\n\n    const value = this._destination.generateValue(calldata, rules);\n\n    calldata.setOffset(currentOffset);\n    return value;\n  } // Disable prefer-function-over-method for inherited abstract method.\n\n  /* tslint:disable prefer-function-over-method */\n\n\n  isStatic() {\n    return true;\n  }\n\n}\n\nexports.AbstractPointerDataType = AbstractPointerDataType;","map":{"version":3,"sources":["../../../../../src/abi_encoder/abstract_data_types/types/pointer.ts"],"names":[],"mappings":";;;;;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AAGA,MAAA,SAAA,GAAA,OAAA,CAAA,+BAAA,CAAA;;AAGA,MAAA,WAAA,GAAA,OAAA,CAAA,uBAAA,CAAA;;AAGA,MAAA,WAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;AAGA,MAAsB,uBAAtB,SAAsD,WAAA,CAAA,QAAtD,CAA8D;AAI1D,EAAA,WAAA,CAAmB,QAAnB,EAAuC,OAAvC,EAAiE,WAAjE,EAAwF,MAAxF,EAAwG;AACpG,UAAM,QAAN,EAAgB,OAAhB;AACA,SAAK,YAAL,GAAoB,WAApB;AACA,SAAK,OAAL,GAAe,MAAf;AACH;;AAEM,EAAA,qBAAqB,CAAC,KAAD,EAAa,WAAb,EAAwC;AAChE,QAAI,WAAW,KAAK,SAApB,EAA+B;AAC3B,YAAM,IAAI,KAAJ,CAAU,iEAAV,CAAN;AACH;;AACD,UAAM,gBAAgB,GAAG,KAAK,YAAL,CAAkB,qBAAlB,CAAwC,KAAxC,EAA+C,WAA/C,CAAzB;;AACA,UAAM,IAAI,GAAG,KAAK,WAAL,GAAmB,IAAhC;AACA,UAAM,SAAS,GAAG,KAAK,YAAL,EAAlB;AACA,UAAM,UAAU,GAAG,WAAW,CAAC,OAAZ,EAAnB;AACA,UAAM,KAAK,GAAG,IAAI,SAAA,CAAA,oBAAJ,CAAyB,IAAzB,EAA+B,SAA/B,EAA0C,UAA1C,EAAsD,gBAAtD,EAAwE,WAAxE,CAAd;AACA,WAAO,KAAP;AACH;;AAEM,EAAA,aAAa,CAAC,QAAD,EAAwB,KAAxB,EAA4C;AAC5D,UAAM,oBAAoB,GAAG,QAAQ,CAAC,OAAT,EAA7B;AACA,UAAM,oBAAoB,GAAG,OAAO,CAAC,WAAR,CAAoB,oBAApB,CAA7B;AACA,UAAM,yBAAyB,GAAG,QAAQ,CAAC,oBAAD,EAAuB,WAAA,CAAA,SAAA,CAAU,QAAjC,CAA1C;AACA,UAAM,yBAAyB,GAAG,QAAQ,CAAC,gBAAT,CAA0B,yBAA1B,CAAlC;AACA,UAAM,aAAa,GAAG,QAAQ,CAAC,SAAT,EAAtB;AACA,IAAA,QAAQ,CAAC,SAAT,CAAmB,yBAAnB;;AACA,UAAM,KAAK,GAAG,KAAK,YAAL,CAAkB,aAAlB,CAAgC,QAAhC,EAA0C,KAA1C,CAAd;;AACA,IAAA,QAAQ,CAAC,SAAT,CAAmB,aAAnB;AACA,WAAO,KAAP;AACH,GAhCyD,CAkC1D;;AACA;;;AACO,EAAA,QAAQ,GAAA;AACX,WAAO,IAAP;AACH;;AAtCyD;;AAA9D,OAAA,CAAA,uBAAA,GAAA,uBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ethUtil = require(\"ethereumjs-util\");\nconst pointer_1 = require(\"../../calldata/blocks/pointer\");\nconst constants_1 = require(\"../../utils/constants\");\nconst data_type_1 = require(\"../data_type\");\nclass AbstractPointerDataType extends data_type_1.DataType {\n    constructor(dataItem, factory, destination, parent) {\n        super(dataItem, factory);\n        this._destination = destination;\n        this._parent = parent;\n    }\n    generateCalldataBlock(value, parentBlock) {\n        if (parentBlock === undefined) {\n            throw new Error(`DependentDataType requires a parent block to generate its block`);\n        }\n        const destinationBlock = this._destination.generateCalldataBlock(value, parentBlock);\n        const name = this.getDataItem().name;\n        const signature = this.getSignature();\n        const parentName = parentBlock.getName();\n        const block = new pointer_1.PointerCalldataBlock(name, signature, parentName, destinationBlock, parentBlock);\n        return block;\n    }\n    generateValue(calldata, rules) {\n        const destinationOffsetBuf = calldata.popWord();\n        const destinationOffsetHex = ethUtil.bufferToHex(destinationOffsetBuf);\n        const destinationOffsetRelative = parseInt(destinationOffsetHex, constants_1.constants.HEX_BASE);\n        const destinationOffsetAbsolute = calldata.toAbsoluteOffset(destinationOffsetRelative);\n        const currentOffset = calldata.getOffset();\n        calldata.setOffset(destinationOffsetAbsolute);\n        const value = this._destination.generateValue(calldata, rules);\n        calldata.setOffset(currentOffset);\n        return value;\n    }\n    // Disable prefer-function-over-method for inherited abstract method.\n    /* tslint:disable prefer-function-over-method */\n    isStatic() {\n        return true;\n    }\n}\nexports.AbstractPointerDataType = AbstractPointerDataType;\n//# sourceMappingURL=pointer.js.map"]},"metadata":{},"sourceType":"module"}