{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ethereum_types_1 = require(\"ethereum-types\");\n\nconst _ = require(\"lodash\");\n\nconst set_1 = require(\"../abstract_data_types/types/set\");\n\nclass TupleDataType extends set_1.AbstractSetDataType {\n  static matchType(type) {\n    return type === ethereum_types_1.SolidityTypes.Tuple;\n  }\n\n  constructor(dataItem, dataTypeFactory) {\n    super(dataItem, dataTypeFactory);\n\n    if (!TupleDataType.matchType(dataItem.type)) {\n      throw new Error(`Tried to instantiate Tuple with bad input: ${dataItem}`);\n    }\n  }\n\n  getSignatureType() {\n    return this._computeSignatureOfMembers(false);\n  }\n\n  getSignature(isDetailed) {\n    if (_.isEmpty(this.getDataItem().name) || !isDetailed) {\n      return this.getSignatureType();\n    }\n\n    const name = this.getDataItem().name;\n    const lastIndexOfScopeDelimiter = name.lastIndexOf('.');\n    const isScopedName = lastIndexOfScopeDelimiter !== undefined && lastIndexOfScopeDelimiter > 0;\n    const shortName = isScopedName ? name.substr(lastIndexOfScopeDelimiter + 1) : name;\n    const detailedSignature = `${shortName} ${this._computeSignatureOfMembers(isDetailed)}`;\n    return detailedSignature;\n  }\n\n}\n\nexports.TupleDataType = TupleDataType;","map":{"version":3,"sources":["../../../../src/abi_encoder/evm_data_types/tuple.ts"],"names":[],"mappings":";;;;;;AAAA,MAAA,gBAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AACA,MAAA,CAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AAGA,MAAA,KAAA,GAAA,OAAA,CAAA,kCAAA,CAAA;;AAEA,MAAa,aAAb,SAAmC,KAAA,CAAA,mBAAnC,CAAsD;AAC3B,SAAT,SAAS,CAAC,IAAD,EAAa;AAChC,WAAO,IAAI,KAAK,gBAAA,CAAA,aAAA,CAAc,KAA9B;AACH;;AAED,EAAA,WAAA,CAAmB,QAAnB,EAAuC,eAAvC,EAAuE;AACnE,UAAM,QAAN,EAAgB,eAAhB;;AACA,QAAI,CAAC,aAAa,CAAC,SAAd,CAAwB,QAAQ,CAAC,IAAjC,CAAL,EAA6C;AACzC,YAAM,IAAI,KAAJ,CAAU,8CAA8C,QAAQ,EAAhE,CAAN;AACH;AACJ;;AAEM,EAAA,gBAAgB,GAAA;AACnB,WAAO,KAAK,0BAAL,CAAgC,KAAhC,CAAP;AACH;;AAEM,EAAA,YAAY,CAAC,UAAD,EAAqB;AACpC,QAAI,CAAC,CAAC,OAAF,CAAU,KAAK,WAAL,GAAmB,IAA7B,KAAsC,CAAC,UAA3C,EAAuD;AACnD,aAAO,KAAK,gBAAL,EAAP;AACH;;AACD,UAAM,IAAI,GAAG,KAAK,WAAL,GAAmB,IAAhC;AACA,UAAM,yBAAyB,GAAG,IAAI,CAAC,WAAL,CAAiB,GAAjB,CAAlC;AACA,UAAM,YAAY,GAAG,yBAAyB,KAAK,SAA9B,IAA2C,yBAAyB,GAAG,CAA5F;AACA,UAAM,SAAS,GAAG,YAAY,GAAG,IAAI,CAAC,MAAL,CAAa,yBAAoC,GAAG,CAApD,CAAH,GAA4D,IAA1F;AACA,UAAM,iBAAiB,GAAG,GAAG,SAAS,IAAI,KAAK,0BAAL,CAAgC,UAAhC,CAA2C,EAArF;AACA,WAAO,iBAAP;AACH;;AA1BiD;;AAAtD,OAAA,CAAA,aAAA,GAAA,aAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ethereum_types_1 = require(\"ethereum-types\");\nconst _ = require(\"lodash\");\nconst set_1 = require(\"../abstract_data_types/types/set\");\nclass TupleDataType extends set_1.AbstractSetDataType {\n    static matchType(type) {\n        return type === ethereum_types_1.SolidityTypes.Tuple;\n    }\n    constructor(dataItem, dataTypeFactory) {\n        super(dataItem, dataTypeFactory);\n        if (!TupleDataType.matchType(dataItem.type)) {\n            throw new Error(`Tried to instantiate Tuple with bad input: ${dataItem}`);\n        }\n    }\n    getSignatureType() {\n        return this._computeSignatureOfMembers(false);\n    }\n    getSignature(isDetailed) {\n        if (_.isEmpty(this.getDataItem().name) || !isDetailed) {\n            return this.getSignatureType();\n        }\n        const name = this.getDataItem().name;\n        const lastIndexOfScopeDelimiter = name.lastIndexOf('.');\n        const isScopedName = lastIndexOfScopeDelimiter !== undefined && lastIndexOfScopeDelimiter > 0;\n        const shortName = isScopedName ? name.substr(lastIndexOfScopeDelimiter + 1) : name;\n        const detailedSignature = `${shortName} ${this._computeSignatureOfMembers(isDetailed)}`;\n        return detailedSignature;\n    }\n}\nexports.TupleDataType = TupleDataType;\n//# sourceMappingURL=tuple.js.map"]},"metadata":{},"sourceType":"module"}