{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport waterfall from 'async/waterfall';\nimport * as ethUtil from 'ethereumjs-util';\nimport extend from 'xtend';\nimport ProviderEngine from 'web3-provider-engine';\nimport HookedWalletSubprovider from 'web3-provider-engine/subproviders/hooked-wallet';\nimport RpcSubprovider from 'web3-provider-engine/subproviders/rpc';\nimport SubscriptionSubprovider from 'web3-provider-engine/subproviders/subscriptions';\nimport FilterSubprovider from 'web3-provider-engine/subproviders/filters';\nimport pify from 'pify';\nimport * as web3Utils from 'web3-utils';\nimport Authereum from './AuthereumSDK';\nimport { throttle } from './utils';\nexport default class AuthereumProvider extends ProviderEngine {\n  constructor(config) {\n    super();\n    this.isAuthereum = true;\n    this.lastSignTx = '';\n    this.lastSignTxTimeout = null;\n    this.lastTx = '';\n    this.lastTxTimeout = null;\n    this.lastMsg = '';\n    this.lastMsgTimeout = null;\n    this.lastTypedMsg = '';\n    this.lastTypedMsgTimeout = null;\n\n    this.concatAuthKeySig = sig => __awaiter(this, void 0, void 0, function* () {\n      let authKeySig = yield this.authereum.getLoginKeyAuthSignature(); // Combines two hex strings into one hex string\n\n      authKeySig = authKeySig.slice(2);\n      return sig.concat(authKeySig);\n    });\n\n    let authereumClient = null;\n\n    if (config instanceof Authereum) {\n      authereumClient = config;\n      config = authereumClient.config;\n    }\n\n    this.config = config || {};\n    this.authereum = authereumClient || new Authereum(this.config);\n    this.initSubprovider();\n    this.isAuthereum = true;\n  }\n\n  initSubprovider() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.authereum._tilReady();\n      this.rpcUri = this.config.rpcUri || (yield this.authereum.getRpcUri());\n      const throttleTimeout = 2e3;\n      const walletSubprovider = new HookedWalletSubprovider({\n        getAccounts: cb => __awaiter(this, void 0, void 0, function* () {\n          const loggedIn = yield this.authereum.isAuthenticated();\n\n          if (!loggedIn) {\n            if (cb) {\n              cb(null, []);\n            }\n\n            return [];\n          }\n\n          const accountAddress = yield this.authereum.getAccountAddress();\n\n          if (!accountAddress) {\n            if (cb) {\n              cb(null, []);\n            }\n\n            return [];\n          }\n\n          if (cb) {\n            cb(null, [accountAddress]);\n          }\n\n          return [accountAddress];\n        }),\n        approveTransaction: (txParams, cb) => __awaiter(this, void 0, void 0, function* () {\n          if (cb) {\n            cb(null, true);\n          }\n\n          return true;\n        }),\n        approveMessage: (msgParams, cb) => __awaiter(this, void 0, void 0, function* () {\n          if (cb) {\n            cb(null, true);\n          }\n\n          return true;\n        }),\n        approveTypedMessage: (msgParams, cb) => __awaiter(this, void 0, void 0, function* () {\n          if (cb) {\n            cb(null, true);\n          }\n\n          return true;\n        }),\n        signMessage: (msgParams, cb) => __awaiter(this, void 0, void 0, function* () {\n          let currentMsg = msgParams;\n\n          try {\n            currentMsg = JSON.stringify(msgParams);\n          } catch (err) {// noop\n          } // Throttle if the tx is identical\n\n\n          clearTimeout(this.lastMsgTimeout);\n\n          if (this.lastMsg === currentMsg) {\n            return this._throttledSignMessage(msgParams, cb);\n          } // Check if this is the first one. If so, run it through the throttling function\n\n\n          const isFirst = !this.lastMsg;\n          this.lastMsg = currentMsg;\n          this.lastMsgTimeout = setTimeout(() => {\n            this.lastMsg = '';\n          }, throttleTimeout);\n\n          if (isFirst) {\n            return this._throttledSignMessage(msgParams, cb);\n          }\n\n          return this._signMessage(msgParams, cb);\n        }),\n        signTransaction: (txParams, cb) => __awaiter(this, void 0, void 0, function* () {\n          const t = Object.assign({}, txParams);\n          t.nonce = null; // Throttle if the tx is identical\n\n          const currentTx = JSON.stringify(t);\n          clearTimeout(this.lastSignTxTimeout);\n\n          if (this.lastSignTx === currentTx) {\n            return this._throttledSignTransaction(txParams, cb);\n          } // Check if this is the first one. If so, run it through the throttling function\n\n\n          const isFirst = !this.lastSignTx;\n          this.lastSignTx = currentTx;\n          this.lastSignTxTimeout = setTimeout(() => {\n            this.lastSignTx = '';\n          }, throttleTimeout);\n\n          if (isFirst) {\n            return this._throttledSignTransaction(txParams, cb);\n          }\n\n          return this._signTransaction(txParams, cb);\n        }),\n        processSignTransaction: (txParams, cb) => __awaiter(this, void 0, void 0, function* () {\n          const t = Object.assign({}, txParams);\n          t.nonce = null; // Throttle if the tx is identical\n\n          const currentTx = JSON.stringify(t);\n          clearTimeout(this.lastTxTimeout);\n\n          if (this.lastTx === currentTx) {\n            return this._throttledProcessSignTransaction(txParams, cb);\n          } // Check if this is the first one. If so, run it through the throttling function\n\n\n          const isFirst = !this.lastTx;\n          this.lastTx = currentTx;\n          this.lastTxTimeout = setTimeout(() => {\n            this.lastTx = '';\n          }, throttleTimeout);\n\n          if (isFirst) {\n            return this._throttledProcessSignTransaction(txParams, cb);\n          }\n\n          return walletSubprovider.finalizeTx(txParams, cb);\n        }),\n        processTransaction: (txParams, cb) => __awaiter(this, void 0, void 0, function* () {\n          const t = Object.assign({}, txParams);\n          t.nonce = null; // Throttle if the tx is identical\n\n          const currentTx = JSON.stringify(t);\n          clearTimeout(this.lastTxTimeout);\n\n          if (this.lastTx === currentTx) {\n            return this._throttledProcessTransaction(txParams, cb);\n          } // Check if this is the first one. If so, run it through the throttling function\n\n\n          const isFirst = !this.lastTx;\n          this.lastTx = currentTx;\n          this.lastTxTimeout = setTimeout(() => {\n            this.lastTx = '';\n          }, throttleTimeout);\n\n          if (isFirst) {\n            return this._throttledProcessTransaction(txParams, cb);\n          }\n\n          return this._processTransaction(txParams, cb);\n        }),\n        finalizeTx: (txParams, cb) => __awaiter(this, void 0, void 0, function* () {\n          try {\n            const signedTx = yield this._signTransaction(txParams);\n            const res = {\n              raw: signedTx,\n              tx: txParams\n            };\n\n            if (cb) {\n              cb(null, res);\n            }\n\n            return res;\n          } catch (err) {\n            if (cb) {\n              cb(err);\n            }\n\n            throw err;\n          }\n        }),\n        approvePersonalMessage: (msgParams, cb) => __awaiter(this, void 0, void 0, function* () {\n          if (cb) {\n            cb(null, true);\n          }\n\n          return true;\n        }),\n        signPersonalMessage: (msgParams, cb) => __awaiter(this, void 0, void 0, function* () {\n          msgParams.personal = true;\n          return walletSubprovider.signMessage(msgParams, cb);\n        }),\n        signTypedMessage: (msgParams, cb) => __awaiter(this, void 0, void 0, function* () {\n          let currentTypedMsg = msgParams;\n\n          try {\n            currentTypedMsg = JSON.stringify(msgParams);\n          } catch (err) {// noop\n          } // Throttle if the tx is identical\n\n\n          clearTimeout(this.lastTypedMsgTimeout);\n\n          if (this.lastTypedMsg === currentTypedMsg) {\n            return this._throttledSignTypedMessage(msgParams, cb);\n          } // Check if this is the first one. If so, run it through the throttling function\n\n\n          const isFirst = !this.lastTypedMsg;\n          this.lastTypedMsg = currentTypedMsg;\n          this.lastTypedMsgTimeout = setTimeout(() => {\n            this.lastTypedMsg = '';\n          }, throttleTimeout);\n\n          if (isFirst) {\n            return this._throttledSignTypedMessage(msgParams, cb);\n          }\n\n          return this._signTypedMessage(msgParams, cb);\n        })\n      });\n      this.walletSubprovider = walletSubprovider;\n\n      this._processTransaction = (txParams, cb) => __awaiter(this, void 0, void 0, function* () {\n        try {\n          const signedTransaction = yield pify(walletSubprovider.signTransaction.bind(walletSubprovider))(txParams);\n          const transactionHash = web3Utils.sha3(signedTransaction);\n\n          if (cb) {\n            cb(null, transactionHash);\n          }\n\n          return transactionHash;\n        } catch (err) {\n          if (cb) {\n            cb(err);\n            return;\n          }\n\n          throw err;\n        }\n      });\n\n      this._throttledProcessSignTransaction = throttle((txParams, cb) => __awaiter(this, void 0, void 0, function* () {\n        return walletSubprovider.finalizeTx(txParams, cb);\n      }), throttleTimeout);\n      this._throttledProcessTransaction = throttle((txParams, cb) => __awaiter(this, void 0, void 0, function* () {\n        return this._processTransaction(txParams, cb);\n      }), throttleTimeout);\n\n      this._signMessage = (msgParams, cb) => __awaiter(this, void 0, void 0, function* () {\n        try {\n          let sig = '';\n\n          if (msgParams.personal) {\n            sig = yield this.authereum.signPersonalMessage(msgParams.data);\n          } else {\n            sig = yield this.authereum.signMessage(msgParams.data);\n          }\n\n          let authKeySig = yield this.authereum.getLoginKeyAuthSignature();\n          let loginKeyRestrictionsData = yield this.authereum.getLoginKeyRestrictionsData(); // Combines three hex strings into one hex string\n\n          authKeySig = authKeySig.slice(2);\n          loginKeyRestrictionsData = loginKeyRestrictionsData.slice(2);\n          const combinedSig = sig.concat(authKeySig, loginKeyRestrictionsData);\n\n          if (cb) {\n            cb(null, combinedSig);\n          }\n\n          return combinedSig;\n        } catch (err) {\n          if (cb) {\n            cb(err);\n          }\n        }\n      });\n\n      this._throttledSignMessage = throttle((msgParams, cb) => __awaiter(this, void 0, void 0, function* () {\n        return this._signMessage(msgParams, cb);\n      }), throttleTimeout);\n\n      this._signTypedMessage = (msgParams, cb) => __awaiter(this, void 0, void 0, function* () {\n        try {\n          const sig = yield this.authereum.signTypedMessage(msgParams.data);\n          let authKeySig = yield this.authereum.getLoginKeyAuthSignature();\n          let loginKeyRestrictionsData = yield this.authereum.getLoginKeyRestrictionsData(); // Combines three hex strings into one hex string\n\n          authKeySig = authKeySig.slice(2);\n          loginKeyRestrictionsData = loginKeyRestrictionsData.slice(2);\n          const combinedSig = sig.concat(authKeySig, loginKeyRestrictionsData);\n\n          if (cb) {\n            cb(null, combinedSig);\n          }\n\n          return combinedSig;\n        } catch (err) {\n          if (cb) {\n            cb(err);\n          }\n        }\n      });\n\n      this._throttledSignTypedMessage = throttle((msgParams, cb) => __awaiter(this, void 0, void 0, function* () {\n        return this._signTypedMessage(msgParams, cb);\n      }), throttleTimeout);\n\n      this._signTransaction = (txParams, cb) => __awaiter(this, void 0, void 0, function* () {\n        try {\n          const res = yield this.authereum.signTransaction(txParams);\n\n          if (!res) {\n            throw new Error('Error signing transaction');\n          }\n\n          if (cb) {\n            cb(null, res.signedTransactionData);\n          }\n\n          return res.signedTransactionData;\n        } catch (err) {\n          cb(err);\n        }\n      });\n\n      this._throttledSignTransaction = throttle((txParams, cb) => __awaiter(this, void 0, void 0, function* () {\n        return this._signTransaction(txParams, cb);\n      }), throttleTimeout); // keep reference to original sendAsync\n\n      this._sendAsync = this.sendAsync;\n\n      this.sendAsync = (payload, callback) => __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve, reject) => {\n          if (!callback) {\n            callback = (err, response) => {\n              if (err) {\n                reject(err);\n                return;\n              }\n\n              resolve(response);\n            };\n          }\n\n          this._sendAsync(payload, callback);\n        });\n      });\n\n      this.send = (payload, callback) => {\n        // Web3 >=1.0-beta.38 calls `send` with method and parameters\n        if (typeof payload === 'string') {\n          return new Promise((resolve, reject) => {\n            this.sendAsync({\n              jsonrpc: '2.0',\n              id: 42,\n              method: payload,\n              params: callback || []\n            }, (error, response) => {\n              if (error) {\n                reject(error);\n              } else {\n                resolve(response.result);\n              }\n            });\n          });\n        } // Web3 <=1.0 beta.37 uses `send` with a callback for async queries\n\n\n        if (callback) {\n          this.sendAsync(payload, callback);\n          return;\n        }\n\n        let result = null;\n\n        switch (payload.method) {\n          case 'eth_uninstallFilter':\n            this.sendAsync(payload, () => {// noop\n            });\n            result = true;\n            break;\n\n          default:\n            let message = `The Authereum Web3 object does not support synchronous methods like ${payload.method} without a callback parameter.`;\n            throw new Error(message);\n        }\n\n        return {\n          id: payload.id,\n          jsonrpc: payload.jsonrpc,\n          result: result\n        };\n      };\n\n      walletSubprovider.handleRequest = function (payload, next, end) {\n        const self = this;\n        self._parityRequests = {};\n        self._parityRequestCount = 0; // switch statement is not block scoped\n        // sp we cant repeat var declarations\n\n        let txParams;\n        let msgParams;\n        let extraParams;\n        let message;\n        let address;\n\n        switch (payload.method) {\n          case 'eth_coinbase':\n            // process normally\n            self.getAccounts(function (err, accounts) {\n              if (err) return end(err);\n              let result = accounts[0] || null;\n              end(null, result);\n            });\n            return;\n\n          case 'eth_accounts':\n            // process normally\n            self.getAccounts(function (err, accounts) {\n              if (err) return end(err);\n              end(null, accounts);\n            });\n            return;\n\n          case 'eth_sendTransaction':\n            txParams = payload.params[0];\n            waterfall([cb => self.processTransaction(txParams, cb)], end);\n            return;\n\n          case 'eth_signTransaction':\n            txParams = payload.params[0];\n            waterfall([cb => self.processSignTransaction(txParams, cb)], end);\n            return;\n\n          case 'eth_sign':\n            // process normally\n            address = payload.params[0];\n            message = payload.params[1]; // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n            // good place for metadata\n\n            extraParams = payload.params[2] || {};\n            msgParams = extend(extraParams, {\n              from: address,\n              data: message\n            });\n            waterfall([cb => self.processMessage(msgParams, cb)], end);\n            return;\n\n          case 'personal_sign':\n            return function () {\n              // process normally\n              const first = payload.params[0];\n              const second = payload.params[1]; // We initially incorrectly ordered these parameters.\n              // To gracefully respect users who adopted this API early,\n              // we are currently gracefully recovering from the wrong param order\n              // when it is clearly identifiable.\n              //\n              // That means when the first param is definitely an address,\n              // and the second param is definitely not, but is hex.\n\n              if (resemblesData(second) && resemblesAddress(first)) {\n                let warning = `The eth_personalSign method requires params ordered `;\n                warning += `[message, address]. This was previously handled incorrectly, `;\n                warning += `and has been corrected automatically. `;\n                warning += `Please switch this param order for smooth behavior in the future.`;\n                console.warn(warning);\n                address = payload.params[0];\n                message = payload.params[1];\n              } else {\n                message = payload.params[0];\n                address = payload.params[1];\n              } // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n              // good place for metadata\n\n\n              extraParams = payload.params[2] || {};\n              msgParams = extend(extraParams, {\n                from: address,\n                data: message\n              });\n              waterfall([cb => self.processPersonalMessage(msgParams, cb)], end);\n            }();\n\n          case 'eth_decryptMessage':\n            return function () {\n              // process normally\n              const first = payload.params[0];\n              const second = payload.params[1]; // We initially incorrectly ordered these parameters.\n              // To gracefully respect users who adopted this API early,\n              // we are currently gracefully recovering from the wrong param order\n              // when it is clearly identifiable.\n              //\n              // That means when the first param is definitely an address,\n              // and the second param is definitely not, but is hex.\n\n              if (resemblesData(second) && resemblesAddress(first)) {\n                let warning = `The eth_decryptMessage method requires params ordered `;\n                warning += `[message, address]. This was previously handled incorrectly, `;\n                warning += `and has been corrected automatically. `;\n                warning += `Please switch this param order for smooth behavior in the future.`;\n                console.warn(warning);\n                address = payload.params[0];\n                message = payload.params[1];\n              } else {\n                message = payload.params[0];\n                address = payload.params[1];\n              } // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n              // good place for metadata\n\n\n              extraParams = payload.params[2] || {};\n              msgParams = extend(extraParams, {\n                from: address,\n                data: message\n              });\n              waterfall([cb => self.validateDecryptMessage(msgParams, cb), cb => self.processDecryptMessage(msgParams, cb)], end);\n            }();\n\n          case 'encryption_public_key':\n            return function () {\n              address = payload.params[0];\n              waterfall([cb => self.validateEncryptionPublicKey(address, cb), cb => self.processEncryptionPublicKey(address, cb)], end);\n            }();\n\n          case 'personal_ecRecover':\n            return function () {\n              message = payload.params[0];\n              let signature = payload.params[1]; // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n              // good place for metadata\n\n              extraParams = payload.params[2] || {};\n              msgParams = extend(extraParams, {\n                sig: signature,\n                data: message\n              });\n              self.recoverPersonalSignature(msgParams, end);\n            }();\n\n          case 'eth_signTypedData':\n            // process normally\n            message = payload.params[0];\n            address = payload.params[1];\n            extraParams = payload.params[2] || {};\n            msgParams = extend(extraParams, {\n              from: address,\n              data: message\n            });\n            waterfall([cb => self.processTypedMessage(msgParams, cb)], end);\n            return;\n\n          case 'eth_signTypedData_v3':\n            // process normally\n            address = payload.params[0];\n            message = payload.params[1];\n            extraParams = payload.params[2] || {};\n            msgParams = extend(extraParams, {\n              from: address,\n              data: message\n            });\n            waterfall([cb => self.processTypedMessage(msgParams, cb)], end);\n            return;\n\n          case 'parity_postTransaction':\n            txParams = payload.params[0];\n            self.parityPostTransaction(txParams, end);\n            return;\n\n          case 'parity_postSign':\n            address = payload.params[0];\n            message = payload.params[1];\n            self.parityPostSign(address, message, end);\n            return;\n\n          case 'parity_checkRequest':\n            return function () {\n              const requestId = payload.params[0];\n              self.parityCheckRequest(requestId, end);\n            }();\n\n          case 'parity_defaultAccount':\n            self.getAccounts(function (err, accounts) {\n              if (err) return end(err);\n              const account = accounts[0] || null;\n              end(null, account);\n            });\n            return;\n\n          default:\n            next();\n            return;\n        }\n      };\n\n      walletSubprovider.validatePersonalMessage = (msgParams, cb) => __awaiter(this, void 0, void 0, function* () {\n        if (cb) {\n          cb(null, true);\n        }\n\n        return true;\n      });\n\n      walletSubprovider.validateMessage = (msgParams, cb) => __awaiter(this, void 0, void 0, function* () {\n        if (cb) {\n          cb(null, true);\n        }\n\n        return true;\n      });\n\n      walletSubprovider.validateTypedMessage = (msgParams, cb) => __awaiter(this, void 0, void 0, function* () {\n        if (cb) {\n          cb(null, true);\n        }\n\n        return true;\n      });\n\n      this.addProvider(walletSubprovider);\n      this.rpcSubProvider = new RpcSubprovider({\n        rpcUrl: this.rpcUri\n      });\n      this.addProvider(new SubscriptionSubprovider());\n      this.addProvider(new FilterSubprovider());\n      this.addProvider({\n        setEngine: _ => _,\n        handleRequest: (payload, next, end) => __awaiter(this, void 0, void 0, function* () {\n          this.rpcSubProvider.handleRequest(payload, next, end);\n        })\n      }); // network connectivity error\n\n      this.on('error', err => {\n        console.error(err.stack);\n      }); // start polling\n\n      this.start();\n\n      this._blockTracker.removeAllListeners();\n    });\n  }\n\n  getAccounts(cb) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const loggedIn = yield this.authereum.isAuthenticated();\n\n      if (!loggedIn) {\n        if (cb) {\n          cb(null, []);\n        }\n\n        return [];\n      }\n\n      const accountAddress = yield this.authereum.getAccountAddress();\n\n      if (!accountAddress) {\n        if (cb) {\n          cb(null, []);\n        }\n\n        return [];\n      }\n\n      if (cb) {\n        cb(null, [accountAddress]);\n      }\n\n      return [accountAddress];\n    });\n  }\n\n  isConnected() {\n    return this.authereum.isAuthenticatedSync();\n  }\n\n  enable() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.authereum.login();\n      const accountAddress = yield this.authereum.getAccountAddress();\n\n      if (accountAddress) {\n        return [accountAddress];\n      }\n\n      return [];\n    });\n  }\n\n  disable() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.authereum.logout();\n    });\n  }\n\n  tilDomReady() {\n    return new Promise(resolve => {\n      if (document.readyState !== 'loading') {\n        resolve();\n      } else {\n        document.addEventListener('DOMContentLoaded', () => resolve());\n      }\n    });\n  }\n\n  sendTransaction(tx) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.sendTransactionBatch([tx]);\n    });\n  }\n\n  sendTransactionBatch(txs) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.authereum.sendTransactionBatch(txs);\n    });\n  }\n\n  estimateGasBatch(txs) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.authereum.estimateGasBatch(txs);\n    });\n  }\n\n  sign(msgParams) {\n    return this._signMessage(msgParams);\n  }\n\n  signMessageWithAdminKey(message) {\n    return this.authereum.signMessageWithAdminKey(message);\n  }\n\n  signMessageWithSigningKey(message) {\n    return this.authereum.signMessageWithSigningKey(message);\n  }\n\n  showWidget(enabled = true) {\n    return this.authereum.showWidget(enabled);\n  }\n\n  widgetEnabled() {\n    return this.authereum.widgetEnabled();\n  }\n\n  getTransactionReceipt(txHash) {\n    return this.authereum.getTransactionReceipt(txHash);\n  }\n\n  waitForTransactionReceipt(txHash) {\n    return this.authereum.waitForTransactionReceipt(txHash);\n  }\n\n  isContractDeployed(accountAddress) {\n    return this.authereum.isContractDeployed(accountAddress);\n  }\n\n}\n\nfunction resemblesAddress(str) {\n  const fixed = ethUtil.addHexPrefix(str);\n  const isValid = ethUtil.isValidAddress(fixed);\n  return isValid;\n} // Returns true if resembles hex data\n// but definitely not a valid address.\n\n\nfunction resemblesData(str) {\n  const fixed = ethUtil.addHexPrefix(str);\n  const isValidAddress = ethUtil.isValidAddress(fixed);\n  return !isValidAddress && isValidHex(str);\n}\n\nfunction isValidHex(data) {\n  const isString = typeof data === 'string';\n  if (!isString) return false;\n  const isHexPrefixed = data.slice(0, 2) === '0x';\n  if (!isHexPrefixed) return false;\n  const nonPrefixed = data.slice(2);\n  const hexRegex = /^[0-9A-Fa-f]+$/g;\n  const isValid = nonPrefixed.match(hexRegex);\n  return isValid;\n}","map":{"version":3,"sources":["/Users/kelvinho/Documents/Coding/HoHey-main 4 2/hoheywebsite/client/src/example/node_modules/authereum/dist/AuthereumProvider.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","waterfall","ethUtil","extend","ProviderEngine","HookedWalletSubprovider","RpcSubprovider","SubscriptionSubprovider","FilterSubprovider","pify","web3Utils","Authereum","throttle","AuthereumProvider","constructor","config","isAuthereum","lastSignTx","lastSignTxTimeout","lastTx","lastTxTimeout","lastMsg","lastMsgTimeout","lastTypedMsg","lastTypedMsgTimeout","concatAuthKeySig","sig","authKeySig","authereum","getLoginKeyAuthSignature","slice","concat","authereumClient","initSubprovider","_tilReady","rpcUri","getRpcUri","throttleTimeout","walletSubprovider","getAccounts","cb","loggedIn","isAuthenticated","accountAddress","getAccountAddress","approveTransaction","txParams","approveMessage","msgParams","approveTypedMessage","signMessage","currentMsg","JSON","stringify","err","clearTimeout","_throttledSignMessage","isFirst","setTimeout","_signMessage","signTransaction","t","Object","assign","nonce","currentTx","_throttledSignTransaction","_signTransaction","processSignTransaction","_throttledProcessSignTransaction","finalizeTx","processTransaction","_throttledProcessTransaction","_processTransaction","signedTx","res","raw","tx","approvePersonalMessage","signPersonalMessage","personal","signTypedMessage","currentTypedMsg","_throttledSignTypedMessage","_signTypedMessage","signedTransaction","bind","transactionHash","sha3","data","loginKeyRestrictionsData","getLoginKeyRestrictionsData","combinedSig","Error","signedTransactionData","_sendAsync","sendAsync","payload","callback","response","send","jsonrpc","id","method","params","error","message","handleRequest","end","self","_parityRequests","_parityRequestCount","extraParams","address","accounts","from","processMessage","first","second","resemblesData","resemblesAddress","warning","console","warn","processPersonalMessage","validateDecryptMessage","processDecryptMessage","validateEncryptionPublicKey","processEncryptionPublicKey","signature","recoverPersonalSignature","processTypedMessage","parityPostTransaction","parityPostSign","requestId","parityCheckRequest","account","validatePersonalMessage","validateMessage","validateTypedMessage","addProvider","rpcSubProvider","rpcUrl","setEngine","_","on","stack","start","_blockTracker","removeAllListeners","isConnected","isAuthenticatedSync","enable","login","disable","logout","tilDomReady","document","readyState","addEventListener","sendTransaction","sendTransactionBatch","txs","estimateGasBatch","sign","signMessageWithAdminKey","signMessageWithSigningKey","showWidget","enabled","widgetEnabled","getTransactionReceipt","txHash","waitForTransactionReceipt","isContractDeployed","str","fixed","addHexPrefix","isValid","isValidAddress","isValidHex","isString","isHexPrefixed","nonPrefixed","hexRegex","match"],"mappings":"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","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport waterfall from 'async/waterfall';\nimport * as ethUtil from 'ethereumjs-util';\nimport extend from 'xtend';\nimport ProviderEngine from 'web3-provider-engine';\nimport HookedWalletSubprovider from 'web3-provider-engine/subproviders/hooked-wallet';\nimport RpcSubprovider from 'web3-provider-engine/subproviders/rpc';\nimport SubscriptionSubprovider from 'web3-provider-engine/subproviders/subscriptions';\nimport FilterSubprovider from 'web3-provider-engine/subproviders/filters';\nimport pify from 'pify';\nimport * as web3Utils from 'web3-utils';\nimport Authereum from './AuthereumSDK';\nimport { throttle } from './utils';\nexport default class AuthereumProvider extends ProviderEngine {\n    constructor(config) {\n        super();\n        this.isAuthereum = true;\n        this.lastSignTx = '';\n        this.lastSignTxTimeout = null;\n        this.lastTx = '';\n        this.lastTxTimeout = null;\n        this.lastMsg = '';\n        this.lastMsgTimeout = null;\n        this.lastTypedMsg = '';\n        this.lastTypedMsgTimeout = null;\n        this.concatAuthKeySig = (sig) => __awaiter(this, void 0, void 0, function* () {\n            let authKeySig = yield this.authereum.getLoginKeyAuthSignature();\n            // Combines two hex strings into one hex string\n            authKeySig = authKeySig.slice(2);\n            return sig.concat(authKeySig);\n        });\n        let authereumClient = null;\n        if (config instanceof Authereum) {\n            authereumClient = config;\n            config = authereumClient.config;\n        }\n        this.config = config || {};\n        this.authereum = authereumClient || new Authereum(this.config);\n        this.initSubprovider();\n        this.isAuthereum = true;\n    }\n    initSubprovider() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.authereum._tilReady();\n            this.rpcUri = this.config.rpcUri || (yield this.authereum.getRpcUri());\n            const throttleTimeout = 2e3;\n            const walletSubprovider = new HookedWalletSubprovider({\n                getAccounts: (cb) => __awaiter(this, void 0, void 0, function* () {\n                    const loggedIn = yield this.authereum.isAuthenticated();\n                    if (!loggedIn) {\n                        if (cb) {\n                            cb(null, []);\n                        }\n                        return [];\n                    }\n                    const accountAddress = yield this.authereum.getAccountAddress();\n                    if (!accountAddress) {\n                        if (cb) {\n                            cb(null, []);\n                        }\n                        return [];\n                    }\n                    if (cb) {\n                        cb(null, [accountAddress]);\n                    }\n                    return [accountAddress];\n                }),\n                approveTransaction: (txParams, cb) => __awaiter(this, void 0, void 0, function* () {\n                    if (cb) {\n                        cb(null, true);\n                    }\n                    return true;\n                }),\n                approveMessage: (msgParams, cb) => __awaiter(this, void 0, void 0, function* () {\n                    if (cb) {\n                        cb(null, true);\n                    }\n                    return true;\n                }),\n                approveTypedMessage: (msgParams, cb) => __awaiter(this, void 0, void 0, function* () {\n                    if (cb) {\n                        cb(null, true);\n                    }\n                    return true;\n                }),\n                signMessage: (msgParams, cb) => __awaiter(this, void 0, void 0, function* () {\n                    let currentMsg = msgParams;\n                    try {\n                        currentMsg = JSON.stringify(msgParams);\n                    }\n                    catch (err) {\n                        // noop\n                    }\n                    // Throttle if the tx is identical\n                    clearTimeout(this.lastMsgTimeout);\n                    if (this.lastMsg === currentMsg) {\n                        return this._throttledSignMessage(msgParams, cb);\n                    }\n                    // Check if this is the first one. If so, run it through the throttling function\n                    const isFirst = !this.lastMsg;\n                    this.lastMsg = currentMsg;\n                    this.lastMsgTimeout = setTimeout(() => {\n                        this.lastMsg = '';\n                    }, throttleTimeout);\n                    if (isFirst) {\n                        return this._throttledSignMessage(msgParams, cb);\n                    }\n                    return this._signMessage(msgParams, cb);\n                }),\n                signTransaction: (txParams, cb) => __awaiter(this, void 0, void 0, function* () {\n                    const t = Object.assign({}, txParams);\n                    t.nonce = null;\n                    // Throttle if the tx is identical\n                    const currentTx = JSON.stringify(t);\n                    clearTimeout(this.lastSignTxTimeout);\n                    if (this.lastSignTx === currentTx) {\n                        return this._throttledSignTransaction(txParams, cb);\n                    }\n                    // Check if this is the first one. If so, run it through the throttling function\n                    const isFirst = !this.lastSignTx;\n                    this.lastSignTx = currentTx;\n                    this.lastSignTxTimeout = setTimeout(() => {\n                        this.lastSignTx = '';\n                    }, throttleTimeout);\n                    if (isFirst) {\n                        return this._throttledSignTransaction(txParams, cb);\n                    }\n                    return this._signTransaction(txParams, cb);\n                }),\n                processSignTransaction: (txParams, cb) => __awaiter(this, void 0, void 0, function* () {\n                    const t = Object.assign({}, txParams);\n                    t.nonce = null;\n                    // Throttle if the tx is identical\n                    const currentTx = JSON.stringify(t);\n                    clearTimeout(this.lastTxTimeout);\n                    if (this.lastTx === currentTx) {\n                        return this._throttledProcessSignTransaction(txParams, cb);\n                    }\n                    // Check if this is the first one. If so, run it through the throttling function\n                    const isFirst = !this.lastTx;\n                    this.lastTx = currentTx;\n                    this.lastTxTimeout = setTimeout(() => {\n                        this.lastTx = '';\n                    }, throttleTimeout);\n                    if (isFirst) {\n                        return this._throttledProcessSignTransaction(txParams, cb);\n                    }\n                    return walletSubprovider.finalizeTx(txParams, cb);\n                }),\n                processTransaction: (txParams, cb) => __awaiter(this, void 0, void 0, function* () {\n                    const t = Object.assign({}, txParams);\n                    t.nonce = null;\n                    // Throttle if the tx is identical\n                    const currentTx = JSON.stringify(t);\n                    clearTimeout(this.lastTxTimeout);\n                    if (this.lastTx === currentTx) {\n                        return this._throttledProcessTransaction(txParams, cb);\n                    }\n                    // Check if this is the first one. If so, run it through the throttling function\n                    const isFirst = !this.lastTx;\n                    this.lastTx = currentTx;\n                    this.lastTxTimeout = setTimeout(() => {\n                        this.lastTx = '';\n                    }, throttleTimeout);\n                    if (isFirst) {\n                        return this._throttledProcessTransaction(txParams, cb);\n                    }\n                    return this._processTransaction(txParams, cb);\n                }),\n                finalizeTx: (txParams, cb) => __awaiter(this, void 0, void 0, function* () {\n                    try {\n                        const signedTx = yield this._signTransaction(txParams);\n                        const res = { raw: signedTx, tx: txParams };\n                        if (cb) {\n                            cb(null, res);\n                        }\n                        return res;\n                    }\n                    catch (err) {\n                        if (cb) {\n                            cb(err);\n                        }\n                        throw err;\n                    }\n                }),\n                approvePersonalMessage: (msgParams, cb) => __awaiter(this, void 0, void 0, function* () {\n                    if (cb) {\n                        cb(null, true);\n                    }\n                    return true;\n                }),\n                signPersonalMessage: (msgParams, cb) => __awaiter(this, void 0, void 0, function* () {\n                    msgParams.personal = true;\n                    return walletSubprovider.signMessage(msgParams, cb);\n                }),\n                signTypedMessage: (msgParams, cb) => __awaiter(this, void 0, void 0, function* () {\n                    let currentTypedMsg = msgParams;\n                    try {\n                        currentTypedMsg = JSON.stringify(msgParams);\n                    }\n                    catch (err) {\n                        // noop\n                    }\n                    // Throttle if the tx is identical\n                    clearTimeout(this.lastTypedMsgTimeout);\n                    if (this.lastTypedMsg === currentTypedMsg) {\n                        return this._throttledSignTypedMessage(msgParams, cb);\n                    }\n                    // Check if this is the first one. If so, run it through the throttling function\n                    const isFirst = !this.lastTypedMsg;\n                    this.lastTypedMsg = currentTypedMsg;\n                    this.lastTypedMsgTimeout = setTimeout(() => {\n                        this.lastTypedMsg = '';\n                    }, throttleTimeout);\n                    if (isFirst) {\n                        return this._throttledSignTypedMessage(msgParams, cb);\n                    }\n                    return this._signTypedMessage(msgParams, cb);\n                })\n            });\n            this.walletSubprovider = walletSubprovider;\n            this._processTransaction = (txParams, cb) => __awaiter(this, void 0, void 0, function* () {\n                try {\n                    const signedTransaction = yield pify(walletSubprovider.signTransaction.bind(walletSubprovider))(txParams);\n                    const transactionHash = web3Utils.sha3(signedTransaction);\n                    if (cb) {\n                        cb(null, transactionHash);\n                    }\n                    return transactionHash;\n                }\n                catch (err) {\n                    if (cb) {\n                        cb(err);\n                        return;\n                    }\n                    throw err;\n                }\n            });\n            this._throttledProcessSignTransaction = throttle((txParams, cb) => __awaiter(this, void 0, void 0, function* () {\n                return walletSubprovider.finalizeTx(txParams, cb);\n            }), throttleTimeout);\n            this._throttledProcessTransaction = throttle((txParams, cb) => __awaiter(this, void 0, void 0, function* () {\n                return this._processTransaction(txParams, cb);\n            }), throttleTimeout);\n            this._signMessage = (msgParams, cb) => __awaiter(this, void 0, void 0, function* () {\n                try {\n                    let sig = '';\n                    if (msgParams.personal) {\n                        sig = yield this.authereum.signPersonalMessage(msgParams.data);\n                    }\n                    else {\n                        sig = yield this.authereum.signMessage(msgParams.data);\n                    }\n                    let authKeySig = yield this.authereum.getLoginKeyAuthSignature();\n                    let loginKeyRestrictionsData = yield this.authereum.getLoginKeyRestrictionsData();\n                    // Combines three hex strings into one hex string\n                    authKeySig = authKeySig.slice(2);\n                    loginKeyRestrictionsData = loginKeyRestrictionsData.slice(2);\n                    const combinedSig = sig.concat(authKeySig, loginKeyRestrictionsData);\n                    if (cb) {\n                        cb(null, combinedSig);\n                    }\n                    return combinedSig;\n                }\n                catch (err) {\n                    if (cb) {\n                        cb(err);\n                    }\n                }\n            });\n            this._throttledSignMessage = throttle((msgParams, cb) => __awaiter(this, void 0, void 0, function* () {\n                return this._signMessage(msgParams, cb);\n            }), throttleTimeout);\n            this._signTypedMessage = (msgParams, cb) => __awaiter(this, void 0, void 0, function* () {\n                try {\n                    const sig = yield this.authereum.signTypedMessage(msgParams.data);\n                    let authKeySig = yield this.authereum.getLoginKeyAuthSignature();\n                    let loginKeyRestrictionsData = yield this.authereum.getLoginKeyRestrictionsData();\n                    // Combines three hex strings into one hex string\n                    authKeySig = authKeySig.slice(2);\n                    loginKeyRestrictionsData = loginKeyRestrictionsData.slice(2);\n                    const combinedSig = sig.concat(authKeySig, loginKeyRestrictionsData);\n                    if (cb) {\n                        cb(null, combinedSig);\n                    }\n                    return combinedSig;\n                }\n                catch (err) {\n                    if (cb) {\n                        cb(err);\n                    }\n                }\n            });\n            this._throttledSignTypedMessage = throttle((msgParams, cb) => __awaiter(this, void 0, void 0, function* () {\n                return this._signTypedMessage(msgParams, cb);\n            }), throttleTimeout);\n            this._signTransaction = (txParams, cb) => __awaiter(this, void 0, void 0, function* () {\n                try {\n                    const res = yield this.authereum.signTransaction(txParams);\n                    if (!res) {\n                        throw new Error('Error signing transaction');\n                    }\n                    if (cb) {\n                        cb(null, res.signedTransactionData);\n                    }\n                    return res.signedTransactionData;\n                }\n                catch (err) {\n                    cb(err);\n                }\n            });\n            this._throttledSignTransaction = throttle((txParams, cb) => __awaiter(this, void 0, void 0, function* () {\n                return this._signTransaction(txParams, cb);\n            }), throttleTimeout);\n            // keep reference to original sendAsync\n            this._sendAsync = this.sendAsync;\n            this.sendAsync = (payload, callback) => __awaiter(this, void 0, void 0, function* () {\n                return new Promise((resolve, reject) => {\n                    if (!callback) {\n                        callback = (err, response) => {\n                            if (err) {\n                                reject(err);\n                                return;\n                            }\n                            resolve(response);\n                        };\n                    }\n                    this._sendAsync(payload, callback);\n                });\n            });\n            this.send = (payload, callback) => {\n                // Web3 >=1.0-beta.38 calls `send` with method and parameters\n                if (typeof payload === 'string') {\n                    return new Promise((resolve, reject) => {\n                        this.sendAsync({\n                            jsonrpc: '2.0',\n                            id: 42,\n                            method: payload,\n                            params: callback || []\n                        }, (error, response) => {\n                            if (error) {\n                                reject(error);\n                            }\n                            else {\n                                resolve(response.result);\n                            }\n                        });\n                    });\n                }\n                // Web3 <=1.0 beta.37 uses `send` with a callback for async queries\n                if (callback) {\n                    this.sendAsync(payload, callback);\n                    return;\n                }\n                let result = null;\n                switch (payload.method) {\n                    case 'eth_uninstallFilter':\n                        this.sendAsync(payload, () => {\n                            // noop\n                        });\n                        result = true;\n                        break;\n                    default:\n                        let message = `The Authereum Web3 object does not support synchronous methods like ${payload.method} without a callback parameter.`;\n                        throw new Error(message);\n                }\n                return {\n                    id: payload.id,\n                    jsonrpc: payload.jsonrpc,\n                    result: result\n                };\n            };\n            walletSubprovider.handleRequest = function (payload, next, end) {\n                const self = this;\n                self._parityRequests = {};\n                self._parityRequestCount = 0;\n                // switch statement is not block scoped\n                // sp we cant repeat var declarations\n                let txParams;\n                let msgParams;\n                let extraParams;\n                let message;\n                let address;\n                switch (payload.method) {\n                    case 'eth_coinbase':\n                        // process normally\n                        self.getAccounts(function (err, accounts) {\n                            if (err)\n                                return end(err);\n                            let result = accounts[0] || null;\n                            end(null, result);\n                        });\n                        return;\n                    case 'eth_accounts':\n                        // process normally\n                        self.getAccounts(function (err, accounts) {\n                            if (err)\n                                return end(err);\n                            end(null, accounts);\n                        });\n                        return;\n                    case 'eth_sendTransaction':\n                        txParams = payload.params[0];\n                        waterfall([\n                            (cb) => self.processTransaction(txParams, cb)\n                        ], end);\n                        return;\n                    case 'eth_signTransaction':\n                        txParams = payload.params[0];\n                        waterfall([\n                            (cb) => self.processSignTransaction(txParams, cb)\n                        ], end);\n                        return;\n                    case 'eth_sign':\n                        // process normally\n                        address = payload.params[0];\n                        message = payload.params[1];\n                        // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n                        // good place for metadata\n                        extraParams = payload.params[2] || {};\n                        msgParams = extend(extraParams, {\n                            from: address,\n                            data: message\n                        });\n                        waterfall([\n                            (cb) => self.processMessage(msgParams, cb)\n                        ], end);\n                        return;\n                    case 'personal_sign':\n                        return (function () {\n                            // process normally\n                            const first = payload.params[0];\n                            const second = payload.params[1];\n                            // We initially incorrectly ordered these parameters.\n                            // To gracefully respect users who adopted this API early,\n                            // we are currently gracefully recovering from the wrong param order\n                            // when it is clearly identifiable.\n                            //\n                            // That means when the first param is definitely an address,\n                            // and the second param is definitely not, but is hex.\n                            if (resemblesData(second) && resemblesAddress(first)) {\n                                let warning = `The eth_personalSign method requires params ordered `;\n                                warning += `[message, address]. This was previously handled incorrectly, `;\n                                warning += `and has been corrected automatically. `;\n                                warning += `Please switch this param order for smooth behavior in the future.`;\n                                console.warn(warning);\n                                address = payload.params[0];\n                                message = payload.params[1];\n                            }\n                            else {\n                                message = payload.params[0];\n                                address = payload.params[1];\n                            }\n                            // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n                            // good place for metadata\n                            extraParams = payload.params[2] || {};\n                            msgParams = extend(extraParams, {\n                                from: address,\n                                data: message\n                            });\n                            waterfall([\n                                (cb) => self.processPersonalMessage(msgParams, cb)\n                            ], end);\n                        })();\n                    case 'eth_decryptMessage':\n                        return (function () {\n                            // process normally\n                            const first = payload.params[0];\n                            const second = payload.params[1];\n                            // We initially incorrectly ordered these parameters.\n                            // To gracefully respect users who adopted this API early,\n                            // we are currently gracefully recovering from the wrong param order\n                            // when it is clearly identifiable.\n                            //\n                            // That means when the first param is definitely an address,\n                            // and the second param is definitely not, but is hex.\n                            if (resemblesData(second) && resemblesAddress(first)) {\n                                let warning = `The eth_decryptMessage method requires params ordered `;\n                                warning += `[message, address]. This was previously handled incorrectly, `;\n                                warning += `and has been corrected automatically. `;\n                                warning += `Please switch this param order for smooth behavior in the future.`;\n                                console.warn(warning);\n                                address = payload.params[0];\n                                message = payload.params[1];\n                            }\n                            else {\n                                message = payload.params[0];\n                                address = payload.params[1];\n                            }\n                            // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n                            // good place for metadata\n                            extraParams = payload.params[2] || {};\n                            msgParams = extend(extraParams, {\n                                from: address,\n                                data: message\n                            });\n                            waterfall([\n                                (cb) => self.validateDecryptMessage(msgParams, cb),\n                                (cb) => self.processDecryptMessage(msgParams, cb)\n                            ], end);\n                        })();\n                    case 'encryption_public_key':\n                        return (function () {\n                            address = payload.params[0];\n                            waterfall([\n                                (cb) => self.validateEncryptionPublicKey(address, cb),\n                                (cb) => self.processEncryptionPublicKey(address, cb)\n                            ], end);\n                        })();\n                    case 'personal_ecRecover':\n                        return (function () {\n                            message = payload.params[0];\n                            let signature = payload.params[1];\n                            // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n                            // good place for metadata\n                            extraParams = payload.params[2] || {};\n                            msgParams = extend(extraParams, {\n                                sig: signature,\n                                data: message\n                            });\n                            self.recoverPersonalSignature(msgParams, end);\n                        })();\n                    case 'eth_signTypedData':\n                        // process normally\n                        message = payload.params[0];\n                        address = payload.params[1];\n                        extraParams = payload.params[2] || {};\n                        msgParams = extend(extraParams, {\n                            from: address,\n                            data: message\n                        });\n                        waterfall([\n                            (cb) => self.processTypedMessage(msgParams, cb)\n                        ], end);\n                        return;\n                    case 'eth_signTypedData_v3':\n                        // process normally\n                        address = payload.params[0];\n                        message = payload.params[1];\n                        extraParams = payload.params[2] || {};\n                        msgParams = extend(extraParams, {\n                            from: address,\n                            data: message\n                        });\n                        waterfall([\n                            (cb) => self.processTypedMessage(msgParams, cb)\n                        ], end);\n                        return;\n                    case 'parity_postTransaction':\n                        txParams = payload.params[0];\n                        self.parityPostTransaction(txParams, end);\n                        return;\n                    case 'parity_postSign':\n                        address = payload.params[0];\n                        message = payload.params[1];\n                        self.parityPostSign(address, message, end);\n                        return;\n                    case 'parity_checkRequest':\n                        return (function () {\n                            const requestId = payload.params[0];\n                            self.parityCheckRequest(requestId, end);\n                        })();\n                    case 'parity_defaultAccount':\n                        self.getAccounts(function (err, accounts) {\n                            if (err)\n                                return end(err);\n                            const account = accounts[0] || null;\n                            end(null, account);\n                        });\n                        return;\n                    default:\n                        next();\n                        return;\n                }\n            };\n            walletSubprovider.validatePersonalMessage = (msgParams, cb) => __awaiter(this, void 0, void 0, function* () {\n                if (cb) {\n                    cb(null, true);\n                }\n                return true;\n            });\n            walletSubprovider.validateMessage = (msgParams, cb) => __awaiter(this, void 0, void 0, function* () {\n                if (cb) {\n                    cb(null, true);\n                }\n                return true;\n            });\n            walletSubprovider.validateTypedMessage = (msgParams, cb) => __awaiter(this, void 0, void 0, function* () {\n                if (cb) {\n                    cb(null, true);\n                }\n                return true;\n            });\n            this.addProvider(walletSubprovider);\n            this.rpcSubProvider = new RpcSubprovider({\n                rpcUrl: this.rpcUri\n            });\n            this.addProvider(new SubscriptionSubprovider());\n            this.addProvider(new FilterSubprovider());\n            this.addProvider({\n                setEngine: _ => _,\n                handleRequest: (payload, next, end) => __awaiter(this, void 0, void 0, function* () {\n                    this.rpcSubProvider.handleRequest(payload, next, end);\n                })\n            });\n            // network connectivity error\n            this.on('error', (err) => {\n                console.error(err.stack);\n            });\n            // start polling\n            this.start();\n            this._blockTracker.removeAllListeners();\n        });\n    }\n    getAccounts(cb) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const loggedIn = yield this.authereum.isAuthenticated();\n            if (!loggedIn) {\n                if (cb) {\n                    cb(null, []);\n                }\n                return [];\n            }\n            const accountAddress = yield this.authereum.getAccountAddress();\n            if (!accountAddress) {\n                if (cb) {\n                    cb(null, []);\n                }\n                return [];\n            }\n            if (cb) {\n                cb(null, [accountAddress]);\n            }\n            return [accountAddress];\n        });\n    }\n    isConnected() {\n        return this.authereum.isAuthenticatedSync();\n    }\n    enable() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.authereum.login();\n            const accountAddress = yield this.authereum.getAccountAddress();\n            if (accountAddress) {\n                return [accountAddress];\n            }\n            return [];\n        });\n    }\n    disable() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.authereum.logout();\n        });\n    }\n    tilDomReady() {\n        return new Promise((resolve) => {\n            if (document.readyState !== 'loading') {\n                resolve();\n            }\n            else {\n                document.addEventListener('DOMContentLoaded', () => resolve());\n            }\n        });\n    }\n    sendTransaction(tx) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.sendTransactionBatch([tx]);\n        });\n    }\n    sendTransactionBatch(txs) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.authereum.sendTransactionBatch(txs);\n        });\n    }\n    estimateGasBatch(txs) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.authereum.estimateGasBatch(txs);\n        });\n    }\n    sign(msgParams) {\n        return this._signMessage(msgParams);\n    }\n    signMessageWithAdminKey(message) {\n        return this.authereum.signMessageWithAdminKey(message);\n    }\n    signMessageWithSigningKey(message) {\n        return this.authereum.signMessageWithSigningKey(message);\n    }\n    showWidget(enabled = true) {\n        return this.authereum.showWidget(enabled);\n    }\n    widgetEnabled() {\n        return this.authereum.widgetEnabled();\n    }\n    getTransactionReceipt(txHash) {\n        return this.authereum.getTransactionReceipt(txHash);\n    }\n    waitForTransactionReceipt(txHash) {\n        return this.authereum.waitForTransactionReceipt(txHash);\n    }\n    isContractDeployed(accountAddress) {\n        return this.authereum.isContractDeployed(accountAddress);\n    }\n}\nfunction resemblesAddress(str) {\n    const fixed = ethUtil.addHexPrefix(str);\n    const isValid = ethUtil.isValidAddress(fixed);\n    return isValid;\n}\n// Returns true if resembles hex data\n// but definitely not a valid address.\nfunction resemblesData(str) {\n    const fixed = ethUtil.addHexPrefix(str);\n    const isValidAddress = ethUtil.isValidAddress(fixed);\n    return !isValidAddress && isValidHex(str);\n}\nfunction isValidHex(data) {\n    const isString = typeof data === 'string';\n    if (!isString)\n        return false;\n    const isHexPrefixed = data.slice(0, 2) === '0x';\n    if (!isHexPrefixed)\n        return false;\n    const nonPrefixed = data.slice(2);\n    const hexRegex = /^[0-9A-Fa-f]+$/g;\n    const isValid = nonPrefixed.match(hexRegex);\n    return isValid;\n}\n"]},"metadata":{},"sourceType":"module"}