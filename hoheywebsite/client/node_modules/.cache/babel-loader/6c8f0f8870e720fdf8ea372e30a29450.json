{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ethereum_types_1 = require(\"ethereum-types\");\n\nconst ethers = require(\"ethers\");\n\nconst _ = require(\"lodash\");\n\nconst _1 = require(\".\");\n/**\n * AbiDecoder allows you to decode event logs given a set of supplied contract ABI's. It takes the contract's event\n * signature from the ABI and attempts to decode the logs using it.\n */\n\n\nclass AbiDecoder {\n  /**\n   * Instantiate an AbiDecoder\n   * @param abiArrays An array of contract ABI's\n   * @return AbiDecoder instance\n   */\n  constructor(abiArrays) {\n    this._eventIds = {};\n    this._selectorToFunctionInfo = {};\n\n    _.each(abiArrays, abi => {\n      this.addABI(abi);\n    });\n  }\n  /**\n   * Retrieves the function selector from calldata.\n   * @param calldata hex-encoded calldata.\n   * @return hex-encoded function selector.\n   */\n\n\n  static _getFunctionSelector(calldata) {\n    const functionSelectorLength = 10;\n\n    if (!calldata.startsWith('0x') || calldata.length < functionSelectorLength) {\n      throw new Error(`Malformed calldata. Must include a hex prefix '0x' and 4-byte function selector. Got '${calldata}'`);\n    }\n\n    const functionSelector = calldata.substr(0, functionSelectorLength);\n    return functionSelector;\n  }\n  /**\n   * Attempt to decode a log given the ABI's the AbiDecoder knows about.\n   * @param log The log to attempt to decode\n   * @return The decoded log if the requisite ABI was available. Otherwise the log unaltered.\n   */\n\n\n  tryToDecodeLogOrNoop(log) {\n    // Lookup event corresponding to log\n    const eventId = log.topics[0];\n    const numIndexedArgs = log.topics.length - 1;\n\n    if (this._eventIds[eventId] === undefined || this._eventIds[eventId][numIndexedArgs] === undefined) {\n      return log;\n    }\n\n    const event = this._eventIds[eventId][numIndexedArgs]; // Create decoders for indexed data\n\n    const indexedDataDecoders = _.mapValues(_.filter(event.inputs, {\n      indexed: true\n    }), input => // tslint:disable:next-line no-unnecessary-type-assertion\n    _1.AbiEncoder.create(input)); // Decode indexed data\n\n\n    const decodedIndexedData = _.map(log.topics.slice(1), // ignore first topic, which is the event id.\n    (input, i) => indexedDataDecoders[i].decode(input)); // Decode non-indexed data\n\n\n    const decodedNonIndexedData = _1.AbiEncoder.create(_.filter(event.inputs, {\n      indexed: false\n    })).decodeAsArray(log.data); // Construct DecodedLogArgs struct by mapping event parameters to their respective decoded argument.\n\n\n    const decodedArgs = {};\n    let indexedOffset = 0;\n    let nonIndexedOffset = 0;\n\n    for (const param of event.inputs) {\n      const value = param.indexed ? decodedIndexedData[indexedOffset++] : decodedNonIndexedData[nonIndexedOffset++];\n\n      if (value === undefined) {\n        return log;\n      }\n\n      decodedArgs[param.name] = value;\n    } // Decoding was successful. Return decoded log.\n\n\n    return Object.assign({}, log, {\n      event: event.name,\n      args: decodedArgs\n    });\n  }\n  /**\n   * Decodes calldata for a known ABI.\n   * @param calldata hex-encoded calldata.\n   * @param contractName used to disambiguate similar ABI's (optional).\n   * @return Decoded calldata. Includes: function name and signature, along with the decoded arguments.\n   */\n\n\n  decodeCalldataOrThrow(calldata, contractName) {\n    const functionSelector = AbiDecoder._getFunctionSelector(calldata);\n\n    const candidateFunctionInfos = this._selectorToFunctionInfo[functionSelector];\n\n    if (candidateFunctionInfos === undefined) {\n      throw new Error(`No functions registered for selector '${functionSelector}'`);\n    }\n\n    const functionInfo = _.find(candidateFunctionInfos, candidateFunctionInfo => {\n      return contractName === undefined || _.toLower(contractName) === _.toLower(candidateFunctionInfo.contractName);\n    });\n\n    if (functionInfo === undefined) {\n      throw new Error(`No function registered with selector ${functionSelector} and contract name ${contractName}.`);\n    } else if (functionInfo.abiEncoder === undefined) {\n      throw new Error(`Function ABI Encoder is not defined, for function registered with selector ${functionSelector} and contract name ${contractName}.`);\n    }\n\n    const functionName = functionInfo.abiEncoder.getDataItem().name;\n    const functionSignature = functionInfo.abiEncoder.getSignatureType();\n    const functionArguments = functionInfo.abiEncoder.decode(calldata);\n    const decodedCalldata = {\n      functionName,\n      functionSignature,\n      functionArguments\n    };\n    return decodedCalldata;\n  }\n  /**\n   * Adds a set of ABI definitions, after which calldata and logs targeting these ABI's can be decoded.\n   * Additional properties can be included to disambiguate similar ABI's. For example, if two functions\n   * have the same signature but different parameter names, then their ABI definitions can be disambiguated\n   * by specifying a contract name.\n   * @param abiDefinitions ABI definitions for a given contract.\n   * @param contractName Name of contract that encapsulates the ABI definitions (optional).\n   *                     This can be used when decoding calldata to disambiguate methods with\n   *                     the same signature but different parameter names.\n   */\n\n\n  addABI(abiArray, contractName) {\n    if (abiArray === undefined) {\n      return;\n    }\n\n    const ethersInterface = new ethers.utils.Interface(abiArray);\n\n    _.map(abiArray, abi => {\n      switch (abi.type) {\n        case ethereum_types_1.AbiType.Event:\n          // tslint:disable-next-line:no-unnecessary-type-assertion\n          this._addEventABI(abi, ethersInterface);\n\n          break;\n\n        case ethereum_types_1.AbiType.Function:\n          // tslint:disable-next-line:no-unnecessary-type-assertion\n          this._addMethodABI(abi, contractName);\n\n          break;\n\n        default:\n          // ignore other types\n          break;\n      }\n    });\n  }\n\n  _addEventABI(eventAbi, ethersInterface) {\n    const topic = ethersInterface.events[eventAbi.name].topic;\n\n    const numIndexedArgs = _.reduce(eventAbi.inputs, (sum, input) => input.indexed ? sum + 1 : sum, 0);\n\n    this._eventIds[topic] = Object.assign({}, this._eventIds[topic], {\n      [numIndexedArgs]: eventAbi\n    });\n  }\n\n  _addMethodABI(methodAbi, contractName) {\n    const abiEncoder = new _1.AbiEncoder.Method(methodAbi);\n    const functionSelector = abiEncoder.getSelector();\n\n    if (!(functionSelector in this._selectorToFunctionInfo)) {\n      this._selectorToFunctionInfo[functionSelector] = [];\n    } // Recored a copy of this ABI for each deployment\n\n\n    const functionSignature = abiEncoder.getSignature();\n\n    this._selectorToFunctionInfo[functionSelector].push({\n      functionSignature,\n      abiEncoder,\n      contractName\n    });\n  }\n\n}\n\nexports.AbiDecoder = AbiDecoder;","map":{"version":3,"sources":["../../src/abi_decoder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ethereum_types_1 = require(\"ethereum-types\");\nconst ethers = require(\"ethers\");\nconst _ = require(\"lodash\");\nconst _1 = require(\".\");\n/**\n * AbiDecoder allows you to decode event logs given a set of supplied contract ABI's. It takes the contract's event\n * signature from the ABI and attempts to decode the logs using it.\n */\nclass AbiDecoder {\n    /**\n     * Instantiate an AbiDecoder\n     * @param abiArrays An array of contract ABI's\n     * @return AbiDecoder instance\n     */\n    constructor(abiArrays) {\n        this._eventIds = {};\n        this._selectorToFunctionInfo = {};\n        _.each(abiArrays, abi => {\n            this.addABI(abi);\n        });\n    }\n    /**\n     * Retrieves the function selector from calldata.\n     * @param calldata hex-encoded calldata.\n     * @return hex-encoded function selector.\n     */\n    static _getFunctionSelector(calldata) {\n        const functionSelectorLength = 10;\n        if (!calldata.startsWith('0x') || calldata.length < functionSelectorLength) {\n            throw new Error(`Malformed calldata. Must include a hex prefix '0x' and 4-byte function selector. Got '${calldata}'`);\n        }\n        const functionSelector = calldata.substr(0, functionSelectorLength);\n        return functionSelector;\n    }\n    /**\n     * Attempt to decode a log given the ABI's the AbiDecoder knows about.\n     * @param log The log to attempt to decode\n     * @return The decoded log if the requisite ABI was available. Otherwise the log unaltered.\n     */\n    tryToDecodeLogOrNoop(log) {\n        // Lookup event corresponding to log\n        const eventId = log.topics[0];\n        const numIndexedArgs = log.topics.length - 1;\n        if (this._eventIds[eventId] === undefined || this._eventIds[eventId][numIndexedArgs] === undefined) {\n            return log;\n        }\n        const event = this._eventIds[eventId][numIndexedArgs];\n        // Create decoders for indexed data\n        const indexedDataDecoders = _.mapValues(_.filter(event.inputs, { indexed: true }), input => \n        // tslint:disable:next-line no-unnecessary-type-assertion\n        _1.AbiEncoder.create(input));\n        // Decode indexed data\n        const decodedIndexedData = _.map(log.topics.slice(1), // ignore first topic, which is the event id.\n        (input, i) => indexedDataDecoders[i].decode(input));\n        // Decode non-indexed data\n        const decodedNonIndexedData = _1.AbiEncoder.create(_.filter(event.inputs, { indexed: false })).decodeAsArray(log.data);\n        // Construct DecodedLogArgs struct by mapping event parameters to their respective decoded argument.\n        const decodedArgs = {};\n        let indexedOffset = 0;\n        let nonIndexedOffset = 0;\n        for (const param of event.inputs) {\n            const value = param.indexed\n                ? decodedIndexedData[indexedOffset++]\n                : decodedNonIndexedData[nonIndexedOffset++];\n            if (value === undefined) {\n                return log;\n            }\n            decodedArgs[param.name] = value;\n        }\n        // Decoding was successful. Return decoded log.\n        return Object.assign({}, log, { event: event.name, args: decodedArgs });\n    }\n    /**\n     * Decodes calldata for a known ABI.\n     * @param calldata hex-encoded calldata.\n     * @param contractName used to disambiguate similar ABI's (optional).\n     * @return Decoded calldata. Includes: function name and signature, along with the decoded arguments.\n     */\n    decodeCalldataOrThrow(calldata, contractName) {\n        const functionSelector = AbiDecoder._getFunctionSelector(calldata);\n        const candidateFunctionInfos = this._selectorToFunctionInfo[functionSelector];\n        if (candidateFunctionInfos === undefined) {\n            throw new Error(`No functions registered for selector '${functionSelector}'`);\n        }\n        const functionInfo = _.find(candidateFunctionInfos, candidateFunctionInfo => {\n            return (contractName === undefined || _.toLower(contractName) === _.toLower(candidateFunctionInfo.contractName));\n        });\n        if (functionInfo === undefined) {\n            throw new Error(`No function registered with selector ${functionSelector} and contract name ${contractName}.`);\n        }\n        else if (functionInfo.abiEncoder === undefined) {\n            throw new Error(`Function ABI Encoder is not defined, for function registered with selector ${functionSelector} and contract name ${contractName}.`);\n        }\n        const functionName = functionInfo.abiEncoder.getDataItem().name;\n        const functionSignature = functionInfo.abiEncoder.getSignatureType();\n        const functionArguments = functionInfo.abiEncoder.decode(calldata);\n        const decodedCalldata = {\n            functionName,\n            functionSignature,\n            functionArguments,\n        };\n        return decodedCalldata;\n    }\n    /**\n     * Adds a set of ABI definitions, after which calldata and logs targeting these ABI's can be decoded.\n     * Additional properties can be included to disambiguate similar ABI's. For example, if two functions\n     * have the same signature but different parameter names, then their ABI definitions can be disambiguated\n     * by specifying a contract name.\n     * @param abiDefinitions ABI definitions for a given contract.\n     * @param contractName Name of contract that encapsulates the ABI definitions (optional).\n     *                     This can be used when decoding calldata to disambiguate methods with\n     *                     the same signature but different parameter names.\n     */\n    addABI(abiArray, contractName) {\n        if (abiArray === undefined) {\n            return;\n        }\n        const ethersInterface = new ethers.utils.Interface(abiArray);\n        _.map(abiArray, (abi) => {\n            switch (abi.type) {\n                case ethereum_types_1.AbiType.Event:\n                    // tslint:disable-next-line:no-unnecessary-type-assertion\n                    this._addEventABI(abi, ethersInterface);\n                    break;\n                case ethereum_types_1.AbiType.Function:\n                    // tslint:disable-next-line:no-unnecessary-type-assertion\n                    this._addMethodABI(abi, contractName);\n                    break;\n                default:\n                    // ignore other types\n                    break;\n            }\n        });\n    }\n    _addEventABI(eventAbi, ethersInterface) {\n        const topic = ethersInterface.events[eventAbi.name].topic;\n        const numIndexedArgs = _.reduce(eventAbi.inputs, (sum, input) => (input.indexed ? sum + 1 : sum), 0);\n        this._eventIds[topic] = Object.assign({}, this._eventIds[topic], { [numIndexedArgs]: eventAbi });\n    }\n    _addMethodABI(methodAbi, contractName) {\n        const abiEncoder = new _1.AbiEncoder.Method(methodAbi);\n        const functionSelector = abiEncoder.getSelector();\n        if (!(functionSelector in this._selectorToFunctionInfo)) {\n            this._selectorToFunctionInfo[functionSelector] = [];\n        }\n        // Recored a copy of this ABI for each deployment\n        const functionSignature = abiEncoder.getSignature();\n        this._selectorToFunctionInfo[functionSelector].push({\n            functionSignature,\n            abiEncoder,\n            contractName,\n        });\n    }\n}\nexports.AbiDecoder = AbiDecoder;\n//# sourceMappingURL=abi_decoder.js.map"]},"metadata":{},"sourceType":"module"}