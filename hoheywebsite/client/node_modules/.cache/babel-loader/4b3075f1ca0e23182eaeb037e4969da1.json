{"ast":null,"code":"const crypto = require('crypto');\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst SDK = require('gridplus-sdk');\n\nconst keyringType = 'Lattice Hardware';\nconst HARDENED_OFFSET = 0x80000000;\nconst PER_PAGE = 5;\nconst CLOSE_CODE = -1000;\n\nclass LatticeKeyring extends EventEmitter {\n  constructor(opts = {}) {\n    super();\n    this.type = keyringType;\n\n    this._resetDefaults();\n\n    this.deserialize(opts);\n  } //-------------------------------------------------------------------\n  // Keyring API (per `https://github.com/MetaMask/eth-simple-keyring`)\n  //-------------------------------------------------------------------\n\n\n  deserialize(opts = {}) {\n    if (opts.creds) this.creds = opts.creds;\n    if (opts.accounts) this.accounts = opts.accounts;\n    if (opts.walletUID) this.walletUID = opts.walletUID;\n    if (opts.name) this.name = opts.name;\n    if (opts.network) this.network = opts.network;\n    return Promise.resolve();\n  }\n\n  serialize() {\n    return Promise.resolve({\n      creds: this.creds,\n      accounts: this.accounts,\n      walletUID: this.walletUID,\n      name: this.name,\n      network: this.network\n    });\n  }\n\n  isUnlocked() {\n    return this._hasCreds() && this._hasSession();\n  }\n\n  setHdPath() {\n    console.warn(\"setHdPath not implemented.\");\n    return;\n  } // Initialize a session with the Lattice1 device using the GridPlus SDK\n\n\n  unlock(updateData = true) {\n    return new Promise((resolve, reject) => {\n      this._getCreds().then(creds => {\n        if (creds) {\n          this.creds.deviceID = creds.deviceID;\n          this.creds.password = creds.password;\n        }\n\n        return this._initSession();\n      }).then(() => {\n        return this._connect(updateData);\n      }).then(() => {\n        return resolve('Unlocked');\n      }).catch(err => {\n        return reject(Error(err));\n      });\n    });\n  } // Add addresses to the local store and return the full result\n\n\n  addAccounts(n = 1) {\n    return new Promise((resolve, reject) => {\n      if (n === CLOSE_CODE) {\n        // Special case: use a code to forget the device. \n        // (This function is overloaded due to constraints upstream)\n        this.forgetDevice();\n        return resolve([]);\n      } else if (n <= 0) {\n        // Avoid non-positive numbers.\n        return reject('Number of accounts to add must be a positive number.');\n      } else {\n        // Normal behavior: establish the connection and fetch addresses.\n        this.unlock().then(() => {\n          return this._fetchAddresses(n, this.unlockedAccount);\n        }).then(addrs => {\n          // Splice the new account(s) into `this.accounts`\n          this.accounts.splice(this.unlockedAccount, n);\n          this.accounts.splice(this.unlockedAccount, 0, ...addrs);\n          return resolve(this.accounts);\n        }).catch(err => {\n          return reject(err);\n        });\n      }\n    });\n  } // Return the local store of addresses\n\n\n  getAccounts() {\n    return Promise.resolve(this.accounts ? this.accounts.slice() : [].slice());\n  }\n\n  signTransaction(address, tx) {\n    return new Promise((resolve, reject) => {\n      this._unlockAndFindAccount(address).then(addrIdx => {\n        // Build the Lattice request data and make request\n        const txData = {\n          chainId: tx.getChainId(),\n          nonce: Number(`0x${tx.nonce.toString('hex')}`) || 0,\n          gasPrice: Number(`0x${tx.gasPrice.toString('hex')}`),\n          gasLimit: Number(`0x${tx.gasLimit.toString('hex')}`),\n          to: `0x${tx.to.toString('hex')}`,\n          value: Number(`0x${tx.value.toString('hex')}`),\n          data: tx.data.length === 0 ? null : `0x${tx.data.toString('hex')}`,\n          signerPath: [HARDENED_OFFSET + 44, HARDENED_OFFSET + 60, HARDENED_OFFSET, 0, addrIdx]\n        };\n        return this._signTxData(txData);\n      }).then(signedTx => {\n        // Add the sig params. `signedTx = { sig: { v, r, s }, tx, txHash}`\n        if (!signedTx.sig || !signedTx.sig.v || !signedTx.sig.r || !signedTx.sig.s) return reject(Error('No signature returned'));\n        tx.v = signedTx.sig.v;\n        tx.r = Buffer.from(signedTx.sig.r, 'hex');\n        tx.s = Buffer.from(signedTx.sig.s, 'hex');\n        return resolve(tx);\n      }).catch(err => {\n        return reject(Error(err));\n      });\n    });\n  }\n\n  signPersonalMessage(address, msg) {\n    return this.signMessage(address, {\n      payload: msg,\n      protocol: 'signPersonal'\n    });\n  }\n\n  signMessage(address, msg) {\n    return new Promise((resolve, reject) => {\n      this._unlockAndFindAccount(address).then(addrIdx => {\n        const {\n          payload,\n          protocol\n        } = msg;\n        if (!payload || !protocol) return reject('`payload` and `protocol` fields must be included in the request');\n        const req = {\n          currency: 'ETH_MSG',\n          data: {\n            protocol,\n            payload,\n            signerPath: [HARDENED_OFFSET + 44, HARDENED_OFFSET + 60, HARDENED_OFFSET, 0, addrIdx]\n          }\n        };\n        if (!this._hasSession()) return reject('No SDK session started. Cannot sign transaction.');\n        this.sdkSession.sign(req, (err, res) => {\n          if (err) return reject(err);\n          if (!res.sig) return reject('No signature returned');\n          let v = (res.sig.v - 27).toString(16);\n          if (v.length < 2) v = `0${v}`;\n          return resolve(`0x${res.sig.r}${res.sig.s}${v}`);\n        });\n      });\n    });\n  }\n\n  exportAccount(address) {\n    return Promise.reject(Error('exportAccount not supported by this device'));\n  }\n\n  removeAccount(address) {\n    // We only allow one account at a time, so removing any account\n    // should result in a state reset. The user will need to reconnect\n    // to the Lattice\n    this.forgetDevice();\n  }\n\n  getFirstPage() {\n    this.page = 0;\n    return this._getPage(1);\n  }\n\n  getNextPage() {\n    return this.getFirstPage();\n  }\n\n  getPreviousPage() {\n    return this.getFirstPage();\n  }\n\n  setAccountToUnlock(index) {\n    this.unlockedAccount = parseInt(index, 10);\n  }\n\n  forgetDevice() {\n    this._resetDefaults();\n  } //-------------------------------------------------------------------\n  // Internal methods and interface to SDK\n  //-------------------------------------------------------------------\n\n\n  _unlockAndFindAccount(address) {\n    return new Promise((resolve, reject) => {\n      // NOTE: We are passing `false` here because we do NOT want\n      // state data to be updated as a result of a transaction request.\n      // It is possible the user inserted or removed a SafeCard and\n      // will not be able to sign this transaction. If that is the\n      // case, we just want to return an error message\n      this.unlock(false).then(() => {\n        return this.getAccounts();\n      }).then(addrs => {\n        // Find the signer in our current set of accounts\n        // If we can't find it, return an error\n        let addrIdx = null;\n        addrs.forEach((addr, i) => {\n          if (address.toLowerCase() === addr.toLowerCase()) addrIdx = i;\n        });\n        if (addrIdx === null) return reject('Signer not present');\n        return resolve(addrIdx);\n      }).catch(err => {\n        return reject(err);\n      });\n    });\n  }\n\n  _resetDefaults() {\n    this.accounts = [];\n    this.isLocked = true;\n    this.creds = {\n      deviceID: null,\n      password: null\n    };\n    this.walletUID = null;\n    this.sdkSession = null;\n    this.page = 0;\n    this.unlockedAccount = 0;\n    this.network = null;\n  }\n\n  _getCreds() {\n    return new Promise((resolve, reject) => {\n      // We only need to setup if we don't have a deviceID\n      if (this._hasCreds()) return resolve(); // If we are not aware of what Lattice we should be talking to,\n      // we need to open a window that lets the user go through the\n      // pairing or connection process.\n\n      const name = this.name ? this.name : 'Unknown';\n      let base = 'https://wallet.gridplus.io';\n      if (this.network && this.network !== 'mainnet') base = 'https://gridplus-web-wallet-dev.herokuapp.com';\n      let url = `${base}?keyring=${name}`;\n      if (this.network) url += `&network=${this.network}`;\n      const popup = window.open(url);\n      popup.postMessage('GET_LATTICE_CREDS', base); // PostMessage handler\n\n      function receiveMessage(event) {\n        // Ensure origin\n        if (event.origin !== base) return; // Parse response data\n\n        try {\n          const data = JSON.parse(event.data);\n          if (!data.deviceID || !data.password) return reject(Error('Invalid credentials returned from Lattice.'));\n          return resolve(data);\n        } catch (err) {\n          return reject(err);\n        }\n      }\n\n      window.addEventListener(\"message\", receiveMessage, false);\n    });\n  } // [re]connect to the Lattice. This should be done frequently to ensure\n  // the expected wallet UID is still the one active in the Lattice.\n  // This will handle SafeCard insertion/removal events.\n  // updateData - true if you want to overwrite walletUID and accounts in\n  //              the event that we find we are not synced.\n  //              If left false and we notice a new walletUID, we will\n  //              return an error.\n\n\n  _connect(updateData) {\n    return new Promise((resolve, reject) => {\n      this.sdkSession.connect(this.creds.deviceID, err => {\n        if (err) return reject(err); // Save the current wallet UID\n\n        const activeWallet = this.sdkSession.getActiveWallet();\n        if (!activeWallet || !activeWallet.uid) return reject(\"No active wallet\");\n        const newUID = activeWallet.uid.toString('hex'); // If we fetched a walletUID that does not match our current one,\n        // reset accounts and update the known UID\n\n        if (newUID != this.walletUID) {\n          // If we don't want to update data, return an error\n          if (updateData === false) return reject('Wallet has changed! Please reconnect.'); // By default we should clear out accounts and update with\n          // the new walletUID. We should NOT fill in the accounts yet,\n          // as we reserve that functionality to `addAccounts`\n\n          this.accounts = [];\n          this.walletUID = newUID;\n        }\n\n        return resolve();\n      });\n    });\n  }\n\n  _initSession() {\n    return new Promise((resolve, reject) => {\n      if (this._hasSession()) return resolve();\n\n      try {\n        let url = 'https://signing.gridpl.us';\n        if (this.network && this.network !== 'mainnet') url = 'https://signing.staging-gridpl.us';\n        const setupData = {\n          name: this.name,\n          baseUrl: url,\n          crypto,\n          timeout: 120000,\n          privKey: this._genSessionKey(),\n          network: this.network\n        };\n        this.sdkSession = new SDK.Client(setupData);\n        return resolve();\n      } catch (err) {\n        return reject(err);\n      }\n    });\n  }\n\n  _fetchAddresses(n = 1, i = 0) {\n    return new Promise((resolve, reject) => {\n      if (!this._hasSession()) return reject('No SDK session started. Cannot fetch addresses.'); // The Lattice does not allow for us to skip indices.\n\n      if (i > this.accounts.length) return reject(`Requested address is out of bounds. You may only request index <${this.accounts.length}`); // If we have already cached the address(es), we don't need to do it again\n\n      if (this.accounts.length > i) return resolve(this.accounts.slice(i, n)); // Make the request to get the requested address\n\n      const addrData = {\n        currency: 'ETH',\n        startPath: [HARDENED_OFFSET + 44, HARDENED_OFFSET + 60, HARDENED_OFFSET, 0, i],\n        n // Only request one at a time. This module only supports ETH, so no gap limits\n\n      };\n      this.sdkSession.getAddresses(addrData, (err, addrs) => {\n        if (err) return reject(Error(`Error getting addresses: ${err}`)); // Sanity check -- if this returned 0 addresses, handle the error\n\n        if (addrs.length < 1) return reject('No addresses returned'); // Return the addresses we fetched *without* updating state\n\n        return resolve(addrs);\n      });\n    });\n  }\n\n  _signTxData(txData) {\n    return new Promise((resolve, reject) => {\n      if (!this._hasSession()) return reject('No SDK session started. Cannot sign transaction.');\n      this.sdkSession.sign({\n        currency: 'ETH',\n        data: txData\n      }, (err, res) => {\n        if (err) return reject(err);\n        if (!res.tx) return reject('No transaction payload returned.');\n        return resolve(res);\n      });\n    });\n  }\n\n  _getPage(increment = 1) {\n    return new Promise((resolve, reject) => {\n      this.page += increment;\n      if (this.page <= 0) this.page = 1;\n      const start = PER_PAGE * (this.page - 1);\n      const to = PER_PAGE * this.page;\n      this.unlock().then(() => {\n        // V1: We will only support export of one (the first) address\n        return this._fetchAddresses(1, 0); //-----------\n      }).then(addrs => {\n        // Build some account objects from the addresses\n        const localAccounts = [];\n        addrs.forEach((addr, i) => {\n          localAccounts.push({\n            address: addr,\n            balance: null,\n            index: start + i\n          });\n        });\n        return resolve(localAccounts);\n      }).catch(err => {\n        return reject(err);\n      });\n    });\n  }\n\n  _hasCreds() {\n    return this.creds.deviceID !== null && this.creds.password !== null && this.name;\n  }\n\n  _hasSession() {\n    return this.sdkSession && this.walletUID;\n  }\n\n  _genSessionKey() {\n    if (!this._hasCreds()) throw new Error('No credentials -- cannot create session key!');\n    const buf = Buffer.concat([Buffer.from(this.creds.password), Buffer.from(this.creds.deviceID), Buffer.from(this.name)]);\n    return crypto.createHash('sha256').update(buf).digest();\n  }\n\n}\n\nLatticeKeyring.type = keyringType;\nmodule.exports = LatticeKeyring;","map":{"version":3,"sources":["/Users/kelvinho/Documents/Coding/HoHey-main 4 2/hoheywebsite/client/src/example/node_modules/eth-lattice-keyring/index.js"],"names":["crypto","require","EventEmitter","SDK","keyringType","HARDENED_OFFSET","PER_PAGE","CLOSE_CODE","LatticeKeyring","constructor","opts","type","_resetDefaults","deserialize","creds","accounts","walletUID","name","network","Promise","resolve","serialize","isUnlocked","_hasCreds","_hasSession","setHdPath","console","warn","unlock","updateData","reject","_getCreds","then","deviceID","password","_initSession","_connect","catch","err","Error","addAccounts","n","forgetDevice","_fetchAddresses","unlockedAccount","addrs","splice","getAccounts","slice","signTransaction","address","tx","_unlockAndFindAccount","addrIdx","txData","chainId","getChainId","nonce","Number","toString","gasPrice","gasLimit","to","value","data","length","signerPath","_signTxData","signedTx","sig","v","r","s","Buffer","from","signPersonalMessage","msg","signMessage","payload","protocol","req","currency","sdkSession","sign","res","exportAccount","removeAccount","getFirstPage","page","_getPage","getNextPage","getPreviousPage","setAccountToUnlock","index","parseInt","forEach","addr","i","toLowerCase","isLocked","base","url","popup","window","open","postMessage","receiveMessage","event","origin","JSON","parse","addEventListener","connect","activeWallet","getActiveWallet","uid","newUID","setupData","baseUrl","timeout","privKey","_genSessionKey","Client","addrData","startPath","getAddresses","increment","start","localAccounts","push","balance","buf","concat","createHash","update","digest","module","exports"],"mappings":"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","sourcesContent":["const crypto = require('crypto');\nconst EventEmitter = require('events').EventEmitter;\nconst SDK = require('gridplus-sdk');\nconst keyringType = 'Lattice Hardware';\nconst HARDENED_OFFSET = 0x80000000;\nconst PER_PAGE = 5;\nconst CLOSE_CODE = -1000;\n\nclass LatticeKeyring extends EventEmitter {\n  constructor (opts={}) {\n    super()\n    this.type = keyringType\n    this._resetDefaults();\n    this.deserialize(opts);\n  }\n\n  //-------------------------------------------------------------------\n  // Keyring API (per `https://github.com/MetaMask/eth-simple-keyring`)\n  //-------------------------------------------------------------------\n  deserialize (opts = {}) {\n    if (opts.creds)\n      this.creds = opts.creds;\n    if (opts.accounts)\n      this.accounts = opts.accounts;\n    if (opts.walletUID)\n      this.walletUID = opts.walletUID;\n    if (opts.name)\n      this.name = opts.name;\n    if (opts.network)\n      this.network = opts.network;\n    return Promise.resolve()\n  }\n\n  serialize() {\n    return Promise.resolve({\n      creds: this.creds,\n      accounts: this.accounts,\n      walletUID: this.walletUID,\n      name: this.name,\n      network: this.network,\n    })\n  }\n\n  isUnlocked () {\n    return this._hasCreds() && this._hasSession()\n  }\n\n  setHdPath() {\n    console.warn(\"setHdPath not implemented.\")\n    return;\n  }\n\n  // Initialize a session with the Lattice1 device using the GridPlus SDK\n  unlock(updateData=true) {\n    return new Promise((resolve, reject) => {\n      this._getCreds()\n      .then((creds) => {\n        if (creds) {\n          this.creds.deviceID = creds.deviceID;\n          this.creds.password = creds.password;\n        }\n        return this._initSession();\n      })\n      .then(() => {\n        return this._connect(updateData);\n      })\n      .then(() => {\n        return resolve('Unlocked');\n      })\n      .catch((err) => {\n        return reject(Error(err));\n      })\n    })\n  }\n\n  // Add addresses to the local store and return the full result\n  addAccounts(n=1) {\n    return new Promise((resolve, reject) => {\n      if (n === CLOSE_CODE) {\n        // Special case: use a code to forget the device. \n        // (This function is overloaded due to constraints upstream)\n        this.forgetDevice();\n        return resolve([]);\n      } else if (n <= 0) {\n        // Avoid non-positive numbers.\n        return reject('Number of accounts to add must be a positive number.');\n      } else {\n        // Normal behavior: establish the connection and fetch addresses.\n        this.unlock()\n        .then(() => {\n          return this._fetchAddresses(n, this.unlockedAccount)\n        })\n        .then((addrs) => {\n          // Splice the new account(s) into `this.accounts`\n          this.accounts.splice(this.unlockedAccount, n);\n          this.accounts.splice(this.unlockedAccount, 0, ...addrs);\n          return resolve(this.accounts);\n        })\n        .catch((err) => {\n          return reject(err);\n        })\n      }\n    })\n  }\n\n  // Return the local store of addresses\n  getAccounts() {\n    return Promise.resolve(this.accounts ? this.accounts.slice() : [].slice());\n  }\n\n  signTransaction (address, tx) {\n    return new Promise((resolve, reject) => {\n      this._unlockAndFindAccount(address)\n      .then((addrIdx) => {\n        // Build the Lattice request data and make request\n        const txData = {\n          chainId: tx.getChainId(),\n          nonce: Number(`0x${tx.nonce.toString('hex')}`) || 0,\n          gasPrice: Number(`0x${tx.gasPrice.toString('hex')}`),\n          gasLimit: Number(`0x${tx.gasLimit.toString('hex')}`),\n          to: `0x${tx.to.toString('hex')}`,\n          value: Number(`0x${tx.value.toString('hex')}`),\n          data: tx.data.length === 0 ? null : `0x${tx.data.toString('hex')}`,\n          signerPath: [HARDENED_OFFSET+44, HARDENED_OFFSET+60, HARDENED_OFFSET, 0, addrIdx],\n        }\n        return this._signTxData(txData)\n      })\n      .then((signedTx) => {\n        // Add the sig params. `signedTx = { sig: { v, r, s }, tx, txHash}`\n        if (!signedTx.sig || !signedTx.sig.v || !signedTx.sig.r || !signedTx.sig.s)\n          return reject(Error('No signature returned'));\n        tx.v = signedTx.sig.v;\n        tx.r = Buffer.from(signedTx.sig.r, 'hex');\n        tx.s = Buffer.from(signedTx.sig.s, 'hex');\n        return resolve(tx);\n      })\n      .catch((err) => {\n        return reject(Error(err));\n      })\n    })\n  }\n\n  signPersonalMessage(address, msg) {\n    return this.signMessage(address, { payload: msg, protocol: 'signPersonal' });\n  }\n\n  signMessage(address, msg) {\n    return new Promise((resolve, reject) => {\n      this._unlockAndFindAccount(address)\n      .then((addrIdx) => {\n        const { payload, protocol } = msg;\n        if (!payload || !protocol)\n          return reject('`payload` and `protocol` fields must be included in the request');\n        const req = {\n          currency: 'ETH_MSG',\n          data: {\n            protocol,\n            payload,\n            signerPath: [HARDENED_OFFSET+44, HARDENED_OFFSET+60, HARDENED_OFFSET, 0, addrIdx],\n          }\n        }\n        if (!this._hasSession())\n          return reject('No SDK session started. Cannot sign transaction.')\n        this.sdkSession.sign(req, (err, res) => {\n          if (err)\n            return reject(err);\n          if (!res.sig)\n            return reject('No signature returned');\n          let v = (res.sig.v - 27).toString(16);\n          if (v.length < 2)\n            v = `0${v}`;\n          return resolve(`0x${res.sig.r}${res.sig.s}${v}`);\n        })\n      })\n    })\n  }\n\n  exportAccount(address) {\n    return Promise.reject(Error('exportAccount not supported by this device'))\n  }\n\n  removeAccount(address) {\n    // We only allow one account at a time, so removing any account\n    // should result in a state reset. The user will need to reconnect\n    // to the Lattice\n    this.forgetDevice();\n  }\n\n  getFirstPage() {\n    this.page = 0;\n    return this._getPage(1);\n  }\n\n  getNextPage () {\n    return this.getFirstPage();\n  }\n\n  getPreviousPage () {\n    return this.getFirstPage();\n  }\n\n  setAccountToUnlock (index) {\n    this.unlockedAccount = parseInt(index, 10)\n  }\n\n  forgetDevice () {\n    this._resetDefaults();\n  }\n\n  //-------------------------------------------------------------------\n  // Internal methods and interface to SDK\n  //-------------------------------------------------------------------\n  _unlockAndFindAccount(address) {\n    return new Promise((resolve, reject) => {\n      // NOTE: We are passing `false` here because we do NOT want\n      // state data to be updated as a result of a transaction request.\n      // It is possible the user inserted or removed a SafeCard and\n      // will not be able to sign this transaction. If that is the\n      // case, we just want to return an error message\n      this.unlock(false)\n      .then(() => {\n        return this.getAccounts()\n      })\n      .then((addrs) => {\n        // Find the signer in our current set of accounts\n        // If we can't find it, return an error\n        let addrIdx = null;\n        addrs.forEach((addr, i) => {\n          if (address.toLowerCase() === addr.toLowerCase())\n            addrIdx = i;\n        })\n        if (addrIdx === null)\n          return reject('Signer not present');\n        return resolve(addrIdx);\n      })\n      .catch((err) => {\n        return reject(err);\n      })\n    })\n  }\n\n\n  _resetDefaults() {\n    this.accounts = [];\n    this.isLocked = true;\n    this.creds = {\n      deviceID: null,\n      password: null,\n    };\n    this.walletUID = null;\n    this.sdkSession = null;\n    this.page = 0;\n    this.unlockedAccount = 0;\n    this.network = null;\n  }\n\n  _getCreds() {\n    return new Promise((resolve, reject) => {\n      // We only need to setup if we don't have a deviceID\n      if (this._hasCreds())\n        return resolve();\n\n      // If we are not aware of what Lattice we should be talking to,\n      // we need to open a window that lets the user go through the\n      // pairing or connection process.\n      const name = this.name ? this.name : 'Unknown'\n      let base = 'https://wallet.gridplus.io';\n      if (this.network && this.network !== 'mainnet')\n        base = 'https://gridplus-web-wallet-dev.herokuapp.com';\n      let url = `${base}?keyring=${name}`;\n      if (this.network)\n        url += `&network=${this.network}`\n      const popup = window.open(url);\n      popup.postMessage('GET_LATTICE_CREDS', base);\n\n      // PostMessage handler\n      function receiveMessage(event) {\n        // Ensure origin\n        if (event.origin !== base)\n          return;\n        // Parse response data\n        try {\n          const data = JSON.parse(event.data);\n          if (!data.deviceID || !data.password)\n            return reject(Error('Invalid credentials returned from Lattice.'));\n          return resolve(data);\n        } catch (err) {\n          return reject(err);\n        }\n      }\n      window.addEventListener(\"message\", receiveMessage, false);\n    })\n  }\n\n  // [re]connect to the Lattice. This should be done frequently to ensure\n  // the expected wallet UID is still the one active in the Lattice.\n  // This will handle SafeCard insertion/removal events.\n  // updateData - true if you want to overwrite walletUID and accounts in\n  //              the event that we find we are not synced.\n  //              If left false and we notice a new walletUID, we will\n  //              return an error.\n  _connect(updateData) {\n    return new Promise((resolve, reject) => {\n      this.sdkSession.connect(this.creds.deviceID, (err) => {\n        if (err)\n          return reject(err);\n        // Save the current wallet UID\n        const activeWallet = this.sdkSession.getActiveWallet();\n        if (!activeWallet || !activeWallet.uid)\n          return reject(\"No active wallet\");\n        const newUID = activeWallet.uid.toString('hex');\n        // If we fetched a walletUID that does not match our current one,\n        // reset accounts and update the known UID\n        if (newUID != this.walletUID) {\n          // If we don't want to update data, return an error\n          if (updateData === false)\n            return reject('Wallet has changed! Please reconnect.')\n          \n          // By default we should clear out accounts and update with\n          // the new walletUID. We should NOT fill in the accounts yet,\n          // as we reserve that functionality to `addAccounts`\n          this.accounts = [];\n          this.walletUID = newUID;\n        }\n        return resolve();\n      });\n    })\n  }\n\n  _initSession() {\n    return new Promise((resolve, reject) => {\n      if (this._hasSession())\n        return resolve();\n      try {\n        let url = 'https://signing.gridpl.us';\n        if (this.network && this.network !== 'mainnet')\n          url = 'https://signing.staging-gridpl.us'\n        const setupData = {\n          name: this.name,\n          baseUrl: url,\n          crypto,\n          timeout: 120000,\n          privKey: this._genSessionKey(),\n          network: this.network\n        }\n        this.sdkSession = new SDK.Client(setupData);\n        return resolve();\n      } catch (err) {\n        return reject(err);\n      }\n    })\n  }\n\n  _fetchAddresses(n=1, i=0) {\n    return new Promise((resolve, reject) => {\n      if (!this._hasSession())\n        return reject('No SDK session started. Cannot fetch addresses.')\n\n      // The Lattice does not allow for us to skip indices.\n      if (i > this.accounts.length)\n        return reject(`Requested address is out of bounds. You may only request index <${this.accounts.length}`)\n\n      // If we have already cached the address(es), we don't need to do it again\n      if (this.accounts.length > i)\n        return resolve(this.accounts.slice(i, n));\n      \n      // Make the request to get the requested address\n      const addrData = { \n        currency: 'ETH', \n        startPath: [HARDENED_OFFSET+44, HARDENED_OFFSET+60, HARDENED_OFFSET, 0, i], \n        n, // Only request one at a time. This module only supports ETH, so no gap limits\n      }\n      this.sdkSession.getAddresses(addrData, (err, addrs) => {\n        if (err)\n          return reject(Error(`Error getting addresses: ${err}`));\n        // Sanity check -- if this returned 0 addresses, handle the error\n        if (addrs.length < 1)\n          return reject('No addresses returned');\n        // Return the addresses we fetched *without* updating state\n        return resolve(addrs);\n      })\n    })\n  }\n\n  _signTxData(txData) {\n    return new Promise((resolve, reject) => {\n      if (!this._hasSession())\n        return reject('No SDK session started. Cannot sign transaction.')\n      this.sdkSession.sign({ currency: 'ETH', data: txData }, (err, res) => {\n        if (err)\n          return reject(err);\n        if (!res.tx)\n          return reject('No transaction payload returned.');\n        return resolve(res)\n      })\n    })\n  }\n\n  _getPage(increment=1) {\n    return new Promise((resolve, reject) => {\n      this.page += increment;\n      if (this.page <= 0)\n        this.page = 1;\n      const start = PER_PAGE * (this.page - 1);\n      const to = PER_PAGE * this.page;\n\n      this.unlock()\n      .then(() => {\n        // V1: We will only support export of one (the first) address\n        return this._fetchAddresses(1, 0);\n        //-----------\n      })\n      .then((addrs) => {\n        // Build some account objects from the addresses\n        const localAccounts = [];\n        addrs.forEach((addr, i) => {\n          localAccounts.push({\n            address: addr,\n            balance: null,\n            index: start + i,\n          })\n        })\n        return resolve(localAccounts);\n      })\n      .catch((err) => {\n        return reject(err);\n      })\n    })\n  }\n\n  _hasCreds() {\n    return this.creds.deviceID !== null && this.creds.password !== null && this.name;\n  }\n\n  _hasSession() {\n    return this.sdkSession && this.walletUID;\n  }\n\n  _genSessionKey() {\n    if (!this._hasCreds())\n      throw new Error('No credentials -- cannot create session key!');\n    const buf = Buffer.concat([\n      Buffer.from(this.creds.password), \n      Buffer.from(this.creds.deviceID), \n      Buffer.from(this.name)\n    ])\n    return crypto.createHash('sha256').update(buf).digest();\n  }\n\n}\n\nLatticeKeyring.type = keyringType\nmodule.exports = LatticeKeyring;"]},"metadata":{},"sourceType":"module"}