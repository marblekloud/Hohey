{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ethereum_types_1 = require(\"ethereum-types\");\n\nconst _ = require(\"lodash\");\n\nconst configured_bignumber_1 = require(\"./configured_bignumber\"); // Note(albrow): This function is unexported in ethers.js. Copying it here for\n// now.\n// Source: https://github.com/ethers-io/ethers.js/blob/884593ab76004a808bf8097e9753fb5f8dcc3067/contracts/interface.js#L30\n\n\nfunction parseEthersParams(params) {\n  const names = [];\n  const types = [];\n  params.forEach(param => {\n    if (param.components != null) {\n      let suffix = '';\n      const arrayBracket = param.type.indexOf('[');\n\n      if (arrayBracket >= 0) {\n        suffix = param.type.substring(arrayBracket);\n      }\n\n      const result = parseEthersParams(param.components);\n      names.push({\n        name: param.name || null,\n        names: result.names\n      });\n      types.push(`tuple(${result.types.join(',')})${suffix}`);\n    } else {\n      names.push(param.name || null);\n      types.push(param.type);\n    }\n  });\n  return {\n    names,\n    types\n  };\n} // returns true if x is equal to y and false otherwise. Performs some minimal\n// type conversion and data massaging for x and y, depending on type. name and\n// type should typically be derived from parseEthersParams.\n\n\nfunction isAbiDataEqual(name, type, x, y) {\n  if (x === undefined && y === undefined) {\n    return true;\n  } else if (x === undefined && y !== undefined) {\n    return false;\n  } else if (x !== undefined && y === undefined) {\n    return false;\n  }\n\n  if (_.endsWith(type, '[]')) {\n    // For array types, we iterate through the elements and check each one\n    // individually. Strangely, name does not need to be changed in this\n    // case.\n    if (x.length !== y.length) {\n      return false;\n    }\n\n    const newType = _.trimEnd(type, '[]');\n\n    for (let i = 0; i < x.length; i++) {\n      if (!isAbiDataEqual(name, newType, x[i], y[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (_.startsWith(type, 'tuple(')) {\n    if (_.isString(name)) {\n      throw new Error('Internal error: type was tuple but names was a string');\n    } else if (name === null) {\n      throw new Error('Internal error: type was tuple but names was null');\n    } // For tuples, we iterate through the underlying values and check each\n    // one individually.\n\n\n    const types = splitTupleTypes(type);\n\n    if (types.length !== name.names.length) {\n      throw new Error(`Internal error: parameter types/names length mismatch (${types.length} != ${name.names.length})`);\n    }\n\n    for (let i = 0; i < types.length; i++) {\n      // For tuples, name is an object with a names property that is an\n      // array. As an example, for orders, name looks like:\n      //\n      //  {\n      //      name: 'orders',\n      //      names: [\n      //          'makerAddress',\n      //          // ...\n      //          'takerAssetData'\n      //      ]\n      //  }\n      //\n      const nestedName = _.isString(name.names[i]) ? name.names[i] : name.names[i].name;\n\n      if (!isAbiDataEqual(name.names[i], types[i], x[nestedName], y[nestedName])) {\n        return false;\n      }\n    }\n\n    return true;\n  } else if (type === 'address' || type === 'bytes') {\n    // HACK(albrow): ethers.js returns the checksummed address even when\n    // initially passed in a non-checksummed address. To account for that,\n    // we convert to lowercase before comparing.\n    return _.isEqual(_.toLower(x), _.toLower(y));\n  } else if (_.startsWith(type, 'uint') || _.startsWith(type, 'int')) {\n    return new configured_bignumber_1.BigNumber(x).eq(new configured_bignumber_1.BigNumber(y));\n  }\n\n  return _.isEqual(x, y);\n} // splitTupleTypes splits a tuple type string (of the form `tuple(X)` where X is\n// any other type or list of types) into its component types. It works with\n// nested tuples, so, e.g., `tuple(tuple(uint256,address),bytes32)` will yield:\n// `['tuple(uint256,address)', 'bytes32']`. It expects exactly one tuple type as\n// an argument (not an array).\n\n\nfunction splitTupleTypes(type) {\n  if (_.endsWith(type, '[]')) {\n    throw new Error('Internal error: array types are not supported');\n  } else if (!_.startsWith(type, 'tuple(')) {\n    throw new Error(`Internal error: expected tuple type but got non-tuple type: ${type}`);\n  } // Trim the outtermost tuple().\n\n\n  const trimmedType = type.substring('tuple('.length, type.length - 1);\n  const types = [];\n  let currToken = '';\n  let parenCount = 0; // Tokenize the type string while keeping track of parentheses.\n\n  for (const char of trimmedType) {\n    switch (char) {\n      case '(':\n        parenCount += 1;\n        currToken += char;\n        break;\n\n      case ')':\n        parenCount -= 1;\n        currToken += char;\n        break;\n\n      case ',':\n        if (parenCount === 0) {\n          types.push(currToken);\n          currToken = '';\n          break;\n        } else {\n          currToken += char;\n          break;\n        }\n\n      default:\n        currToken += char;\n        break;\n    }\n  }\n\n  types.push(currToken);\n  return types;\n}\n\nexports.abiUtils = {\n  parseEthersParams,\n  isAbiDataEqual,\n  splitTupleTypes,\n\n  parseFunctionParam(param) {\n    if (param.type === 'tuple') {\n      // Parse out tuple types into {type_1, type_2, ..., type_N}\n      const tupleComponents = param.components;\n\n      const paramString = _.map(tupleComponents, component => exports.abiUtils.parseFunctionParam(component));\n\n      const tupleParamString = `{${paramString}}`;\n      return tupleParamString;\n    }\n\n    return param.type;\n  },\n\n  getFunctionSignature(methodAbi) {\n    const functionName = methodAbi.name;\n\n    const parameterTypeList = _.map(methodAbi.inputs, param => exports.abiUtils.parseFunctionParam(param));\n\n    const functionSignature = `${functionName}(${parameterTypeList})`;\n    return functionSignature;\n  },\n\n  /**\n   * Solidity supports function overloading whereas TypeScript does not.\n   * See: https://solidity.readthedocs.io/en/v0.4.21/contracts.html?highlight=overload#function-overloading\n   * In order to support overloaded functions, we suffix overloaded function names with an index.\n   * This index should be deterministic, regardless of function ordering within the smart contract. To do so,\n   * we assign indexes based on the alphabetical order of function signatures.\n   *\n   * E.g\n   * ['f(uint)', 'f(uint,byte32)']\n   * Should always be renamed to:\n   * ['f1(uint)', 'f2(uint,byte32)']\n   * Regardless of the order in which these these overloaded functions are declared within the contract ABI.\n   */\n  renameOverloadedMethods(inputContractAbi) {\n    const contractAbi = _.cloneDeep(inputContractAbi);\n\n    const methodAbis = contractAbi.filter(abi => abi.type === ethereum_types_1.AbiType.Function); // Sort method Abis into alphabetical order, by function signature\n\n    const methodAbisOrdered = _.sortBy(methodAbis, [methodAbi => {\n      const functionSignature = exports.abiUtils.getFunctionSignature(methodAbi);\n      return functionSignature;\n    }]); // Group method Abis by name (overloaded methods will be grouped together, in alphabetical order)\n\n\n    const methodAbisByName = {};\n\n    _.each(methodAbisOrdered, methodAbi => {\n      (methodAbisByName[methodAbi.name] || (methodAbisByName[methodAbi.name] = [])).push(methodAbi);\n    }); // Rename overloaded methods to overloadedMethodName1, overloadedMethodName2, ...\n\n\n    _.each(methodAbisByName, methodAbisWithSameName => {\n      _.each(methodAbisWithSameName, (methodAbi, i) => {\n        if (methodAbisWithSameName.length > 1) {\n          const overloadedMethodId = i + 1;\n          const sanitizedMethodName = `${methodAbi.name}${overloadedMethodId}`;\n\n          const indexOfExistingAbiWithSanitizedMethodNameIfExists = _.findIndex(methodAbis, currentMethodAbi => currentMethodAbi.name === sanitizedMethodName);\n\n          if (indexOfExistingAbiWithSanitizedMethodNameIfExists >= 0) {\n            const methodName = methodAbi.name;\n            throw new Error(`Failed to rename overloaded method '${methodName}' to '${sanitizedMethodName}'. A method with this name already exists.`);\n          }\n\n          methodAbi.name = sanitizedMethodName;\n        }\n      });\n    });\n\n    return contractAbi;\n  }\n\n};","map":{"version":3,"sources":["../../src/abi_utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ethereum_types_1 = require(\"ethereum-types\");\nconst _ = require(\"lodash\");\nconst configured_bignumber_1 = require(\"./configured_bignumber\");\n// Note(albrow): This function is unexported in ethers.js. Copying it here for\n// now.\n// Source: https://github.com/ethers-io/ethers.js/blob/884593ab76004a808bf8097e9753fb5f8dcc3067/contracts/interface.js#L30\nfunction parseEthersParams(params) {\n    const names = [];\n    const types = [];\n    params.forEach((param) => {\n        if (param.components != null) {\n            let suffix = '';\n            const arrayBracket = param.type.indexOf('[');\n            if (arrayBracket >= 0) {\n                suffix = param.type.substring(arrayBracket);\n            }\n            const result = parseEthersParams(param.components);\n            names.push({ name: param.name || null, names: result.names });\n            types.push(`tuple(${result.types.join(',')})${suffix}`);\n        }\n        else {\n            names.push(param.name || null);\n            types.push(param.type);\n        }\n    });\n    return {\n        names,\n        types,\n    };\n}\n// returns true if x is equal to y and false otherwise. Performs some minimal\n// type conversion and data massaging for x and y, depending on type. name and\n// type should typically be derived from parseEthersParams.\nfunction isAbiDataEqual(name, type, x, y) {\n    if (x === undefined && y === undefined) {\n        return true;\n    }\n    else if (x === undefined && y !== undefined) {\n        return false;\n    }\n    else if (x !== undefined && y === undefined) {\n        return false;\n    }\n    if (_.endsWith(type, '[]')) {\n        // For array types, we iterate through the elements and check each one\n        // individually. Strangely, name does not need to be changed in this\n        // case.\n        if (x.length !== y.length) {\n            return false;\n        }\n        const newType = _.trimEnd(type, '[]');\n        for (let i = 0; i < x.length; i++) {\n            if (!isAbiDataEqual(name, newType, x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (_.startsWith(type, 'tuple(')) {\n        if (_.isString(name)) {\n            throw new Error('Internal error: type was tuple but names was a string');\n        }\n        else if (name === null) {\n            throw new Error('Internal error: type was tuple but names was null');\n        }\n        // For tuples, we iterate through the underlying values and check each\n        // one individually.\n        const types = splitTupleTypes(type);\n        if (types.length !== name.names.length) {\n            throw new Error(`Internal error: parameter types/names length mismatch (${types.length} != ${name.names.length})`);\n        }\n        for (let i = 0; i < types.length; i++) {\n            // For tuples, name is an object with a names property that is an\n            // array. As an example, for orders, name looks like:\n            //\n            //  {\n            //      name: 'orders',\n            //      names: [\n            //          'makerAddress',\n            //          // ...\n            //          'takerAssetData'\n            //      ]\n            //  }\n            //\n            const nestedName = _.isString(name.names[i])\n                ? name.names[i]\n                : name.names[i].name;\n            if (!isAbiDataEqual(name.names[i], types[i], x[nestedName], y[nestedName])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    else if (type === 'address' || type === 'bytes') {\n        // HACK(albrow): ethers.js returns the checksummed address even when\n        // initially passed in a non-checksummed address. To account for that,\n        // we convert to lowercase before comparing.\n        return _.isEqual(_.toLower(x), _.toLower(y));\n    }\n    else if (_.startsWith(type, 'uint') || _.startsWith(type, 'int')) {\n        return new configured_bignumber_1.BigNumber(x).eq(new configured_bignumber_1.BigNumber(y));\n    }\n    return _.isEqual(x, y);\n}\n// splitTupleTypes splits a tuple type string (of the form `tuple(X)` where X is\n// any other type or list of types) into its component types. It works with\n// nested tuples, so, e.g., `tuple(tuple(uint256,address),bytes32)` will yield:\n// `['tuple(uint256,address)', 'bytes32']`. It expects exactly one tuple type as\n// an argument (not an array).\nfunction splitTupleTypes(type) {\n    if (_.endsWith(type, '[]')) {\n        throw new Error('Internal error: array types are not supported');\n    }\n    else if (!_.startsWith(type, 'tuple(')) {\n        throw new Error(`Internal error: expected tuple type but got non-tuple type: ${type}`);\n    }\n    // Trim the outtermost tuple().\n    const trimmedType = type.substring('tuple('.length, type.length - 1);\n    const types = [];\n    let currToken = '';\n    let parenCount = 0;\n    // Tokenize the type string while keeping track of parentheses.\n    for (const char of trimmedType) {\n        switch (char) {\n            case '(':\n                parenCount += 1;\n                currToken += char;\n                break;\n            case ')':\n                parenCount -= 1;\n                currToken += char;\n                break;\n            case ',':\n                if (parenCount === 0) {\n                    types.push(currToken);\n                    currToken = '';\n                    break;\n                }\n                else {\n                    currToken += char;\n                    break;\n                }\n            default:\n                currToken += char;\n                break;\n        }\n    }\n    types.push(currToken);\n    return types;\n}\nexports.abiUtils = {\n    parseEthersParams,\n    isAbiDataEqual,\n    splitTupleTypes,\n    parseFunctionParam(param) {\n        if (param.type === 'tuple') {\n            // Parse out tuple types into {type_1, type_2, ..., type_N}\n            const tupleComponents = param.components;\n            const paramString = _.map(tupleComponents, component => exports.abiUtils.parseFunctionParam(component));\n            const tupleParamString = `{${paramString}}`;\n            return tupleParamString;\n        }\n        return param.type;\n    },\n    getFunctionSignature(methodAbi) {\n        const functionName = methodAbi.name;\n        const parameterTypeList = _.map(methodAbi.inputs, (param) => exports.abiUtils.parseFunctionParam(param));\n        const functionSignature = `${functionName}(${parameterTypeList})`;\n        return functionSignature;\n    },\n    /**\n     * Solidity supports function overloading whereas TypeScript does not.\n     * See: https://solidity.readthedocs.io/en/v0.4.21/contracts.html?highlight=overload#function-overloading\n     * In order to support overloaded functions, we suffix overloaded function names with an index.\n     * This index should be deterministic, regardless of function ordering within the smart contract. To do so,\n     * we assign indexes based on the alphabetical order of function signatures.\n     *\n     * E.g\n     * ['f(uint)', 'f(uint,byte32)']\n     * Should always be renamed to:\n     * ['f1(uint)', 'f2(uint,byte32)']\n     * Regardless of the order in which these these overloaded functions are declared within the contract ABI.\n     */\n    renameOverloadedMethods(inputContractAbi) {\n        const contractAbi = _.cloneDeep(inputContractAbi);\n        const methodAbis = contractAbi.filter((abi) => abi.type === ethereum_types_1.AbiType.Function);\n        // Sort method Abis into alphabetical order, by function signature\n        const methodAbisOrdered = _.sortBy(methodAbis, [\n            (methodAbi) => {\n                const functionSignature = exports.abiUtils.getFunctionSignature(methodAbi);\n                return functionSignature;\n            },\n        ]);\n        // Group method Abis by name (overloaded methods will be grouped together, in alphabetical order)\n        const methodAbisByName = {};\n        _.each(methodAbisOrdered, methodAbi => {\n            (methodAbisByName[methodAbi.name] || (methodAbisByName[methodAbi.name] = [])).push(methodAbi);\n        });\n        // Rename overloaded methods to overloadedMethodName1, overloadedMethodName2, ...\n        _.each(methodAbisByName, methodAbisWithSameName => {\n            _.each(methodAbisWithSameName, (methodAbi, i) => {\n                if (methodAbisWithSameName.length > 1) {\n                    const overloadedMethodId = i + 1;\n                    const sanitizedMethodName = `${methodAbi.name}${overloadedMethodId}`;\n                    const indexOfExistingAbiWithSanitizedMethodNameIfExists = _.findIndex(methodAbis, currentMethodAbi => currentMethodAbi.name === sanitizedMethodName);\n                    if (indexOfExistingAbiWithSanitizedMethodNameIfExists >= 0) {\n                        const methodName = methodAbi.name;\n                        throw new Error(`Failed to rename overloaded method '${methodName}' to '${sanitizedMethodName}'. A method with this name already exists.`);\n                    }\n                    methodAbi.name = sanitizedMethodName;\n                }\n            });\n        });\n        return contractAbi;\n    },\n};\n//# sourceMappingURL=abi_utils.js.map"]},"metadata":{},"sourceType":"module"}