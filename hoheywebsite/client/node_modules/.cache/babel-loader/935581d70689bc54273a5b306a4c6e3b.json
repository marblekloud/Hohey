{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ethereum_types_1 = require(\"ethereum-types\");\n\nconst configured_bignumber_1 = require(\"../../configured_bignumber\");\n\nconst blob_1 = require(\"../abstract_data_types/types/blob\");\n\nconst constants_1 = require(\"../utils/constants\");\n\nconst EncoderMath = require(\"../utils/math\");\n\nclass UIntDataType extends blob_1.AbstractBlobDataType {\n  constructor(dataItem, dataTypeFactory) {\n    super(dataItem, dataTypeFactory, UIntDataType._SIZE_KNOWN_AT_COMPILE_TIME);\n\n    if (!UIntDataType.matchType(dataItem.type)) {\n      throw new Error(`Tried to instantiate UInt with bad input: ${dataItem}`);\n    }\n\n    this._width = UIntDataType._decodeWidthFromType(dataItem.type);\n    this._maxValue = new configured_bignumber_1.BigNumber(2).exponentiatedBy(this._width).minus(1);\n  }\n\n  static matchType(type) {\n    return UIntDataType._MATCHER.test(type);\n  }\n\n  static _decodeWidthFromType(type) {\n    const matches = UIntDataType._MATCHER.exec(type);\n\n    const width = matches !== null && matches.length === 2 && matches[1] !== undefined ? parseInt(matches[1], constants_1.constants.DEC_BASE) : UIntDataType._DEFAULT_WIDTH;\n    return width;\n  }\n\n  encodeValue(value) {\n    const encodedValue = EncoderMath.safeEncodeNumericValue(value, UIntDataType._MIN_VALUE, this._maxValue);\n    return encodedValue;\n  }\n\n  decodeValue(calldata) {\n    const valueBuf = calldata.popWord();\n    const value = EncoderMath.safeDecodeNumericValue(valueBuf, UIntDataType._MIN_VALUE, this._maxValue);\n\n    if (this._width === constants_1.constants.NUMBER_OF_BYTES_IN_UINT8) {\n      return value.toNumber();\n    }\n\n    return value;\n  }\n\n  getDefaultValue() {\n    const defaultValue = UIntDataType._DEFAULT_VALUE;\n\n    if (this._width === constants_1.constants.NUMBER_OF_BYTES_IN_UINT8) {\n      return defaultValue.toNumber();\n    }\n\n    return defaultValue;\n  }\n\n  getSignatureType() {\n    return `${ethereum_types_1.SolidityTypes.Uint}${this._width}`;\n  }\n\n}\n\nUIntDataType._MATCHER = RegExp('^uint(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256){0,1}$');\nUIntDataType._SIZE_KNOWN_AT_COMPILE_TIME = true;\nUIntDataType._MAX_WIDTH = 256;\nUIntDataType._DEFAULT_WIDTH = UIntDataType._MAX_WIDTH;\nUIntDataType._MIN_VALUE = new configured_bignumber_1.BigNumber(0);\nUIntDataType._DEFAULT_VALUE = new configured_bignumber_1.BigNumber(0);\nexports.UIntDataType = UIntDataType;","map":{"version":3,"sources":["../../../../src/abi_encoder/evm_data_types/uint.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ethereum_types_1 = require(\"ethereum-types\");\nconst configured_bignumber_1 = require(\"../../configured_bignumber\");\nconst blob_1 = require(\"../abstract_data_types/types/blob\");\nconst constants_1 = require(\"../utils/constants\");\nconst EncoderMath = require(\"../utils/math\");\nclass UIntDataType extends blob_1.AbstractBlobDataType {\n    constructor(dataItem, dataTypeFactory) {\n        super(dataItem, dataTypeFactory, UIntDataType._SIZE_KNOWN_AT_COMPILE_TIME);\n        if (!UIntDataType.matchType(dataItem.type)) {\n            throw new Error(`Tried to instantiate UInt with bad input: ${dataItem}`);\n        }\n        this._width = UIntDataType._decodeWidthFromType(dataItem.type);\n        this._maxValue = new configured_bignumber_1.BigNumber(2).exponentiatedBy(this._width).minus(1);\n    }\n    static matchType(type) {\n        return UIntDataType._MATCHER.test(type);\n    }\n    static _decodeWidthFromType(type) {\n        const matches = UIntDataType._MATCHER.exec(type);\n        const width = matches !== null && matches.length === 2 && matches[1] !== undefined\n            ? parseInt(matches[1], constants_1.constants.DEC_BASE)\n            : UIntDataType._DEFAULT_WIDTH;\n        return width;\n    }\n    encodeValue(value) {\n        const encodedValue = EncoderMath.safeEncodeNumericValue(value, UIntDataType._MIN_VALUE, this._maxValue);\n        return encodedValue;\n    }\n    decodeValue(calldata) {\n        const valueBuf = calldata.popWord();\n        const value = EncoderMath.safeDecodeNumericValue(valueBuf, UIntDataType._MIN_VALUE, this._maxValue);\n        if (this._width === constants_1.constants.NUMBER_OF_BYTES_IN_UINT8) {\n            return value.toNumber();\n        }\n        return value;\n    }\n    getDefaultValue() {\n        const defaultValue = UIntDataType._DEFAULT_VALUE;\n        if (this._width === constants_1.constants.NUMBER_OF_BYTES_IN_UINT8) {\n            return defaultValue.toNumber();\n        }\n        return defaultValue;\n    }\n    getSignatureType() {\n        return `${ethereum_types_1.SolidityTypes.Uint}${this._width}`;\n    }\n}\nUIntDataType._MATCHER = RegExp('^uint(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256){0,1}$');\nUIntDataType._SIZE_KNOWN_AT_COMPILE_TIME = true;\nUIntDataType._MAX_WIDTH = 256;\nUIntDataType._DEFAULT_WIDTH = UIntDataType._MAX_WIDTH;\nUIntDataType._MIN_VALUE = new configured_bignumber_1.BigNumber(0);\nUIntDataType._DEFAULT_VALUE = new configured_bignumber_1.BigNumber(0);\nexports.UIntDataType = UIntDataType;\n//# sourceMappingURL=uint.js.map"]},"metadata":{},"sourceType":"module"}