{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ethereum_types_1 = require(\"ethereum-types\");\n\nconst ethUtil = require(\"ethereumjs-util\");\n\nconst _ = require(\"lodash\");\n\nconst blob_1 = require(\"../abstract_data_types/types/blob\");\n\nconst constants_1 = require(\"../utils/constants\");\n\nclass DynamicBytesDataType extends blob_1.AbstractBlobDataType {\n  constructor(dataItem, dataTypeFactory) {\n    super(dataItem, dataTypeFactory, DynamicBytesDataType._SIZE_KNOWN_AT_COMPILE_TIME);\n\n    if (!DynamicBytesDataType.matchType(dataItem.type)) {\n      throw new Error(`Tried to instantiate Dynamic Bytes with bad input: ${dataItem}`);\n    }\n  }\n\n  static matchType(type) {\n    return type === ethereum_types_1.SolidityTypes.Bytes;\n  }\n\n  static _sanityCheckValue(value) {\n    if (typeof value !== 'string') {\n      return;\n    }\n\n    if (!_.startsWith(value, '0x')) {\n      throw new Error(`Tried to encode non-hex value. Value must include '0x' prefix.`);\n    } else if (value.length % 2 !== 0) {\n      throw new Error(`Tried to assign ${value}, which is contains a half-byte. Use full bytes only.`);\n    }\n  } // Disable prefer-function-over-method for inherited abstract methods.\n\n  /* tslint:disable prefer-function-over-method */\n\n\n  encodeValue(value) {\n    // Encoded value is of the form: <length><value>, with each field padded to be word-aligned.\n    // 1/3 Construct the length\n    const valueBuf = ethUtil.toBuffer(value);\n    const wordsToStoreValuePadded = Math.ceil(valueBuf.byteLength / constants_1.constants.EVM_WORD_WIDTH_IN_BYTES);\n    const bytesToStoreValuePadded = wordsToStoreValuePadded * constants_1.constants.EVM_WORD_WIDTH_IN_BYTES;\n    const lengthBuf = ethUtil.toBuffer(valueBuf.byteLength);\n    const lengthBufPadded = ethUtil.setLengthLeft(lengthBuf, constants_1.constants.EVM_WORD_WIDTH_IN_BYTES); // 2/3 Construct the value\n\n    DynamicBytesDataType._sanityCheckValue(value);\n\n    const valueBufPadded = ethUtil.setLengthRight(valueBuf, bytesToStoreValuePadded); // 3/3 Combine length and value\n\n    const encodedValue = Buffer.concat([lengthBufPadded, valueBufPadded]);\n    return encodedValue;\n  }\n\n  decodeValue(calldata) {\n    // Encoded value is of the form: <length><value>, with each field padded to be word-aligned.\n    // 1/2 Decode length\n    const lengthBuf = calldata.popWord();\n    const lengthHex = ethUtil.bufferToHex(lengthBuf);\n    const length = parseInt(lengthHex, constants_1.constants.HEX_BASE); // 2/2 Decode value\n\n    const wordsToStoreValuePadded = Math.ceil(length / constants_1.constants.EVM_WORD_WIDTH_IN_BYTES);\n    const valueBufPadded = calldata.popWords(wordsToStoreValuePadded);\n    const valueBuf = valueBufPadded.slice(0, length);\n    const value = ethUtil.bufferToHex(valueBuf);\n\n    DynamicBytesDataType._sanityCheckValue(value);\n\n    return value;\n  }\n\n  getDefaultValue() {\n    return DynamicBytesDataType._DEFAULT_VALUE;\n  }\n\n  getSignatureType() {\n    return ethereum_types_1.SolidityTypes.Bytes;\n  }\n\n}\n\nDynamicBytesDataType._SIZE_KNOWN_AT_COMPILE_TIME = false;\nDynamicBytesDataType._DEFAULT_VALUE = '0x';\nexports.DynamicBytesDataType = DynamicBytesDataType;","map":{"version":3,"sources":["../../../../src/abi_encoder/evm_data_types/dynamic_bytes.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ethereum_types_1 = require(\"ethereum-types\");\nconst ethUtil = require(\"ethereumjs-util\");\nconst _ = require(\"lodash\");\nconst blob_1 = require(\"../abstract_data_types/types/blob\");\nconst constants_1 = require(\"../utils/constants\");\nclass DynamicBytesDataType extends blob_1.AbstractBlobDataType {\n    constructor(dataItem, dataTypeFactory) {\n        super(dataItem, dataTypeFactory, DynamicBytesDataType._SIZE_KNOWN_AT_COMPILE_TIME);\n        if (!DynamicBytesDataType.matchType(dataItem.type)) {\n            throw new Error(`Tried to instantiate Dynamic Bytes with bad input: ${dataItem}`);\n        }\n    }\n    static matchType(type) {\n        return type === ethereum_types_1.SolidityTypes.Bytes;\n    }\n    static _sanityCheckValue(value) {\n        if (typeof value !== 'string') {\n            return;\n        }\n        if (!_.startsWith(value, '0x')) {\n            throw new Error(`Tried to encode non-hex value. Value must include '0x' prefix.`);\n        }\n        else if (value.length % 2 !== 0) {\n            throw new Error(`Tried to assign ${value}, which is contains a half-byte. Use full bytes only.`);\n        }\n    }\n    // Disable prefer-function-over-method for inherited abstract methods.\n    /* tslint:disable prefer-function-over-method */\n    encodeValue(value) {\n        // Encoded value is of the form: <length><value>, with each field padded to be word-aligned.\n        // 1/3 Construct the length\n        const valueBuf = ethUtil.toBuffer(value);\n        const wordsToStoreValuePadded = Math.ceil(valueBuf.byteLength / constants_1.constants.EVM_WORD_WIDTH_IN_BYTES);\n        const bytesToStoreValuePadded = wordsToStoreValuePadded * constants_1.constants.EVM_WORD_WIDTH_IN_BYTES;\n        const lengthBuf = ethUtil.toBuffer(valueBuf.byteLength);\n        const lengthBufPadded = ethUtil.setLengthLeft(lengthBuf, constants_1.constants.EVM_WORD_WIDTH_IN_BYTES);\n        // 2/3 Construct the value\n        DynamicBytesDataType._sanityCheckValue(value);\n        const valueBufPadded = ethUtil.setLengthRight(valueBuf, bytesToStoreValuePadded);\n        // 3/3 Combine length and value\n        const encodedValue = Buffer.concat([lengthBufPadded, valueBufPadded]);\n        return encodedValue;\n    }\n    decodeValue(calldata) {\n        // Encoded value is of the form: <length><value>, with each field padded to be word-aligned.\n        // 1/2 Decode length\n        const lengthBuf = calldata.popWord();\n        const lengthHex = ethUtil.bufferToHex(lengthBuf);\n        const length = parseInt(lengthHex, constants_1.constants.HEX_BASE);\n        // 2/2 Decode value\n        const wordsToStoreValuePadded = Math.ceil(length / constants_1.constants.EVM_WORD_WIDTH_IN_BYTES);\n        const valueBufPadded = calldata.popWords(wordsToStoreValuePadded);\n        const valueBuf = valueBufPadded.slice(0, length);\n        const value = ethUtil.bufferToHex(valueBuf);\n        DynamicBytesDataType._sanityCheckValue(value);\n        return value;\n    }\n    getDefaultValue() {\n        return DynamicBytesDataType._DEFAULT_VALUE;\n    }\n    getSignatureType() {\n        return ethereum_types_1.SolidityTypes.Bytes;\n    }\n}\nDynamicBytesDataType._SIZE_KNOWN_AT_COMPILE_TIME = false;\nDynamicBytesDataType._DEFAULT_VALUE = '0x';\nexports.DynamicBytesDataType = DynamicBytesDataType;\n//# sourceMappingURL=dynamic_bytes.js.map"]},"metadata":{},"sourceType":"module"}