{"ast":null,"code":"import { AbstractConnector } from '@web3-react/abstract-connector';\nimport Web3ProviderEngine from 'web3-provider-engine';\nimport { LatticeSubprovider } from '@0x/subproviders/lib/src/subproviders/lattice';\nimport CacheSubprovider from 'web3-provider-engine/subproviders/cache.js';\nimport { RPCSubprovider } from '@0x/subproviders/lib/src/subproviders/rpc_subprovider';\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar LatticeConnector = /*#__PURE__*/function (_AbstractConnector) {\n  _inheritsLoose(LatticeConnector, _AbstractConnector);\n\n  function LatticeConnector(_ref) {\n    var _this;\n\n    var chainId = _ref.chainId,\n        url = _ref.url,\n        pollingInterval = _ref.pollingInterval,\n        requestTimeoutMs = _ref.requestTimeoutMs,\n        appName = _ref.appName;\n    _this = _AbstractConnector.call(this, {\n      supportedChainIds: [chainId]\n    }) || this;\n    _this.chainId = chainId;\n    _this.url = url;\n    _this.pollingInterval = pollingInterval;\n    _this.requestTimeoutMs = requestTimeoutMs;\n    _this.appName = appName;\n    return _this;\n  }\n\n  var _proto = LatticeConnector.prototype;\n\n  _proto.activate = function activate() {\n    try {\n      var _temp3 = function _temp3() {\n        _this3.provider.start();\n\n        return {\n          provider: _this3.provider,\n          chainId: _this3.chainId\n        };\n      };\n\n      var _this3 = this;\n\n      var _temp4 = function () {\n        if (!_this3.provider) {\n          return Promise.resolve(import('eth-lattice-keyring').then(function (m) {\n            var _m$default;\n\n            return (_m$default = m == null ? void 0 : m[\"default\"]) != null ? _m$default : m;\n          })).then(function (LatticeKeyring) {\n            var engine = new Web3ProviderEngine({\n              pollingInterval: _this3.pollingInterval\n            });\n            var opts = {\n              appName: _this3.appName,\n              latticeConnectClient: LatticeKeyring,\n              networkId: _this3.chainId\n            };\n            engine.addProvider(new LatticeSubprovider(opts));\n            engine.addProvider(new CacheSubprovider());\n            engine.addProvider(new RPCSubprovider(_this3.url, _this3.requestTimeoutMs));\n            _this3.provider = engine;\n          });\n        }\n      }();\n\n      return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp3) : _temp3(_temp4));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.getProvider = function getProvider() {\n    try {\n      var _this5 = this;\n\n      return Promise.resolve(_this5.provider);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.getChainId = function getChainId() {\n    try {\n      var _this7 = this;\n\n      return Promise.resolve(_this7.chainId);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.getAccount = function getAccount() {\n    try {\n      var _this9 = this;\n\n      return Promise.resolve(_this9.provider._providers[0].getAccountsAsync(1).then(function (accounts) {\n        return accounts[0];\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.deactivate = function deactivate() {\n    this.provider.stop();\n  };\n\n  _proto.close = function close() {\n    try {\n      var _this11 = this;\n\n      _this11.emitDeactivate(); // Due to limitations in the LatticeSubprovider API, we use this code with `getAccounts`\n      // as a hack to allow us to close out the connection and forget data.\n      // It will get handled in `eth-lattice-keyring`, which will forget the device and return\n      // an empty array (whose first element will be null/undefined)\n\n\n      var CLOSE_CODE = -1000;\n      return Promise.resolve(_this11.provider._providers[0].getAccountsAsync(CLOSE_CODE).then(function (accounts) {\n        return accounts[0];\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  return LatticeConnector;\n}(AbstractConnector);\n\nexport { LatticeConnector };","map":{"version":3,"sources":["../src/index.ts"],"names":["LatticeConnector","chainId","url","pollingInterval","requestTimeoutMs","appName","supportedChainIds","provider","LatticeKeyring","m","engine","opts","latticeConnectClient","networkId","accounts","deactivate","CLOSE_CODE"],"mappings":"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","sourcesContent":["import { ConnectorUpdate } from '@web3-react/types'\nimport { AbstractConnector } from '@web3-react/abstract-connector'\nimport Web3ProviderEngine from 'web3-provider-engine'\nimport { LatticeSubprovider } from '@0x/subproviders/lib/src/subproviders/lattice'\nimport CacheSubprovider from 'web3-provider-engine/subproviders/cache.js'\nimport { RPCSubprovider } from '@0x/subproviders/lib/src/subproviders/rpc_subprovider' // https://github.com/0xProject/0x-monorepo/issues/1400\n\ninterface LatticeConnectorArguments {\n  chainId: number\n  url: string\n  pollingInterval?: number\n  requestTimeoutMs?: number\n  appName: string\n}\n\nexport class LatticeConnector extends AbstractConnector {\n  private readonly chainId: number\n  private readonly url: string\n  private readonly pollingInterval?: number\n  private readonly requestTimeoutMs?: number\n  private readonly appName: string\n  private provider: any\n\n  constructor({ chainId, url, pollingInterval, requestTimeoutMs, appName }: LatticeConnectorArguments) {\n    super({ supportedChainIds: [chainId] })\n\n    this.chainId = chainId\n    this.url = url\n    this.pollingInterval = pollingInterval\n    this.requestTimeoutMs = requestTimeoutMs\n    this.appName = appName\n  }\n\n  public async activate(): Promise<ConnectorUpdate> {\n    if (!this.provider) {\n      const LatticeKeyring = await import('eth-lattice-keyring').then(m => m?.default ?? m)\n      const engine = new Web3ProviderEngine({ pollingInterval: this.pollingInterval })\n      const opts = {\n        appName: this.appName,\n        latticeConnectClient: LatticeKeyring,\n        networkId: this.chainId\n      }\n      engine.addProvider(new LatticeSubprovider(opts))\n      engine.addProvider(new CacheSubprovider())\n      engine.addProvider(new RPCSubprovider(this.url, this.requestTimeoutMs))\n      this.provider = engine\n    }\n\n    this.provider.start()\n\n    return { provider: this.provider, chainId: this.chainId }\n  }\n\n  public async getProvider(): Promise<Web3ProviderEngine> {\n    return this.provider\n  }\n\n  public async getChainId(): Promise<number> {\n    return this.chainId\n  }\n\n  public async getAccount(): Promise<null> {\n    return this.provider._providers[0].getAccountsAsync(1).then((accounts: string[]): string => accounts[0])\n  }\n\n  public deactivate() {\n    this.provider.stop()\n  }\n\n  public async close(): Promise<null> {\n    this.emitDeactivate()\n    // Due to limitations in the LatticeSubprovider API, we use this code with `getAccounts`\n    // as a hack to allow us to close out the connection and forget data.\n    // It will get handled in `eth-lattice-keyring`, which will forget the device and return\n    // an empty array (whose first element will be null/undefined)\n    const CLOSE_CODE = -1000\n    return this.provider._providers[0].getAccountsAsync(CLOSE_CODE).then((accounts: string[]): string => accounts[0])\n  }\n}\n"]},"metadata":{},"sourceType":"module"}