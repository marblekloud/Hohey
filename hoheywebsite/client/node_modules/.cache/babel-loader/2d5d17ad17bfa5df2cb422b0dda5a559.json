{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ethUtil = require(\"ethereumjs-util\");\n\nconst _ = require(\"lodash\");\n\nconst constants_1 = require(\"../utils/constants\");\n\nconst pointer_1 = require(\"./blocks/pointer\");\n\nconst set_1 = require(\"./blocks/set\");\n\nconst iterator_1 = require(\"./iterator\");\n\nclass Calldata {\n  constructor(rules) {\n    this._rules = rules;\n    this._selector = '';\n    this._root = undefined;\n  }\n  /**\n   * Sets the root calldata block. This block usually corresponds to a Method.\n   */\n\n\n  setRoot(block) {\n    this._root = block;\n  }\n  /**\n   * Sets the selector to be prepended onto the calldata.\n   * If the root block was created by a Method then a selector will likely be set.\n   */\n\n\n  setSelector(selector) {\n    if (!_.startsWith(selector, '0x')) {\n      throw new Error(`Expected selector to be hex. Missing prefix '0x'`);\n    } else if (selector.length !== constants_1.constants.HEX_SELECTOR_LENGTH_IN_CHARS) {\n      throw new Error(`Invalid selector '${selector}'`);\n    }\n\n    this._selector = selector;\n  }\n  /**\n   * Iterates through the calldata blocks, starting from the root block, to construct calldata as a hex string.\n   * If the `optimize` flag is set then this calldata will be condensed, to save gas.\n   * If the `annotate` flag is set then this will return human-readable calldata.\n   * If the `annotate` flag is *not* set then this will return EVM-compatible calldata.\n   */\n\n\n  toString() {\n    // Sanity check: root block must be set\n    if (this._root === undefined) {\n      throw new Error('expected root');\n    } // Optimize, if flag set\n\n\n    if (this._rules.shouldOptimize) {\n      this._optimize();\n    } // Set offsets\n\n\n    const iterator = new iterator_1.CalldataIterator(this._root);\n    let offset = 0;\n\n    for (const block of iterator) {\n      block.setOffset(offset);\n      offset += block.getSizeInBytes();\n    } // Generate hex string\n\n\n    const hexString = this._rules.shouldAnnotate ? this._toHumanReadableCallData() : this._toEvmCompatibeCallDataHex();\n    return hexString;\n  }\n  /**\n   * There are three types of calldata blocks: Blob, Set and Pointer.\n   * Scenarios arise where distinct pointers resolve to identical values.\n   * We optimize by keeping only one such instance of the identical value, and redirecting all pointers here.\n   * We keep the last such duplicate value because pointers can only be positive (they cannot point backwards).\n   *\n   * Example #1:\n   *  function f(string[], string[])\n   *  f([\"foo\", \"bar\", \"blitz\"], [\"foo\", \"bar\", \"blitz\"])\n   *  The array [\"foo\", \"bar\", \"blitz\"] will only be included in the calldata once.\n   *\n   * Example #2:\n   *  function f(string[], string)\n   *  f([\"foo\", \"bar\", \"blitz\"], \"foo\")\n   *  The string \"foo\" will only be included in the calldata once.\n   *\n   * Example #3:\n   *  function f((string, uint, bytes), string, uint, bytes)\n   *  f((\"foo\", 5, \"0x05\"), \"foo\", 5, \"0x05\")\n   *  The string \"foo\" and bytes \"0x05\" will only be included in the calldata once.\n   *  The duplicate `uint 5` values cannot be optimized out because they are static values (no pointer points to them).\n   *\n   * @TODO #1:\n   *   This optimization strategy handles blocks that are exact duplicates of one another.\n   *   But what if some block is a combination of two other blocks? Or a subset of another block?\n   *   This optimization problem is not much different from the current implemetation.\n   *   Instead of tracking \"observed\" hashes, at each node we would simply do pattern-matching on the calldata.\n   *   This strategy would be applied after assigning offsets to the tree, rather than before (as in this strategy).\n   *   Note that one consequence of this strategy is pointers may resolve to offsets that are not word-aligned.\n   *   This shouldn't be a problem but further investigation should be done.\n   *\n   * @TODO #2:\n   *   To be done as a follow-up to @TODO #1.\n   *   Since we optimize from the bottom-up, we could be affecting the outcome of a later potential optimization.\n   *   For example, what if by removing one duplicate value we miss out on optimizing another block higher in the tree.\n   *   To handle this case, at each node we can store a candidate optimization in a priority queue (sorted by calldata size).\n   *   At the end of traversing the tree, the candidate at the front of the queue will be the most optimal output.\n   *\n   */\n\n\n  _optimize() {\n    // Step 1/1 Create a reverse iterator (starts from the end of the calldata to the beginning)\n    if (this._root === undefined) {\n      throw new Error('expected root');\n    }\n\n    const iterator = new iterator_1.ReverseCalldataIterator(this._root); // Step 2/2 Iterate over each block, keeping track of which blocks have been seen and pruning redundant blocks.\n\n    const blocksByHash = {};\n\n    for (const block of iterator) {\n      // If a block is a pointer and its value has already been observed, then update\n      // the pointer to resolve to the existing value.\n      if (block instanceof pointer_1.PointerCalldataBlock) {\n        const dependencyBlockHashBuf = block.getDependency().computeHash();\n        const dependencyBlockHash = ethUtil.bufferToHex(dependencyBlockHashBuf);\n\n        if (dependencyBlockHash in blocksByHash) {\n          const blockWithSameHash = blocksByHash[dependencyBlockHash];\n\n          if (blockWithSameHash !== block.getDependency()) {\n            block.setAlias(blockWithSameHash);\n          }\n        }\n\n        continue;\n      } // This block has not been seen. Record its hash.\n\n\n      const blockHashBuf = block.computeHash();\n      const blockHash = ethUtil.bufferToHex(blockHashBuf);\n\n      if (!(blockHash in blocksByHash)) {\n        blocksByHash[blockHash] = block;\n      }\n    }\n  }\n\n  _toEvmCompatibeCallDataHex() {\n    // Sanity check: must have a root block.\n    if (this._root === undefined) {\n      throw new Error('expected root');\n    } // Construct an array of buffers (one buffer for each block).\n\n\n    const selectorBuffer = ethUtil.toBuffer(this._selector);\n    const valueBufs = [selectorBuffer];\n    const iterator = new iterator_1.CalldataIterator(this._root);\n\n    for (const block of iterator) {\n      valueBufs.push(block.toBuffer());\n    } // Create hex from buffer array.\n\n\n    const combinedBuffers = Buffer.concat(valueBufs);\n    const hexValue = ethUtil.bufferToHex(combinedBuffers);\n    return hexValue;\n  }\n  /**\n   * Returns human-readable calldata.\n   *\n   * Example:\n   *   simpleFunction(string[], string[])\n   *   strings = [\"Hello\", \"World\"]\n   *   simpleFunction(strings, strings)\n   *\n   * Output:\n   *   0xbb4f12e3\n   *                                                                                      ### simpleFunction\n   *   0x0       0000000000000000000000000000000000000000000000000000000000000040              ptr<array1> (alias for array2)\n   *   0x20      0000000000000000000000000000000000000000000000000000000000000040              ptr<array2>\n   *\n   *   0x40      0000000000000000000000000000000000000000000000000000000000000002          ### array2\n   *   0x60      0000000000000000000000000000000000000000000000000000000000000040              ptr<array2[0]>\n   *   0x80      0000000000000000000000000000000000000000000000000000000000000080              ptr<array2[1]>\n   *   0xa0      0000000000000000000000000000000000000000000000000000000000000005              array2[0]\n   *   0xc0      48656c6c6f000000000000000000000000000000000000000000000000000000\n   *   0xe0      0000000000000000000000000000000000000000000000000000000000000005              array2[1]\n   *   0x100     576f726c64000000000000000000000000000000000000000000000000000000\n   */\n\n\n  _toHumanReadableCallData() {\n    // Sanity check: must have a root block.\n    if (this._root === undefined) {\n      throw new Error('expected root');\n    } // Constants for constructing annotated string\n\n\n    const offsetPadding = 10;\n    const valuePadding = 74;\n    const namePadding = 80;\n    const evmWordStartIndex = 0;\n    const emptySize = 0; // Construct annotated calldata\n\n    let hexValue = `${this._selector}`;\n    let offset = 0;\n\n    const functionName = this._root.getName();\n\n    const iterator = new iterator_1.CalldataIterator(this._root);\n\n    for (const block of iterator) {\n      // Process each block 1 word at a time\n      const size = block.getSizeInBytes();\n      const name = block.getName();\n      const parentName = block.getParentName();\n      const prettyName = name.replace(`${parentName}.`, '').replace(`${functionName}.`, ''); // Resulting line will be <offsetStr><valueStr><nameStr>\n\n      let offsetStr = '';\n      let valueStr = '';\n      let nameStr = '';\n      let lineStr = '';\n\n      if (size === emptySize) {\n        // This is a Set block with no header.\n        // For example, a tuple or an array with a defined length.\n        offsetStr = ' '.repeat(offsetPadding);\n        valueStr = ' '.repeat(valuePadding);\n        nameStr = `### ${prettyName.padEnd(namePadding)}`;\n        lineStr = `\\n${offsetStr}${valueStr}${nameStr}`;\n      } else {\n        // This block has at least one word of value.\n        offsetStr = `0x${offset.toString(constants_1.constants.HEX_BASE)}`.padEnd(offsetPadding);\n        valueStr = ethUtil.stripHexPrefix(ethUtil.bufferToHex(block.toBuffer().slice(evmWordStartIndex, constants_1.constants.EVM_WORD_WIDTH_IN_BYTES))).padEnd(valuePadding);\n\n        if (block instanceof set_1.SetCalldataBlock) {\n          nameStr = `### ${prettyName.padEnd(namePadding)}`;\n          lineStr = `\\n${offsetStr}${valueStr}${nameStr}`;\n        } else {\n          nameStr = `    ${prettyName.padEnd(namePadding)}`;\n          lineStr = `${offsetStr}${valueStr}${nameStr}`;\n        }\n      } // This block has a value that is more than 1 word.\n\n\n      for (let j = constants_1.constants.EVM_WORD_WIDTH_IN_BYTES; j < size; j += constants_1.constants.EVM_WORD_WIDTH_IN_BYTES) {\n        offsetStr = `0x${(offset + j).toString(constants_1.constants.HEX_BASE)}`.padEnd(offsetPadding);\n        valueStr = ethUtil.stripHexPrefix(ethUtil.bufferToHex(block.toBuffer().slice(j, j + constants_1.constants.EVM_WORD_WIDTH_IN_BYTES))).padEnd(valuePadding);\n        nameStr = ' '.repeat(namePadding);\n        lineStr = `${lineStr}\\n${offsetStr}${valueStr}${nameStr}`;\n      } // Append to hex value\n\n\n      hexValue = `${hexValue}\\n${lineStr}`;\n      offset += size;\n    }\n\n    return hexValue;\n  }\n\n}\n\nexports.Calldata = Calldata;","map":{"version":3,"sources":["../../../../src/abi_encoder/calldata/calldata.ts"],"names":[],"mappings":";;;;;;AAAA,MAAA,OAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AACA,MAAA,CAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AAEA,MAAA,WAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;;AAGA,MAAA,SAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;;AACA,MAAA,KAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;AAEA,MAAA,UAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AAEA,MAAa,QAAb,CAAqB;AAKjB,EAAA,WAAA,CAAmB,KAAnB,EAAuC;AACnC,SAAK,MAAL,GAAc,KAAd;AACA,SAAK,SAAL,GAAiB,EAAjB;AACA,SAAK,KAAL,GAAa,SAAb;AACH;AACD;;AAEG;;;AACI,EAAA,OAAO,CAAC,KAAD,EAAqB;AAC/B,SAAK,KAAL,GAAa,KAAb;AACH;AACD;;;AAGG;;;AACI,EAAA,WAAW,CAAC,QAAD,EAAiB;AAC/B,QAAI,CAAC,CAAC,CAAC,UAAF,CAAa,QAAb,EAAuB,IAAvB,CAAL,EAAmC;AAC/B,YAAM,IAAI,KAAJ,CAAU,kDAAV,CAAN;AACH,KAFD,MAEO,IAAI,QAAQ,CAAC,MAAT,KAAoB,WAAA,CAAA,SAAA,CAAU,4BAAlC,EAAgE;AACnE,YAAM,IAAI,KAAJ,CAAU,qBAAqB,QAAQ,GAAvC,CAAN;AACH;;AACD,SAAK,SAAL,GAAiB,QAAjB;AACH;AACD;;;;;AAKG;;;AACI,EAAA,QAAQ,GAAA;AACX;AACA,QAAI,KAAK,KAAL,KAAe,SAAnB,EAA8B;AAC1B,YAAM,IAAI,KAAJ,CAAU,eAAV,CAAN;AACH,KAJU,CAKX;;;AACA,QAAI,KAAK,MAAL,CAAY,cAAhB,EAAgC;AAC5B,WAAK,SAAL;AACH,KARU,CASX;;;AACA,UAAM,QAAQ,GAAG,IAAI,UAAA,CAAA,gBAAJ,CAAqB,KAAK,KAA1B,CAAjB;AACA,QAAI,MAAM,GAAG,CAAb;;AACA,SAAK,MAAM,KAAX,IAAoB,QAApB,EAA8B;AAC1B,MAAA,KAAK,CAAC,SAAN,CAAgB,MAAhB;AACA,MAAA,MAAM,IAAI,KAAK,CAAC,cAAN,EAAV;AACH,KAfU,CAgBX;;;AACA,UAAM,SAAS,GAAG,KAAK,MAAL,CAAY,cAAZ,GACZ,KAAK,wBAAL,EADY,GAEZ,KAAK,0BAAL,EAFN;AAGA,WAAO,SAAP;AACH;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsCG;;;AACK,EAAA,SAAS,GAAA;AACb;AACA,QAAI,KAAK,KAAL,KAAe,SAAnB,EAA8B;AAC1B,YAAM,IAAI,KAAJ,CAAU,eAAV,CAAN;AACH;;AACD,UAAM,QAAQ,GAAG,IAAI,UAAA,CAAA,uBAAJ,CAA4B,KAAK,KAAjC,CAAjB,CALa,CAMb;;AACA,UAAM,YAAY,GAAqC,EAAvD;;AACA,SAAK,MAAM,KAAX,IAAoB,QAApB,EAA8B;AAC1B;AACA;AACA,UAAI,KAAK,YAAY,SAAA,CAAA,oBAArB,EAA2C;AACvC,cAAM,sBAAsB,GAAG,KAAK,CAAC,aAAN,GAAsB,WAAtB,EAA/B;AACA,cAAM,mBAAmB,GAAG,OAAO,CAAC,WAAR,CAAoB,sBAApB,CAA5B;;AACA,YAAI,mBAAmB,IAAI,YAA3B,EAAyC;AACrC,gBAAM,iBAAiB,GAAG,YAAY,CAAC,mBAAD,CAAtC;;AACA,cAAI,iBAAiB,KAAK,KAAK,CAAC,aAAN,EAA1B,EAAiD;AAC7C,YAAA,KAAK,CAAC,QAAN,CAAe,iBAAf;AACH;AACJ;;AACD;AACH,OAbyB,CAc1B;;;AACA,YAAM,YAAY,GAAG,KAAK,CAAC,WAAN,EAArB;AACA,YAAM,SAAS,GAAG,OAAO,CAAC,WAAR,CAAoB,YAApB,CAAlB;;AACA,UAAI,EAAE,SAAS,IAAI,YAAf,CAAJ,EAAkC;AAC9B,QAAA,YAAY,CAAC,SAAD,CAAZ,GAA0B,KAA1B;AACH;AACJ;AACJ;;AACO,EAAA,0BAA0B,GAAA;AAC9B;AACA,QAAI,KAAK,KAAL,KAAe,SAAnB,EAA8B;AAC1B,YAAM,IAAI,KAAJ,CAAU,eAAV,CAAN;AACH,KAJ6B,CAK9B;;;AACA,UAAM,cAAc,GAAG,OAAO,CAAC,QAAR,CAAiB,KAAK,SAAtB,CAAvB;AACA,UAAM,SAAS,GAAa,CAAC,cAAD,CAA5B;AACA,UAAM,QAAQ,GAAG,IAAI,UAAA,CAAA,gBAAJ,CAAqB,KAAK,KAA1B,CAAjB;;AACA,SAAK,MAAM,KAAX,IAAoB,QAApB,EAA8B;AAC1B,MAAA,SAAS,CAAC,IAAV,CAAe,KAAK,CAAC,QAAN,EAAf;AACH,KAX6B,CAY9B;;;AACA,UAAM,eAAe,GAAG,MAAM,CAAC,MAAP,CAAc,SAAd,CAAxB;AACA,UAAM,QAAQ,GAAG,OAAO,CAAC,WAAR,CAAoB,eAApB,CAAjB;AACA,WAAO,QAAP;AACH;AACD;;;;;;;;;;;;;;;;;;;;;AAqBG;;;AACK,EAAA,wBAAwB,GAAA;AAC5B;AACA,QAAI,KAAK,KAAL,KAAe,SAAnB,EAA8B;AAC1B,YAAM,IAAI,KAAJ,CAAU,eAAV,CAAN;AACH,KAJ2B,CAK5B;;;AACA,UAAM,aAAa,GAAG,EAAtB;AACA,UAAM,YAAY,GAAG,EAArB;AACA,UAAM,WAAW,GAAG,EAApB;AACA,UAAM,iBAAiB,GAAG,CAA1B;AACA,UAAM,SAAS,GAAG,CAAlB,CAV4B,CAW5B;;AACA,QAAI,QAAQ,GAAG,GAAG,KAAK,SAAS,EAAhC;AACA,QAAI,MAAM,GAAG,CAAb;;AACA,UAAM,YAAY,GAAW,KAAK,KAAL,CAAW,OAAX,EAA7B;;AACA,UAAM,QAAQ,GAAG,IAAI,UAAA,CAAA,gBAAJ,CAAqB,KAAK,KAA1B,CAAjB;;AACA,SAAK,MAAM,KAAX,IAAoB,QAApB,EAA8B;AAC1B;AACA,YAAM,IAAI,GAAG,KAAK,CAAC,cAAN,EAAb;AACA,YAAM,IAAI,GAAG,KAAK,CAAC,OAAN,EAAb;AACA,YAAM,UAAU,GAAG,KAAK,CAAC,aAAN,EAAnB;AACA,YAAM,UAAU,GAAG,IAAI,CAAC,OAAL,CAAa,GAAG,UAAU,GAA1B,EAA+B,EAA/B,EAAmC,OAAnC,CAA2C,GAAG,YAAY,GAA1D,EAA+D,EAA/D,CAAnB,CAL0B,CAM1B;;AACA,UAAI,SAAS,GAAG,EAAhB;AACA,UAAI,QAAQ,GAAG,EAAf;AACA,UAAI,OAAO,GAAG,EAAd;AACA,UAAI,OAAO,GAAG,EAAd;;AACA,UAAI,IAAI,KAAK,SAAb,EAAwB;AACpB;AACA;AACA,QAAA,SAAS,GAAG,IAAI,MAAJ,CAAW,aAAX,CAAZ;AACA,QAAA,QAAQ,GAAG,IAAI,MAAJ,CAAW,YAAX,CAAX;AACA,QAAA,OAAO,GAAG,OAAO,UAAU,CAAC,MAAX,CAAkB,WAAlB,CAA8B,EAA/C;AACA,QAAA,OAAO,GAAG,KAAK,SAAS,GAAG,QAAQ,GAAG,OAAO,EAA7C;AACH,OAPD,MAOO;AACH;AACA,QAAA,SAAS,GAAG,KAAK,MAAM,CAAC,QAAP,CAAgB,WAAA,CAAA,SAAA,CAAU,QAA1B,CAAmC,EAAxC,CAA2C,MAA3C,CAAkD,aAAlD,CAAZ;AACA,QAAA,QAAQ,GAAG,OAAO,CACb,cADM,CAEH,OAAO,CAAC,WAAR,CACI,KAAK,CAAC,QAAN,GAAiB,KAAjB,CAAuB,iBAAvB,EAA0C,WAAA,CAAA,SAAA,CAAU,uBAApD,CADJ,CAFG,EAMN,MANM,CAMC,YAND,CAAX;;AAOA,YAAI,KAAK,YAAY,KAAA,CAAA,gBAArB,EAAuC;AACnC,UAAA,OAAO,GAAG,OAAO,UAAU,CAAC,MAAX,CAAkB,WAAlB,CAA8B,EAA/C;AACA,UAAA,OAAO,GAAG,KAAK,SAAS,GAAG,QAAQ,GAAG,OAAO,EAA7C;AACH,SAHD,MAGO;AACH,UAAA,OAAO,GAAG,OAAO,UAAU,CAAC,MAAX,CAAkB,WAAlB,CAA8B,EAA/C;AACA,UAAA,OAAO,GAAG,GAAG,SAAS,GAAG,QAAQ,GAAG,OAAO,EAA3C;AACH;AACJ,OAnCyB,CAoC1B;;;AACA,WAAK,IAAI,CAAC,GAAG,WAAA,CAAA,SAAA,CAAU,uBAAvB,EAAgD,CAAC,GAAG,IAApD,EAA0D,CAAC,IAAI,WAAA,CAAA,SAAA,CAAU,uBAAzE,EAAkG;AAC9F,QAAA,SAAS,GAAG,KAAK,CAAC,MAAM,GAAG,CAAV,EAAa,QAAb,CAAsB,WAAA,CAAA,SAAA,CAAU,QAAhC,CAAyC,EAA9C,CAAiD,MAAjD,CAAwD,aAAxD,CAAZ;AACA,QAAA,QAAQ,GAAG,OAAO,CACb,cADM,CAEH,OAAO,CAAC,WAAR,CAAoB,KAAK,CAAC,QAAN,GAAiB,KAAjB,CAAuB,CAAvB,EAA0B,CAAC,GAAG,WAAA,CAAA,SAAA,CAAU,uBAAxC,CAApB,CAFG,EAIN,MAJM,CAIC,YAJD,CAAX;AAKA,QAAA,OAAO,GAAG,IAAI,MAAJ,CAAW,WAAX,CAAV;AACA,QAAA,OAAO,GAAG,GAAG,OAAO,KAAK,SAAS,GAAG,QAAQ,GAAG,OAAO,EAAvD;AACH,OA9CyB,CA+C1B;;;AACA,MAAA,QAAQ,GAAG,GAAG,QAAQ,KAAK,OAAO,EAAlC;AACA,MAAA,MAAM,IAAI,IAAV;AACH;;AACD,WAAO,QAAP;AACH;;AAxOgB;;AAArB,OAAA,CAAA,QAAA,GAAA,QAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ethUtil = require(\"ethereumjs-util\");\nconst _ = require(\"lodash\");\nconst constants_1 = require(\"../utils/constants\");\nconst pointer_1 = require(\"./blocks/pointer\");\nconst set_1 = require(\"./blocks/set\");\nconst iterator_1 = require(\"./iterator\");\nclass Calldata {\n    constructor(rules) {\n        this._rules = rules;\n        this._selector = '';\n        this._root = undefined;\n    }\n    /**\n     * Sets the root calldata block. This block usually corresponds to a Method.\n     */\n    setRoot(block) {\n        this._root = block;\n    }\n    /**\n     * Sets the selector to be prepended onto the calldata.\n     * If the root block was created by a Method then a selector will likely be set.\n     */\n    setSelector(selector) {\n        if (!_.startsWith(selector, '0x')) {\n            throw new Error(`Expected selector to be hex. Missing prefix '0x'`);\n        }\n        else if (selector.length !== constants_1.constants.HEX_SELECTOR_LENGTH_IN_CHARS) {\n            throw new Error(`Invalid selector '${selector}'`);\n        }\n        this._selector = selector;\n    }\n    /**\n     * Iterates through the calldata blocks, starting from the root block, to construct calldata as a hex string.\n     * If the `optimize` flag is set then this calldata will be condensed, to save gas.\n     * If the `annotate` flag is set then this will return human-readable calldata.\n     * If the `annotate` flag is *not* set then this will return EVM-compatible calldata.\n     */\n    toString() {\n        // Sanity check: root block must be set\n        if (this._root === undefined) {\n            throw new Error('expected root');\n        }\n        // Optimize, if flag set\n        if (this._rules.shouldOptimize) {\n            this._optimize();\n        }\n        // Set offsets\n        const iterator = new iterator_1.CalldataIterator(this._root);\n        let offset = 0;\n        for (const block of iterator) {\n            block.setOffset(offset);\n            offset += block.getSizeInBytes();\n        }\n        // Generate hex string\n        const hexString = this._rules.shouldAnnotate\n            ? this._toHumanReadableCallData()\n            : this._toEvmCompatibeCallDataHex();\n        return hexString;\n    }\n    /**\n     * There are three types of calldata blocks: Blob, Set and Pointer.\n     * Scenarios arise where distinct pointers resolve to identical values.\n     * We optimize by keeping only one such instance of the identical value, and redirecting all pointers here.\n     * We keep the last such duplicate value because pointers can only be positive (they cannot point backwards).\n     *\n     * Example #1:\n     *  function f(string[], string[])\n     *  f([\"foo\", \"bar\", \"blitz\"], [\"foo\", \"bar\", \"blitz\"])\n     *  The array [\"foo\", \"bar\", \"blitz\"] will only be included in the calldata once.\n     *\n     * Example #2:\n     *  function f(string[], string)\n     *  f([\"foo\", \"bar\", \"blitz\"], \"foo\")\n     *  The string \"foo\" will only be included in the calldata once.\n     *\n     * Example #3:\n     *  function f((string, uint, bytes), string, uint, bytes)\n     *  f((\"foo\", 5, \"0x05\"), \"foo\", 5, \"0x05\")\n     *  The string \"foo\" and bytes \"0x05\" will only be included in the calldata once.\n     *  The duplicate `uint 5` values cannot be optimized out because they are static values (no pointer points to them).\n     *\n     * @TODO #1:\n     *   This optimization strategy handles blocks that are exact duplicates of one another.\n     *   But what if some block is a combination of two other blocks? Or a subset of another block?\n     *   This optimization problem is not much different from the current implemetation.\n     *   Instead of tracking \"observed\" hashes, at each node we would simply do pattern-matching on the calldata.\n     *   This strategy would be applied after assigning offsets to the tree, rather than before (as in this strategy).\n     *   Note that one consequence of this strategy is pointers may resolve to offsets that are not word-aligned.\n     *   This shouldn't be a problem but further investigation should be done.\n     *\n     * @TODO #2:\n     *   To be done as a follow-up to @TODO #1.\n     *   Since we optimize from the bottom-up, we could be affecting the outcome of a later potential optimization.\n     *   For example, what if by removing one duplicate value we miss out on optimizing another block higher in the tree.\n     *   To handle this case, at each node we can store a candidate optimization in a priority queue (sorted by calldata size).\n     *   At the end of traversing the tree, the candidate at the front of the queue will be the most optimal output.\n     *\n     */\n    _optimize() {\n        // Step 1/1 Create a reverse iterator (starts from the end of the calldata to the beginning)\n        if (this._root === undefined) {\n            throw new Error('expected root');\n        }\n        const iterator = new iterator_1.ReverseCalldataIterator(this._root);\n        // Step 2/2 Iterate over each block, keeping track of which blocks have been seen and pruning redundant blocks.\n        const blocksByHash = {};\n        for (const block of iterator) {\n            // If a block is a pointer and its value has already been observed, then update\n            // the pointer to resolve to the existing value.\n            if (block instanceof pointer_1.PointerCalldataBlock) {\n                const dependencyBlockHashBuf = block.getDependency().computeHash();\n                const dependencyBlockHash = ethUtil.bufferToHex(dependencyBlockHashBuf);\n                if (dependencyBlockHash in blocksByHash) {\n                    const blockWithSameHash = blocksByHash[dependencyBlockHash];\n                    if (blockWithSameHash !== block.getDependency()) {\n                        block.setAlias(blockWithSameHash);\n                    }\n                }\n                continue;\n            }\n            // This block has not been seen. Record its hash.\n            const blockHashBuf = block.computeHash();\n            const blockHash = ethUtil.bufferToHex(blockHashBuf);\n            if (!(blockHash in blocksByHash)) {\n                blocksByHash[blockHash] = block;\n            }\n        }\n    }\n    _toEvmCompatibeCallDataHex() {\n        // Sanity check: must have a root block.\n        if (this._root === undefined) {\n            throw new Error('expected root');\n        }\n        // Construct an array of buffers (one buffer for each block).\n        const selectorBuffer = ethUtil.toBuffer(this._selector);\n        const valueBufs = [selectorBuffer];\n        const iterator = new iterator_1.CalldataIterator(this._root);\n        for (const block of iterator) {\n            valueBufs.push(block.toBuffer());\n        }\n        // Create hex from buffer array.\n        const combinedBuffers = Buffer.concat(valueBufs);\n        const hexValue = ethUtil.bufferToHex(combinedBuffers);\n        return hexValue;\n    }\n    /**\n     * Returns human-readable calldata.\n     *\n     * Example:\n     *   simpleFunction(string[], string[])\n     *   strings = [\"Hello\", \"World\"]\n     *   simpleFunction(strings, strings)\n     *\n     * Output:\n     *   0xbb4f12e3\n     *                                                                                      ### simpleFunction\n     *   0x0       0000000000000000000000000000000000000000000000000000000000000040              ptr<array1> (alias for array2)\n     *   0x20      0000000000000000000000000000000000000000000000000000000000000040              ptr<array2>\n     *\n     *   0x40      0000000000000000000000000000000000000000000000000000000000000002          ### array2\n     *   0x60      0000000000000000000000000000000000000000000000000000000000000040              ptr<array2[0]>\n     *   0x80      0000000000000000000000000000000000000000000000000000000000000080              ptr<array2[1]>\n     *   0xa0      0000000000000000000000000000000000000000000000000000000000000005              array2[0]\n     *   0xc0      48656c6c6f000000000000000000000000000000000000000000000000000000\n     *   0xe0      0000000000000000000000000000000000000000000000000000000000000005              array2[1]\n     *   0x100     576f726c64000000000000000000000000000000000000000000000000000000\n     */\n    _toHumanReadableCallData() {\n        // Sanity check: must have a root block.\n        if (this._root === undefined) {\n            throw new Error('expected root');\n        }\n        // Constants for constructing annotated string\n        const offsetPadding = 10;\n        const valuePadding = 74;\n        const namePadding = 80;\n        const evmWordStartIndex = 0;\n        const emptySize = 0;\n        // Construct annotated calldata\n        let hexValue = `${this._selector}`;\n        let offset = 0;\n        const functionName = this._root.getName();\n        const iterator = new iterator_1.CalldataIterator(this._root);\n        for (const block of iterator) {\n            // Process each block 1 word at a time\n            const size = block.getSizeInBytes();\n            const name = block.getName();\n            const parentName = block.getParentName();\n            const prettyName = name.replace(`${parentName}.`, '').replace(`${functionName}.`, '');\n            // Resulting line will be <offsetStr><valueStr><nameStr>\n            let offsetStr = '';\n            let valueStr = '';\n            let nameStr = '';\n            let lineStr = '';\n            if (size === emptySize) {\n                // This is a Set block with no header.\n                // For example, a tuple or an array with a defined length.\n                offsetStr = ' '.repeat(offsetPadding);\n                valueStr = ' '.repeat(valuePadding);\n                nameStr = `### ${prettyName.padEnd(namePadding)}`;\n                lineStr = `\\n${offsetStr}${valueStr}${nameStr}`;\n            }\n            else {\n                // This block has at least one word of value.\n                offsetStr = `0x${offset.toString(constants_1.constants.HEX_BASE)}`.padEnd(offsetPadding);\n                valueStr = ethUtil\n                    .stripHexPrefix(ethUtil.bufferToHex(block.toBuffer().slice(evmWordStartIndex, constants_1.constants.EVM_WORD_WIDTH_IN_BYTES)))\n                    .padEnd(valuePadding);\n                if (block instanceof set_1.SetCalldataBlock) {\n                    nameStr = `### ${prettyName.padEnd(namePadding)}`;\n                    lineStr = `\\n${offsetStr}${valueStr}${nameStr}`;\n                }\n                else {\n                    nameStr = `    ${prettyName.padEnd(namePadding)}`;\n                    lineStr = `${offsetStr}${valueStr}${nameStr}`;\n                }\n            }\n            // This block has a value that is more than 1 word.\n            for (let j = constants_1.constants.EVM_WORD_WIDTH_IN_BYTES; j < size; j += constants_1.constants.EVM_WORD_WIDTH_IN_BYTES) {\n                offsetStr = `0x${(offset + j).toString(constants_1.constants.HEX_BASE)}`.padEnd(offsetPadding);\n                valueStr = ethUtil\n                    .stripHexPrefix(ethUtil.bufferToHex(block.toBuffer().slice(j, j + constants_1.constants.EVM_WORD_WIDTH_IN_BYTES)))\n                    .padEnd(valuePadding);\n                nameStr = ' '.repeat(namePadding);\n                lineStr = `${lineStr}\\n${offsetStr}${valueStr}${nameStr}`;\n            }\n            // Append to hex value\n            hexValue = `${hexValue}\\n${lineStr}`;\n            offset += size;\n        }\n        return hexValue;\n    }\n}\nexports.Calldata = Calldata;\n//# sourceMappingURL=calldata.js.map"]},"metadata":{},"sourceType":"module"}