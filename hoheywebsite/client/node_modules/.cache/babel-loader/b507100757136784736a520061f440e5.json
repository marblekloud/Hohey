{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ethUtil = require(\"ethereumjs-util\");\n\nconst _ = require(\"lodash\");\n\nconst configured_bignumber_1 = require(\"../../../configured_bignumber\");\n\nconst set_1 = require(\"../../calldata/blocks/set\");\n\nconst constants_1 = require(\"../../utils/constants\");\n\nconst data_type_1 = require(\"../data_type\");\n\nconst pointer_1 = require(\"./pointer\");\n\nclass AbstractSetDataType extends data_type_1.DataType {\n  constructor(dataItem, factory, isArray = false, arrayLength, arrayElementType) {\n    super(dataItem, factory);\n    this._memberIndexByName = {};\n    this._members = [];\n    this._isArray = isArray;\n    this._arrayLength = arrayLength;\n    this._arrayElementType = arrayElementType;\n\n    if (isArray && arrayLength !== undefined) {\n      [this._members, this._memberIndexByName] = this._createMembersWithLength(dataItem, arrayLength);\n    } else if (!isArray) {\n      [this._members, this._memberIndexByName] = this._createMembersWithKeys(dataItem);\n    }\n  }\n\n  generateCalldataBlock(value, parentBlock) {\n    const block = Array.isArray(value) ? this._generateCalldataBlockFromArray(value, parentBlock) : this._generateCalldataBlockFromObject(value, parentBlock);\n    return block;\n  }\n\n  generateValue(calldata, rules) {\n    let members = this._members; // Case 1: This is an array of undefined length, which means that `this._members` was not\n    //         populated in the constructor. So we must construct the set of members now.\n\n    if (this._isArray && this._arrayLength === undefined) {\n      const arrayLengthBuf = calldata.popWord();\n      const arrayLengthHex = ethUtil.bufferToHex(arrayLengthBuf);\n      const arrayLength = new configured_bignumber_1.BigNumber(arrayLengthHex, constants_1.constants.HEX_BASE);\n      [members] = this._createMembersWithLength(this.getDataItem(), arrayLength.toNumber());\n    } // Create a new scope in the calldata, before descending into the members of this set.\n\n\n    calldata.startScope();\n    let value;\n\n    if (rules.shouldConvertStructsToObjects && !this._isArray) {\n      // Construct an object with values for each member of the set.\n      value = {};\n\n      _.each(this._memberIndexByName, (idx, key) => {\n        const member = this._members[idx];\n        const memberValue = member.generateValue(calldata, rules);\n        value[key] = memberValue;\n      });\n    } else {\n      // Construct an array with values for each member of the set.\n      value = [];\n\n      _.each(members, (member, idx) => {\n        const memberValue = member.generateValue(calldata, rules);\n        value.push(memberValue);\n      });\n    } // Close this scope and return tetheh value.\n\n\n    calldata.endScope();\n    return value;\n  }\n\n  isStatic() {\n    // An array with an undefined length is never static.\n    if (this._isArray && this._arrayLength === undefined) {\n      return false;\n    } // If any member of the set is a pointer then the set is not static.\n\n\n    const dependentMember = _.find(this._members, member => {\n      return member instanceof pointer_1.AbstractPointerDataType;\n    });\n\n    const isStatic = dependentMember === undefined;\n    return isStatic;\n  }\n\n  getDefaultValue(rules) {\n    let defaultValue;\n\n    if (this._isArray && this._arrayLength === undefined) {\n      defaultValue = [];\n    } else if (rules !== undefined && rules.shouldConvertStructsToObjects && !this._isArray) {\n      defaultValue = {};\n\n      _.each(this._memberIndexByName, (idx, key) => {\n        const member = this._members[idx];\n        const memberValue = member.getDefaultValue();\n        defaultValue[key] = memberValue;\n      });\n    } else {\n      defaultValue = [];\n\n      _.each(this._members, (member, idx) => {\n        const memberValue = member.getDefaultValue();\n        defaultValue.push(memberValue);\n      });\n    }\n\n    return defaultValue;\n  }\n\n  _generateCalldataBlockFromArray(value, parentBlock) {\n    // Sanity check: if the set has a defined length then `value` must have the same length.\n    if (this._arrayLength !== undefined && value.length !== this._arrayLength) {\n      throw new Error(`Expected array of ${JSON.stringify(this._arrayLength)} elements, but got array of length ${JSON.stringify(value.length)}`);\n    } // Create a new calldata block for this set.\n\n\n    const parentName = parentBlock === undefined ? '' : parentBlock.getName();\n    const block = new set_1.SetCalldataBlock(this.getDataItem().name, this.getSignature(), parentName); // If this set has an undefined length then set its header to be the number of elements.\n\n    let members = this._members;\n\n    if (this._isArray && this._arrayLength === undefined) {\n      [members] = this._createMembersWithLength(this.getDataItem(), value.length);\n      const lenBuf = ethUtil.setLengthLeft(ethUtil.toBuffer(`0x${value.length.toString(constants_1.constants.HEX_BASE)}`), constants_1.constants.EVM_WORD_WIDTH_IN_BYTES);\n      block.setHeader(lenBuf);\n    } // Create blocks for members of set.\n\n\n    const memberCalldataBlocks = [];\n\n    _.each(members, (member, idx) => {\n      const memberBlock = member.generateCalldataBlock(value[idx], block);\n      memberCalldataBlocks.push(memberBlock);\n    });\n\n    block.setMembers(memberCalldataBlocks);\n    return block;\n  }\n\n  _generateCalldataBlockFromObject(obj, parentBlock) {\n    // Create a new calldata block for this set.\n    const parentName = parentBlock === undefined ? '' : parentBlock.getName();\n    const block = new set_1.SetCalldataBlock(this.getDataItem().name, this.getSignature(), parentName); // Create blocks for members of set.\n\n    const memberCalldataBlocks = [];\n\n    _.forEach(this._memberIndexByName, (memberIndex, memberName) => {\n      if (!(memberName in obj)) {\n        throw new Error(`Could not assign tuple to object: missing key '${memberName}' in object ${JSON.stringify(obj)}`);\n      }\n\n      const memberValue = obj[memberName];\n\n      const memberBlock = this._members[memberIndex].generateCalldataBlock(memberValue, block);\n\n      memberCalldataBlocks.push(memberBlock);\n    }); // Associate member blocks with Set block.\n\n\n    block.setMembers(memberCalldataBlocks);\n    return block;\n  }\n\n  _computeSignatureOfMembers(isDetailed) {\n    // Compute signature of members\n    let signature = `(`;\n\n    _.each(this._members, (member, i) => {\n      signature += member.getSignature(isDetailed);\n\n      if (i < this._members.length - 1) {\n        signature += ',';\n      }\n    });\n\n    signature += ')';\n    return signature;\n  }\n\n  _createMembersWithKeys(dataItem) {\n    // Sanity check\n    if (dataItem.components === undefined) {\n      throw new Error(`Tried to create a set using key/value pairs, but no components were defined by the input DataItem '${dataItem.name}'.`);\n    } // Create one member for each component of `dataItem`\n\n\n    const members = [];\n    const memberIndexByName = {};\n    const memberNames = [];\n\n    _.each(dataItem.components, memberItem => {\n      // If a component with `name` already exists then\n      // rename to `name_nameIdx` to avoid naming conflicts.\n      let memberName = memberItem.name;\n      let nameIdx = 0;\n\n      while (_.includes(memberNames, memberName) || _.isEmpty(memberName)) {\n        nameIdx++;\n        memberName = `${memberItem.name}_${nameIdx}`;\n      }\n\n      memberNames.push(memberName);\n      const childDataItem = {\n        type: memberItem.type,\n        name: `${dataItem.name}.${memberName}`\n      };\n      const components = memberItem.components;\n\n      if (components !== undefined) {\n        childDataItem.components = components;\n      }\n\n      const child = this.getFactory().create(childDataItem, this);\n      memberIndexByName[memberName] = members.length;\n      members.push(child);\n    });\n\n    return [members, memberIndexByName];\n  }\n\n  _createMembersWithLength(dataItem, length) {\n    // Create `length` members, deriving the type from `dataItem`\n    const members = [];\n    const memberIndexByName = {};\n\n    const range = _.range(length);\n\n    _.each(range, idx => {\n      const memberDataItem = {\n        type: this._arrayElementType === undefined ? '' : this._arrayElementType,\n        name: `${dataItem.name}[${idx.toString(constants_1.constants.DEC_BASE)}]`\n      };\n      const components = dataItem.components;\n\n      if (components !== undefined) {\n        memberDataItem.components = components;\n      }\n\n      const memberType = this.getFactory().create(memberDataItem, this);\n      memberIndexByName[idx.toString(constants_1.constants.DEC_BASE)] = members.length;\n      members.push(memberType);\n    });\n\n    return [members, memberIndexByName];\n  }\n\n}\n\nexports.AbstractSetDataType = AbstractSetDataType;","map":{"version":3,"sources":["../../../../../src/abi_encoder/abstract_data_types/types/set.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ethUtil = require(\"ethereumjs-util\");\nconst _ = require(\"lodash\");\nconst configured_bignumber_1 = require(\"../../../configured_bignumber\");\nconst set_1 = require(\"../../calldata/blocks/set\");\nconst constants_1 = require(\"../../utils/constants\");\nconst data_type_1 = require(\"../data_type\");\nconst pointer_1 = require(\"./pointer\");\nclass AbstractSetDataType extends data_type_1.DataType {\n    constructor(dataItem, factory, isArray = false, arrayLength, arrayElementType) {\n        super(dataItem, factory);\n        this._memberIndexByName = {};\n        this._members = [];\n        this._isArray = isArray;\n        this._arrayLength = arrayLength;\n        this._arrayElementType = arrayElementType;\n        if (isArray && arrayLength !== undefined) {\n            [this._members, this._memberIndexByName] = this._createMembersWithLength(dataItem, arrayLength);\n        }\n        else if (!isArray) {\n            [this._members, this._memberIndexByName] = this._createMembersWithKeys(dataItem);\n        }\n    }\n    generateCalldataBlock(value, parentBlock) {\n        const block = Array.isArray(value)\n            ? this._generateCalldataBlockFromArray(value, parentBlock)\n            : this._generateCalldataBlockFromObject(value, parentBlock);\n        return block;\n    }\n    generateValue(calldata, rules) {\n        let members = this._members;\n        // Case 1: This is an array of undefined length, which means that `this._members` was not\n        //         populated in the constructor. So we must construct the set of members now.\n        if (this._isArray && this._arrayLength === undefined) {\n            const arrayLengthBuf = calldata.popWord();\n            const arrayLengthHex = ethUtil.bufferToHex(arrayLengthBuf);\n            const arrayLength = new configured_bignumber_1.BigNumber(arrayLengthHex, constants_1.constants.HEX_BASE);\n            [members] = this._createMembersWithLength(this.getDataItem(), arrayLength.toNumber());\n        }\n        // Create a new scope in the calldata, before descending into the members of this set.\n        calldata.startScope();\n        let value;\n        if (rules.shouldConvertStructsToObjects && !this._isArray) {\n            // Construct an object with values for each member of the set.\n            value = {};\n            _.each(this._memberIndexByName, (idx, key) => {\n                const member = this._members[idx];\n                const memberValue = member.generateValue(calldata, rules);\n                value[key] = memberValue;\n            });\n        }\n        else {\n            // Construct an array with values for each member of the set.\n            value = [];\n            _.each(members, (member, idx) => {\n                const memberValue = member.generateValue(calldata, rules);\n                value.push(memberValue);\n            });\n        }\n        // Close this scope and return tetheh value.\n        calldata.endScope();\n        return value;\n    }\n    isStatic() {\n        // An array with an undefined length is never static.\n        if (this._isArray && this._arrayLength === undefined) {\n            return false;\n        }\n        // If any member of the set is a pointer then the set is not static.\n        const dependentMember = _.find(this._members, (member) => {\n            return member instanceof pointer_1.AbstractPointerDataType;\n        });\n        const isStatic = dependentMember === undefined;\n        return isStatic;\n    }\n    getDefaultValue(rules) {\n        let defaultValue;\n        if (this._isArray && this._arrayLength === undefined) {\n            defaultValue = [];\n        }\n        else if (rules !== undefined && rules.shouldConvertStructsToObjects && !this._isArray) {\n            defaultValue = {};\n            _.each(this._memberIndexByName, (idx, key) => {\n                const member = this._members[idx];\n                const memberValue = member.getDefaultValue();\n                defaultValue[key] = memberValue;\n            });\n        }\n        else {\n            defaultValue = [];\n            _.each(this._members, (member, idx) => {\n                const memberValue = member.getDefaultValue();\n                defaultValue.push(memberValue);\n            });\n        }\n        return defaultValue;\n    }\n    _generateCalldataBlockFromArray(value, parentBlock) {\n        // Sanity check: if the set has a defined length then `value` must have the same length.\n        if (this._arrayLength !== undefined && value.length !== this._arrayLength) {\n            throw new Error(`Expected array of ${JSON.stringify(this._arrayLength)} elements, but got array of length ${JSON.stringify(value.length)}`);\n        }\n        // Create a new calldata block for this set.\n        const parentName = parentBlock === undefined ? '' : parentBlock.getName();\n        const block = new set_1.SetCalldataBlock(this.getDataItem().name, this.getSignature(), parentName);\n        // If this set has an undefined length then set its header to be the number of elements.\n        let members = this._members;\n        if (this._isArray && this._arrayLength === undefined) {\n            [members] = this._createMembersWithLength(this.getDataItem(), value.length);\n            const lenBuf = ethUtil.setLengthLeft(ethUtil.toBuffer(`0x${value.length.toString(constants_1.constants.HEX_BASE)}`), constants_1.constants.EVM_WORD_WIDTH_IN_BYTES);\n            block.setHeader(lenBuf);\n        }\n        // Create blocks for members of set.\n        const memberCalldataBlocks = [];\n        _.each(members, (member, idx) => {\n            const memberBlock = member.generateCalldataBlock(value[idx], block);\n            memberCalldataBlocks.push(memberBlock);\n        });\n        block.setMembers(memberCalldataBlocks);\n        return block;\n    }\n    _generateCalldataBlockFromObject(obj, parentBlock) {\n        // Create a new calldata block for this set.\n        const parentName = parentBlock === undefined ? '' : parentBlock.getName();\n        const block = new set_1.SetCalldataBlock(this.getDataItem().name, this.getSignature(), parentName);\n        // Create blocks for members of set.\n        const memberCalldataBlocks = [];\n        _.forEach(this._memberIndexByName, (memberIndex, memberName) => {\n            if (!(memberName in obj)) {\n                throw new Error(`Could not assign tuple to object: missing key '${memberName}' in object ${JSON.stringify(obj)}`);\n            }\n            const memberValue = obj[memberName];\n            const memberBlock = this._members[memberIndex].generateCalldataBlock(memberValue, block);\n            memberCalldataBlocks.push(memberBlock);\n        });\n        // Associate member blocks with Set block.\n        block.setMembers(memberCalldataBlocks);\n        return block;\n    }\n    _computeSignatureOfMembers(isDetailed) {\n        // Compute signature of members\n        let signature = `(`;\n        _.each(this._members, (member, i) => {\n            signature += member.getSignature(isDetailed);\n            if (i < this._members.length - 1) {\n                signature += ',';\n            }\n        });\n        signature += ')';\n        return signature;\n    }\n    _createMembersWithKeys(dataItem) {\n        // Sanity check\n        if (dataItem.components === undefined) {\n            throw new Error(`Tried to create a set using key/value pairs, but no components were defined by the input DataItem '${dataItem.name}'.`);\n        }\n        // Create one member for each component of `dataItem`\n        const members = [];\n        const memberIndexByName = {};\n        const memberNames = [];\n        _.each(dataItem.components, (memberItem) => {\n            // If a component with `name` already exists then\n            // rename to `name_nameIdx` to avoid naming conflicts.\n            let memberName = memberItem.name;\n            let nameIdx = 0;\n            while (_.includes(memberNames, memberName) || _.isEmpty(memberName)) {\n                nameIdx++;\n                memberName = `${memberItem.name}_${nameIdx}`;\n            }\n            memberNames.push(memberName);\n            const childDataItem = {\n                type: memberItem.type,\n                name: `${dataItem.name}.${memberName}`,\n            };\n            const components = memberItem.components;\n            if (components !== undefined) {\n                childDataItem.components = components;\n            }\n            const child = this.getFactory().create(childDataItem, this);\n            memberIndexByName[memberName] = members.length;\n            members.push(child);\n        });\n        return [members, memberIndexByName];\n    }\n    _createMembersWithLength(dataItem, length) {\n        // Create `length` members, deriving the type from `dataItem`\n        const members = [];\n        const memberIndexByName = {};\n        const range = _.range(length);\n        _.each(range, (idx) => {\n            const memberDataItem = {\n                type: this._arrayElementType === undefined ? '' : this._arrayElementType,\n                name: `${dataItem.name}[${idx.toString(constants_1.constants.DEC_BASE)}]`,\n            };\n            const components = dataItem.components;\n            if (components !== undefined) {\n                memberDataItem.components = components;\n            }\n            const memberType = this.getFactory().create(memberDataItem, this);\n            memberIndexByName[idx.toString(constants_1.constants.DEC_BASE)] = members.length;\n            members.push(memberType);\n        });\n        return [members, memberIndexByName];\n    }\n}\nexports.AbstractSetDataType = AbstractSetDataType;\n//# sourceMappingURL=set.js.map"]},"metadata":{},"sourceType":"module"}