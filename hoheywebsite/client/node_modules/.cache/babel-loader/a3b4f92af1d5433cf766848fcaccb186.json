{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst assert_1 = require(\"@0x/assert\");\n\nconst types_1 = require(\"@0x/types\");\n\nconst utils_1 = require(\"@0x/utils\");\n\nconst JsonRpcError = require(\"json-rpc-error\");\n\nconst subprovider_1 = require(\"./subprovider\");\n/**\n * This class implements the [web3-provider-engine](https://github.com/MetaMask/provider-engine) subprovider interface.\n * It forwards on JSON RPC requests to the supplied `rpcUrl` endpoint\n */\n\n\nclass RPCSubprovider extends subprovider_1.Subprovider {\n  /**\n   * @param rpcUrl URL to the backing Ethereum node to which JSON RPC requests should be sent\n   * @param requestTimeoutMs Amount of miliseconds to wait before timing out the JSON RPC request\n   */\n  constructor(rpcUrl, requestTimeoutMs = 20000) {\n    super();\n    assert_1.assert.isString('rpcUrl', rpcUrl);\n    assert_1.assert.isNumber('requestTimeoutMs', requestTimeoutMs);\n    this._rpcUrl = rpcUrl;\n    this._requestTimeoutMs = requestTimeoutMs;\n  }\n  /**\n   * This method conforms to the web3-provider-engine interface.\n   * It is called internally by the ProviderEngine when it is this subproviders\n   * turn to handle a JSON RPC request.\n   * @param payload JSON RPC payload\n   * @param _next Callback to call if this subprovider decides not to handle the request\n   * @param end Callback to call if subprovider handled the request and wants to pass back the request.\n   */\n  // tslint:disable-next-line:prefer-function-over-method async-suffix\n\n\n  handleRequest(payload, _next, end) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const finalPayload = subprovider_1.Subprovider._createFinalPayload(payload);\n\n      const headers = new Headers({\n        Accept: 'application/json',\n        'Content-Type': 'application/json'\n      });\n      let response;\n\n      try {\n        response = yield utils_1.fetchAsync(this._rpcUrl, {\n          method: 'POST',\n          headers,\n          body: JSON.stringify(finalPayload)\n        }, this._requestTimeoutMs);\n      } catch (err) {\n        end(new JsonRpcError.InternalError(err));\n        return;\n      }\n\n      const text = yield response.text();\n\n      if (!response.ok) {\n        const statusCode = response.status;\n\n        switch (statusCode) {\n          case types_1.StatusCodes.MethodNotAllowed:\n            end(new JsonRpcError.MethodNotFound());\n            return;\n\n          case types_1.StatusCodes.GatewayTimeout:\n            const errMsg = 'Gateway timeout. The request took too long to process. This can happen when querying logs over too wide a block range.';\n            const err = new Error(errMsg);\n            end(new JsonRpcError.InternalError(err));\n            return;\n\n          default:\n            end(new JsonRpcError.InternalError(text));\n            return;\n        }\n      }\n\n      let data;\n\n      try {\n        data = JSON.parse(text);\n      } catch (err) {\n        end(new JsonRpcError.InternalError(err));\n        return;\n      }\n\n      if (data.error) {\n        end(data.error);\n        return;\n      }\n\n      end(null, data.result);\n    });\n  }\n\n}\n\nexports.RPCSubprovider = RPCSubprovider;","map":{"version":3,"sources":["../../../src/subproviders/rpc_subprovider.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAA,QAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AAEA,MAAA,YAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AAIA,MAAA,aAAA,GAAA,OAAA,CAAA,eAAA,CAAA;AAEA;;;AAGG;;;AACH,MAAa,cAAb,SAAoC,aAAA,CAAA,WAApC,CAA+C;AAG3C;;;AAGG;AACH,EAAA,WAAA,CAAY,MAAZ,EAA4B,gBAAA,GAA2B,KAAvD,EAA4D;AACxD;AACA,IAAA,QAAA,CAAA,MAAA,CAAO,QAAP,CAAgB,QAAhB,EAA0B,MAA1B;AACA,IAAA,QAAA,CAAA,MAAA,CAAO,QAAP,CAAgB,kBAAhB,EAAoC,gBAApC;AACA,SAAK,OAAL,GAAe,MAAf;AACA,SAAK,iBAAL,GAAyB,gBAAzB;AACH;AACD;;;;;;;AAOG;AACH;;;AACa,EAAA,aAAa,CAAC,OAAD,EAAiC,KAAjC,EAAkD,GAAlD,EAAoE;;AAC1F,YAAM,YAAY,GAAG,aAAA,CAAA,WAAA,CAAY,mBAAZ,CAAgC,OAAhC,CAArB;;AACA,YAAM,OAAO,GAAG,IAAI,OAAJ,CAAY;AACxB,QAAA,MAAM,EAAE,kBADgB;AAExB,wBAAgB;AAFQ,OAAZ,CAAhB;AAKA,UAAI,QAAJ;;AACA,UAAI;AACA,QAAA,QAAQ,GAAG,MAAM,OAAA,CAAA,UAAA,CACb,KAAK,OADQ,EAEb;AACI,UAAA,MAAM,EAAE,MADZ;AAEI,UAAA,OAFJ;AAGI,UAAA,IAAI,EAAE,IAAI,CAAC,SAAL,CAAe,YAAf;AAHV,SAFa,EAOb,KAAK,iBAPQ,CAAjB;AASH,OAVD,CAUE,OAAO,GAAP,EAAY;AACV,QAAA,GAAG,CAAC,IAAI,YAAY,CAAC,aAAjB,CAA+B,GAA/B,CAAD,CAAH;AACA;AACH;;AAED,YAAM,IAAI,GAAG,MAAM,QAAQ,CAAC,IAAT,EAAnB;;AACA,UAAI,CAAC,QAAQ,CAAC,EAAd,EAAkB;AACd,cAAM,UAAU,GAAG,QAAQ,CAAC,MAA5B;;AACA,gBAAQ,UAAR;AACI,eAAK,OAAA,CAAA,WAAA,CAAY,gBAAjB;AACI,YAAA,GAAG,CAAC,IAAI,YAAY,CAAC,cAAjB,EAAD,CAAH;AACA;;AACJ,eAAK,OAAA,CAAA,WAAA,CAAY,cAAjB;AACI,kBAAM,MAAM,GACR,wHADJ;AAEA,kBAAM,GAAG,GAAG,IAAI,KAAJ,CAAU,MAAV,CAAZ;AACA,YAAA,GAAG,CAAC,IAAI,YAAY,CAAC,aAAjB,CAA+B,GAA/B,CAAD,CAAH;AACA;;AACJ;AACI,YAAA,GAAG,CAAC,IAAI,YAAY,CAAC,aAAjB,CAA+B,IAA/B,CAAD,CAAH;AACA;AAZR;AAcH;;AAED,UAAI,IAAJ;;AACA,UAAI;AACA,QAAA,IAAI,GAAG,IAAI,CAAC,KAAL,CAAW,IAAX,CAAP;AACH,OAFD,CAEE,OAAO,GAAP,EAAY;AACV,QAAA,GAAG,CAAC,IAAI,YAAY,CAAC,aAAjB,CAA+B,GAA/B,CAAD,CAAH;AACA;AACH;;AAED,UAAI,IAAI,CAAC,KAAT,EAAgB;AACZ,QAAA,GAAG,CAAC,IAAI,CAAC,KAAN,CAAH;AACA;AACH;;AACD,MAAA,GAAG,CAAC,IAAD,EAAO,IAAI,CAAC,MAAZ,CAAH;AACH,K;AAAA;;AA9E0C;;AAA/C,OAAA,CAAA,cAAA,GAAA,cAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert_1 = require(\"@0x/assert\");\nconst types_1 = require(\"@0x/types\");\nconst utils_1 = require(\"@0x/utils\");\nconst JsonRpcError = require(\"json-rpc-error\");\nconst subprovider_1 = require(\"./subprovider\");\n/**\n * This class implements the [web3-provider-engine](https://github.com/MetaMask/provider-engine) subprovider interface.\n * It forwards on JSON RPC requests to the supplied `rpcUrl` endpoint\n */\nclass RPCSubprovider extends subprovider_1.Subprovider {\n    /**\n     * @param rpcUrl URL to the backing Ethereum node to which JSON RPC requests should be sent\n     * @param requestTimeoutMs Amount of miliseconds to wait before timing out the JSON RPC request\n     */\n    constructor(rpcUrl, requestTimeoutMs = 20000) {\n        super();\n        assert_1.assert.isString('rpcUrl', rpcUrl);\n        assert_1.assert.isNumber('requestTimeoutMs', requestTimeoutMs);\n        this._rpcUrl = rpcUrl;\n        this._requestTimeoutMs = requestTimeoutMs;\n    }\n    /**\n     * This method conforms to the web3-provider-engine interface.\n     * It is called internally by the ProviderEngine when it is this subproviders\n     * turn to handle a JSON RPC request.\n     * @param payload JSON RPC payload\n     * @param _next Callback to call if this subprovider decides not to handle the request\n     * @param end Callback to call if subprovider handled the request and wants to pass back the request.\n     */\n    // tslint:disable-next-line:prefer-function-over-method async-suffix\n    handleRequest(payload, _next, end) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const finalPayload = subprovider_1.Subprovider._createFinalPayload(payload);\n            const headers = new Headers({\n                Accept: 'application/json',\n                'Content-Type': 'application/json',\n            });\n            let response;\n            try {\n                response = yield utils_1.fetchAsync(this._rpcUrl, {\n                    method: 'POST',\n                    headers,\n                    body: JSON.stringify(finalPayload),\n                }, this._requestTimeoutMs);\n            }\n            catch (err) {\n                end(new JsonRpcError.InternalError(err));\n                return;\n            }\n            const text = yield response.text();\n            if (!response.ok) {\n                const statusCode = response.status;\n                switch (statusCode) {\n                    case types_1.StatusCodes.MethodNotAllowed:\n                        end(new JsonRpcError.MethodNotFound());\n                        return;\n                    case types_1.StatusCodes.GatewayTimeout:\n                        const errMsg = 'Gateway timeout. The request took too long to process. This can happen when querying logs over too wide a block range.';\n                        const err = new Error(errMsg);\n                        end(new JsonRpcError.InternalError(err));\n                        return;\n                    default:\n                        end(new JsonRpcError.InternalError(text));\n                        return;\n                }\n            }\n            let data;\n            try {\n                data = JSON.parse(text);\n            }\n            catch (err) {\n                end(new JsonRpcError.InternalError(err));\n                return;\n            }\n            if (data.error) {\n                end(data.error);\n                return;\n            }\n            end(null, data.result);\n        });\n    }\n}\nexports.RPCSubprovider = RPCSubprovider;\n//# sourceMappingURL=rpc_subprovider.js.map"]},"metadata":{},"sourceType":"module"}