{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ethereum_types_1 = require(\"ethereum-types\");\n\nconst ethUtil = require(\"ethereumjs-util\");\n\nconst _ = require(\"lodash\");\n\nconst blob_1 = require(\"../abstract_data_types/types/blob\");\n\nconst constants_1 = require(\"../utils/constants\");\n\nclass AddressDataType extends blob_1.AbstractBlobDataType {\n  constructor(dataItem, dataTypeFactory) {\n    super(dataItem, dataTypeFactory, AddressDataType._SIZE_KNOWN_AT_COMPILE_TIME);\n\n    if (!AddressDataType.matchType(dataItem.type)) {\n      throw new Error(`Tried to instantiate Address with bad input: ${dataItem}`);\n    }\n  }\n\n  static matchType(type) {\n    return type === ethereum_types_1.SolidityTypes.Address;\n  } // Disable prefer-function-over-method for inherited abstract methods.\n\n  /* tslint:disable prefer-function-over-method */\n\n\n  encodeValue(value) {\n    if (!ethUtil.isValidAddress(value)) {\n      throw new Error(`Invalid address: '${value}'`);\n    }\n\n    const valueBuf = ethUtil.toBuffer(value);\n    const encodedValueBuf = ethUtil.setLengthLeft(valueBuf, constants_1.constants.EVM_WORD_WIDTH_IN_BYTES);\n    return encodedValueBuf;\n  }\n\n  decodeValue(calldata) {\n    const valueBufPadded = calldata.popWord();\n    const valueBuf = valueBufPadded.slice(AddressDataType._DECODED_ADDRESS_OFFSET_IN_BYTES);\n    const value = ethUtil.bufferToHex(valueBuf);\n\n    const valueLowercase = _.toLower(value);\n\n    return valueLowercase;\n  }\n\n  getDefaultValue() {\n    return AddressDataType._DEFAULT_VALUE;\n  }\n\n  getSignatureType() {\n    return ethereum_types_1.SolidityTypes.Address;\n  }\n\n}\n\nAddressDataType._SIZE_KNOWN_AT_COMPILE_TIME = true;\nAddressDataType._ADDRESS_SIZE_IN_BYTES = 20;\nAddressDataType._DECODED_ADDRESS_OFFSET_IN_BYTES = constants_1.constants.EVM_WORD_WIDTH_IN_BYTES - AddressDataType._ADDRESS_SIZE_IN_BYTES;\nAddressDataType._DEFAULT_VALUE = '0x0000000000000000000000000000000000000000';\nexports.AddressDataType = AddressDataType;","map":{"version":3,"sources":["../../../../src/abi_encoder/evm_data_types/address.ts"],"names":[],"mappings":";;;;;;AAAA,MAAA,gBAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AACA,MAAA,CAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AAGA,MAAA,MAAA,GAAA,OAAA,CAAA,mCAAA,CAAA;;AAEA,MAAA,WAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;;AAEA,MAAa,eAAb,SAAqC,MAAA,CAAA,oBAArC,CAAyD;AAWrD,EAAA,WAAA,CAAmB,QAAnB,EAAuC,eAAvC,EAAuE;AACnE,UAAM,QAAN,EAAgB,eAAhB,EAAiC,eAAe,CAAC,2BAAjD;;AACA,QAAI,CAAC,eAAe,CAAC,SAAhB,CAA0B,QAAQ,CAAC,IAAnC,CAAL,EAA+C;AAC3C,YAAM,IAAI,KAAJ,CAAU,gDAAgD,QAAQ,EAAlE,CAAN;AACH;AACJ;;AATsB,SAAT,SAAS,CAAC,IAAD,EAAa;AAChC,WAAO,IAAI,KAAK,gBAAA,CAAA,aAAA,CAAc,OAA9B;AACH,GAToD,CAkBrD;;AACA;;;AACO,EAAA,WAAW,CAAC,KAAD,EAAc;AAC5B,QAAI,CAAC,OAAO,CAAC,cAAR,CAAuB,KAAvB,CAAL,EAAoC;AAChC,YAAM,IAAI,KAAJ,CAAU,qBAAqB,KAAK,GAApC,CAAN;AACH;;AACD,UAAM,QAAQ,GAAG,OAAO,CAAC,QAAR,CAAiB,KAAjB,CAAjB;AACA,UAAM,eAAe,GAAG,OAAO,CAAC,aAAR,CAAsB,QAAtB,EAAgC,WAAA,CAAA,SAAA,CAAU,uBAA1C,CAAxB;AACA,WAAO,eAAP;AACH;;AAEM,EAAA,WAAW,CAAC,QAAD,EAAsB;AACpC,UAAM,cAAc,GAAG,QAAQ,CAAC,OAAT,EAAvB;AACA,UAAM,QAAQ,GAAG,cAAc,CAAC,KAAf,CAAqB,eAAe,CAAC,gCAArC,CAAjB;AACA,UAAM,KAAK,GAAG,OAAO,CAAC,WAAR,CAAoB,QAApB,CAAd;;AACA,UAAM,cAAc,GAAG,CAAC,CAAC,OAAF,CAAU,KAAV,CAAvB;;AACA,WAAO,cAAP;AACH;;AAEM,EAAA,eAAe,GAAA;AAClB,WAAO,eAAe,CAAC,cAAvB;AACH;;AAEM,EAAA,gBAAgB,GAAA;AACnB,WAAO,gBAAA,CAAA,aAAA,CAAc,OAArB;AACH;;AA3CoD;;AAC7B,eAAA,CAAA,2BAAA,GAAuC,IAAvC;AACA,eAAA,CAAA,sBAAA,GAAyB,EAAzB;AACA,eAAA,CAAA,gCAAA,GACpB,WAAA,CAAA,SAAA,CAAU,uBAAV,GAAoC,eAAe,CAAC,sBADhC;AAEA,eAAA,CAAA,cAAA,GAAiB,4CAAjB;AAL5B,OAAA,CAAA,eAAA,GAAA,eAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ethereum_types_1 = require(\"ethereum-types\");\nconst ethUtil = require(\"ethereumjs-util\");\nconst _ = require(\"lodash\");\nconst blob_1 = require(\"../abstract_data_types/types/blob\");\nconst constants_1 = require(\"../utils/constants\");\nclass AddressDataType extends blob_1.AbstractBlobDataType {\n    constructor(dataItem, dataTypeFactory) {\n        super(dataItem, dataTypeFactory, AddressDataType._SIZE_KNOWN_AT_COMPILE_TIME);\n        if (!AddressDataType.matchType(dataItem.type)) {\n            throw new Error(`Tried to instantiate Address with bad input: ${dataItem}`);\n        }\n    }\n    static matchType(type) {\n        return type === ethereum_types_1.SolidityTypes.Address;\n    }\n    // Disable prefer-function-over-method for inherited abstract methods.\n    /* tslint:disable prefer-function-over-method */\n    encodeValue(value) {\n        if (!ethUtil.isValidAddress(value)) {\n            throw new Error(`Invalid address: '${value}'`);\n        }\n        const valueBuf = ethUtil.toBuffer(value);\n        const encodedValueBuf = ethUtil.setLengthLeft(valueBuf, constants_1.constants.EVM_WORD_WIDTH_IN_BYTES);\n        return encodedValueBuf;\n    }\n    decodeValue(calldata) {\n        const valueBufPadded = calldata.popWord();\n        const valueBuf = valueBufPadded.slice(AddressDataType._DECODED_ADDRESS_OFFSET_IN_BYTES);\n        const value = ethUtil.bufferToHex(valueBuf);\n        const valueLowercase = _.toLower(value);\n        return valueLowercase;\n    }\n    getDefaultValue() {\n        return AddressDataType._DEFAULT_VALUE;\n    }\n    getSignatureType() {\n        return ethereum_types_1.SolidityTypes.Address;\n    }\n}\nAddressDataType._SIZE_KNOWN_AT_COMPILE_TIME = true;\nAddressDataType._ADDRESS_SIZE_IN_BYTES = 20;\nAddressDataType._DECODED_ADDRESS_OFFSET_IN_BYTES = constants_1.constants.EVM_WORD_WIDTH_IN_BYTES - AddressDataType._ADDRESS_SIZE_IN_BYTES;\nAddressDataType._DEFAULT_VALUE = '0x0000000000000000000000000000000000000000';\nexports.AddressDataType = AddressDataType;\n//# sourceMappingURL=address.js.map"]},"metadata":{},"sourceType":"module"}