{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ethereum_types_1 = require(\"ethereum-types\");\n\nconst ethUtil = require(\"ethereumjs-util\");\n\nconst configured_bignumber_1 = require(\"../../configured_bignumber\");\n\nconst blob_1 = require(\"../abstract_data_types/types/blob\");\n\nconst constants_1 = require(\"../utils/constants\");\n\nclass BoolDataType extends blob_1.AbstractBlobDataType {\n  constructor(dataItem, dataTypeFactory) {\n    super(dataItem, dataTypeFactory, BoolDataType._SIZE_KNOWN_AT_COMPILE_TIME);\n\n    if (!BoolDataType.matchType(dataItem.type)) {\n      throw new Error(`Tried to instantiate Bool with bad input: ${dataItem}`);\n    }\n  }\n\n  static matchType(type) {\n    return type === ethereum_types_1.SolidityTypes.Bool;\n  } // Disable prefer-function-over-method for inherited abstract methods.\n\n  /* tslint:disable prefer-function-over-method */\n\n\n  encodeValue(value) {\n    const encodedValue = value ? '0x1' : '0x0';\n    const encodedValueBuf = ethUtil.setLengthLeft(ethUtil.toBuffer(encodedValue), constants_1.constants.EVM_WORD_WIDTH_IN_BYTES);\n    return encodedValueBuf;\n  }\n\n  decodeValue(calldata) {\n    const valueBuf = calldata.popWord();\n    const valueHex = ethUtil.bufferToHex(valueBuf); // Hack @hysz: there are some cases where `false` is encoded as 0x instead of 0x0.\n\n    const valueNumber = valueHex === '0x' ? new configured_bignumber_1.BigNumber(0) : new configured_bignumber_1.BigNumber(valueHex, constants_1.constants.HEX_BASE);\n\n    if (!(valueNumber.isEqualTo(0) || valueNumber.isEqualTo(1))) {\n      throw new Error(`Failed to decode boolean. Expected 0x0 or 0x1, got ${valueHex}`);\n    }\n    /* tslint:disable boolean-naming */\n\n\n    const value = !valueNumber.isEqualTo(0);\n    /* tslint:enable boolean-naming */\n\n    return value;\n  }\n\n  getDefaultValue() {\n    return BoolDataType._DEFAULT_VALUE;\n  }\n\n  getSignatureType() {\n    return ethereum_types_1.SolidityTypes.Bool;\n  }\n\n}\n\nBoolDataType._SIZE_KNOWN_AT_COMPILE_TIME = true;\nBoolDataType._DEFAULT_VALUE = false;\nexports.BoolDataType = BoolDataType;","map":{"version":3,"sources":["../../../../src/abi_encoder/evm_data_types/bool.ts"],"names":[],"mappings":";;;;;;AAAA,MAAA,gBAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AAGA,MAAA,sBAAA,GAAA,OAAA,CAAA,4BAAA,CAAA;;AAEA,MAAA,MAAA,GAAA,OAAA,CAAA,mCAAA,CAAA;;AAEA,MAAA,WAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;;AAEA,MAAa,YAAb,SAAkC,MAAA,CAAA,oBAAlC,CAAsD;AAQlD,EAAA,WAAA,CAAmB,QAAnB,EAAuC,eAAvC,EAAuE;AACnE,UAAM,QAAN,EAAgB,eAAhB,EAAiC,YAAY,CAAC,2BAA9C;;AACA,QAAI,CAAC,YAAY,CAAC,SAAb,CAAuB,QAAQ,CAAC,IAAhC,CAAL,EAA4C;AACxC,YAAM,IAAI,KAAJ,CAAU,6CAA6C,QAAQ,EAA/D,CAAN;AACH;AACJ;;AATsB,SAAT,SAAS,CAAC,IAAD,EAAa;AAChC,WAAO,IAAI,KAAK,gBAAA,CAAA,aAAA,CAAc,IAA9B;AACH,GANiD,CAelD;;AACA;;;AACO,EAAA,WAAW,CAAC,KAAD,EAAe;AAC7B,UAAM,YAAY,GAAG,KAAK,GAAG,KAAH,GAAW,KAArC;AACA,UAAM,eAAe,GAAG,OAAO,CAAC,aAAR,CACpB,OAAO,CAAC,QAAR,CAAiB,YAAjB,CADoB,EAEpB,WAAA,CAAA,SAAA,CAAU,uBAFU,CAAxB;AAIA,WAAO,eAAP;AACH;;AAEM,EAAA,WAAW,CAAC,QAAD,EAAsB;AACpC,UAAM,QAAQ,GAAG,QAAQ,CAAC,OAAT,EAAjB;AACA,UAAM,QAAQ,GAAG,OAAO,CAAC,WAAR,CAAoB,QAApB,CAAjB,CAFoC,CAGpC;;AACA,UAAM,WAAW,GAAG,QAAQ,KAAK,IAAb,GAAoB,IAAI,sBAAA,CAAA,SAAJ,CAAc,CAAd,CAApB,GAAuC,IAAI,sBAAA,CAAA,SAAJ,CAAc,QAAd,EAAwB,WAAA,CAAA,SAAA,CAAU,QAAlC,CAA3D;;AACA,QAAI,EAAE,WAAW,CAAC,SAAZ,CAAsB,CAAtB,KAA4B,WAAW,CAAC,SAAZ,CAAsB,CAAtB,CAA9B,CAAJ,EAA6D;AACzD,YAAM,IAAI,KAAJ,CAAU,sDAAsD,QAAQ,EAAxE,CAAN;AACH;AACD;;;AACA,UAAM,KAAK,GAAY,CAAC,WAAW,CAAC,SAAZ,CAAsB,CAAtB,CAAxB;AACA;;AACA,WAAO,KAAP;AACH;;AAEM,EAAA,eAAe,GAAA;AAClB,WAAO,YAAY,CAAC,cAApB;AACH;;AAEM,EAAA,gBAAgB,GAAA;AACnB,WAAO,gBAAA,CAAA,aAAA,CAAc,IAArB;AACH;;AA9CiD;;AAC1B,YAAA,CAAA,2BAAA,GAAuC,IAAvC;AACA,YAAA,CAAA,cAAA,GAA0B,KAA1B;AAF5B,OAAA,CAAA,YAAA,GAAA,YAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ethereum_types_1 = require(\"ethereum-types\");\nconst ethUtil = require(\"ethereumjs-util\");\nconst configured_bignumber_1 = require(\"../../configured_bignumber\");\nconst blob_1 = require(\"../abstract_data_types/types/blob\");\nconst constants_1 = require(\"../utils/constants\");\nclass BoolDataType extends blob_1.AbstractBlobDataType {\n    constructor(dataItem, dataTypeFactory) {\n        super(dataItem, dataTypeFactory, BoolDataType._SIZE_KNOWN_AT_COMPILE_TIME);\n        if (!BoolDataType.matchType(dataItem.type)) {\n            throw new Error(`Tried to instantiate Bool with bad input: ${dataItem}`);\n        }\n    }\n    static matchType(type) {\n        return type === ethereum_types_1.SolidityTypes.Bool;\n    }\n    // Disable prefer-function-over-method for inherited abstract methods.\n    /* tslint:disable prefer-function-over-method */\n    encodeValue(value) {\n        const encodedValue = value ? '0x1' : '0x0';\n        const encodedValueBuf = ethUtil.setLengthLeft(ethUtil.toBuffer(encodedValue), constants_1.constants.EVM_WORD_WIDTH_IN_BYTES);\n        return encodedValueBuf;\n    }\n    decodeValue(calldata) {\n        const valueBuf = calldata.popWord();\n        const valueHex = ethUtil.bufferToHex(valueBuf);\n        // Hack @hysz: there are some cases where `false` is encoded as 0x instead of 0x0.\n        const valueNumber = valueHex === '0x' ? new configured_bignumber_1.BigNumber(0) : new configured_bignumber_1.BigNumber(valueHex, constants_1.constants.HEX_BASE);\n        if (!(valueNumber.isEqualTo(0) || valueNumber.isEqualTo(1))) {\n            throw new Error(`Failed to decode boolean. Expected 0x0 or 0x1, got ${valueHex}`);\n        }\n        /* tslint:disable boolean-naming */\n        const value = !valueNumber.isEqualTo(0);\n        /* tslint:enable boolean-naming */\n        return value;\n    }\n    getDefaultValue() {\n        return BoolDataType._DEFAULT_VALUE;\n    }\n    getSignatureType() {\n        return ethereum_types_1.SolidityTypes.Bool;\n    }\n}\nBoolDataType._SIZE_KNOWN_AT_COMPILE_TIME = true;\nBoolDataType._DEFAULT_VALUE = false;\nexports.BoolDataType = BoolDataType;\n//# sourceMappingURL=bool.js.map"]},"metadata":{},"sourceType":"module"}