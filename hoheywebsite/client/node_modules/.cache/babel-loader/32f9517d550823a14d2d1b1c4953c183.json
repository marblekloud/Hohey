{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ethereum_types_1 = require(\"ethereum-types\");\n\nconst configured_bignumber_1 = require(\"../../configured_bignumber\");\n\nconst blob_1 = require(\"../abstract_data_types/types/blob\");\n\nconst constants_1 = require(\"../utils/constants\");\n\nconst EncoderMath = require(\"../utils/math\");\n\nclass IntDataType extends blob_1.AbstractBlobDataType {\n  constructor(dataItem, dataTypeFactory) {\n    super(dataItem, dataTypeFactory, IntDataType._SIZE_KNOWN_AT_COMPILE_TIME);\n\n    if (!IntDataType.matchType(dataItem.type)) {\n      throw new Error(`Tried to instantiate Int with bad input: ${dataItem}`);\n    }\n\n    this._width = IntDataType._decodeWidthFromType(dataItem.type);\n    this._minValue = new configured_bignumber_1.BigNumber(2).exponentiatedBy(this._width - 1).times(-1);\n    this._maxValue = new configured_bignumber_1.BigNumber(2).exponentiatedBy(this._width - 1).minus(1);\n  }\n\n  static matchType(type) {\n    return IntDataType._MATCHER.test(type);\n  }\n\n  static _decodeWidthFromType(type) {\n    const matches = IntDataType._MATCHER.exec(type);\n\n    const width = matches !== null && matches.length === 2 && matches[1] !== undefined ? parseInt(matches[1], constants_1.constants.DEC_BASE) : IntDataType._DEFAULT_WIDTH;\n    return width;\n  }\n\n  encodeValue(value) {\n    const encodedValue = EncoderMath.safeEncodeNumericValue(value, this._minValue, this._maxValue);\n    return encodedValue;\n  }\n\n  decodeValue(calldata) {\n    const valueBuf = calldata.popWord();\n    const value = EncoderMath.safeDecodeNumericValue(valueBuf, this._minValue, this._maxValue);\n\n    if (this._width === constants_1.constants.NUMBER_OF_BYTES_IN_INT8) {\n      return value.toNumber();\n    }\n\n    return value;\n  }\n\n  getDefaultValue() {\n    const defaultValue = IntDataType._DEFAULT_VALUE;\n\n    if (this._width === constants_1.constants.NUMBER_OF_BYTES_IN_INT8) {\n      return defaultValue.toNumber();\n    }\n\n    return defaultValue;\n  }\n\n  getSignatureType() {\n    return `${ethereum_types_1.SolidityTypes.Int}${this._width}`;\n  }\n\n}\n\nIntDataType._MATCHER = RegExp('^int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256){0,1}$');\nIntDataType._SIZE_KNOWN_AT_COMPILE_TIME = true;\nIntDataType._MAX_WIDTH = 256;\nIntDataType._DEFAULT_WIDTH = IntDataType._MAX_WIDTH;\nIntDataType._DEFAULT_VALUE = new configured_bignumber_1.BigNumber(0);\nexports.IntDataType = IntDataType;","map":{"version":3,"sources":["../../../../src/abi_encoder/evm_data_types/int.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ethereum_types_1 = require(\"ethereum-types\");\nconst configured_bignumber_1 = require(\"../../configured_bignumber\");\nconst blob_1 = require(\"../abstract_data_types/types/blob\");\nconst constants_1 = require(\"../utils/constants\");\nconst EncoderMath = require(\"../utils/math\");\nclass IntDataType extends blob_1.AbstractBlobDataType {\n    constructor(dataItem, dataTypeFactory) {\n        super(dataItem, dataTypeFactory, IntDataType._SIZE_KNOWN_AT_COMPILE_TIME);\n        if (!IntDataType.matchType(dataItem.type)) {\n            throw new Error(`Tried to instantiate Int with bad input: ${dataItem}`);\n        }\n        this._width = IntDataType._decodeWidthFromType(dataItem.type);\n        this._minValue = new configured_bignumber_1.BigNumber(2).exponentiatedBy(this._width - 1).times(-1);\n        this._maxValue = new configured_bignumber_1.BigNumber(2).exponentiatedBy(this._width - 1).minus(1);\n    }\n    static matchType(type) {\n        return IntDataType._MATCHER.test(type);\n    }\n    static _decodeWidthFromType(type) {\n        const matches = IntDataType._MATCHER.exec(type);\n        const width = matches !== null && matches.length === 2 && matches[1] !== undefined\n            ? parseInt(matches[1], constants_1.constants.DEC_BASE)\n            : IntDataType._DEFAULT_WIDTH;\n        return width;\n    }\n    encodeValue(value) {\n        const encodedValue = EncoderMath.safeEncodeNumericValue(value, this._minValue, this._maxValue);\n        return encodedValue;\n    }\n    decodeValue(calldata) {\n        const valueBuf = calldata.popWord();\n        const value = EncoderMath.safeDecodeNumericValue(valueBuf, this._minValue, this._maxValue);\n        if (this._width === constants_1.constants.NUMBER_OF_BYTES_IN_INT8) {\n            return value.toNumber();\n        }\n        return value;\n    }\n    getDefaultValue() {\n        const defaultValue = IntDataType._DEFAULT_VALUE;\n        if (this._width === constants_1.constants.NUMBER_OF_BYTES_IN_INT8) {\n            return defaultValue.toNumber();\n        }\n        return defaultValue;\n    }\n    getSignatureType() {\n        return `${ethereum_types_1.SolidityTypes.Int}${this._width}`;\n    }\n}\nIntDataType._MATCHER = RegExp('^int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256){0,1}$');\nIntDataType._SIZE_KNOWN_AT_COMPILE_TIME = true;\nIntDataType._MAX_WIDTH = 256;\nIntDataType._DEFAULT_WIDTH = IntDataType._MAX_WIDTH;\nIntDataType._DEFAULT_VALUE = new configured_bignumber_1.BigNumber(0);\nexports.IntDataType = IntDataType;\n//# sourceMappingURL=int.js.map"]},"metadata":{},"sourceType":"module"}